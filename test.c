/* This file was generated by the Hex-Rays decompiler version 8.3.0.230608.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

int __cdecl sub_4010A0(unsigned __int16 *a1);
int __cdecl sub_4010E0(_WORD *a1);
int __cdecl sub_401158(_WORD *a1);
char __cdecl sub_4011D0(_WORD *a1);
char __cdecl sub_40125D(unsigned __int8 *a1);
char sub_4015F6();
int __cdecl sub_4017C1(_BYTE *a1, _BYTE *a2);
int __cdecl sub_4019F0(char a1, _BYTE *a2);
size_t __cdecl sub_401A56(unsigned __int8 a1);
int __cdecl sub_401C1E(unsigned __int16 a1, char *Buffer);
char __cdecl sub_401D4C(int a1, int a2);
char sub_401E02();
__int16 __cdecl sub_401EBD(__int16 a1);
__int16 __cdecl sub_401F69(int a1);
int sub_401FF0();
int __cdecl sub_402486(int Value); // idb
int sub_402593();
int __cdecl sub_402616(signed __int16 a1, __int16 a2);
int __cdecl sub_402705(int a1);
char __cdecl sub_40292E(char a1);
int __cdecl sub_402976(char a1);
int __cdecl sub_4029B2(char a1);
int sub_402A16();
int __cdecl sub_402EAE(int a1, int a2);
int __cdecl sub_402FA2(int a1, const char *a2);
void __cdecl sub_4033C6(int a1);
int __cdecl sub_4033FF(__int16 a1);
char *__cdecl sub_40343B(char a1);
char *sub_403482();
int sub_4035F1();
__int16 sub_403826();
int __cdecl main(int argc, const char **argv, const char **envp);
_BYTE *__cdecl sub_404FBF(_BYTE *a1, _BYTE *a2);
int __cdecl sub_405005(char *Str); // idb
size_t __cdecl sub_40517C(char *Str, int a2);
_BYTE *__cdecl sub_4051E4(_BYTE *a1, _BYTE *a2);
_BYTE *__cdecl sub_40526F(_BYTE *a1);
int __cdecl sub_4052AE(int a1);
int sub_40546B();
char sub_405950();
char sub_405985();
char sub_4059A0();
char sub_405A5A();
char __cdecl sub_405AC0(char a1, _DWORD *a2);
char __cdecl sub_405D73(char a1, _DWORD *a2);
char sub_405E67();
char sub_405ED7();
char __cdecl sub_405EFE(unsigned __int8 a1);
char sub_405F84();
char sub_406150();
char sub_4061CF();
char sub_4061F6();
char sub_40626B();
char sub_406357();
char sub_4063F0();
char sub_40640D();
char sub_406460();
char __cdecl sub_40648C(char a1);
char __cdecl sub_406503(_BYTE *a1);
char __cdecl sub_406578(int a1);
char __cdecl sub_4066E9(int a1, _BYTE *a2);
char __cdecl sub_4067B6(_BYTE *a1);
char __cdecl sub_406879(_BYTE *a1);
char __cdecl sub_406A6A(int a1);
char __cdecl sub_406B58(char a1);
char __cdecl sub_406BE7(char a1);
char sub_406D17();
char __cdecl sub_406DBA(unsigned __int16 a1);
char __cdecl sub_406E8B(unsigned __int16 a1);
__int16 __cdecl sub_406F2C(int a1, int a2);
char __cdecl sub_406FBC(unsigned __int8 a1, char a2);
char sub_4070AB();
char __cdecl sub_40713F(unsigned __int16 a1);
char __cdecl sub_4071D1(unsigned __int8 a1, char a2);
char sub_4072D7();
char __cdecl sub_40739D(unsigned __int8 a1);
char __cdecl sub_407412(char a1);
char sub_40747A();
char sub_4074C8();
char sub_407595();
char __cdecl sub_407612(char a1);
char __cdecl sub_40764C(char a1, char a2);
char __cdecl sub_407690(char a1);
char __cdecl sub_40774E(char a1);
char __cdecl sub_4077C0(char a1);
char __cdecl sub_407850(char a1);
char __cdecl sub_4078D9(char a1);
char sub_407936();
char sub_40797B();
char __cdecl sub_407A1C(char a1, char a2);
char __cdecl sub_407A72(char a1);
char __cdecl sub_407B7D(char a1);
char __cdecl sub_407BA9(char a1, unsigned __int8 a2);
char __cdecl sub_407F10(_WORD *a1);
char sub_407FB6();
char __cdecl sub_408102(unsigned __int16 a1);
char __cdecl sub_408141(unsigned __int16 a1);
char __cdecl sub_408180(char a1);
char __cdecl sub_4081E0(__int16 a1);
char __cdecl sub_40837F(unsigned __int16 *a1);
char __cdecl sub_408400(unsigned __int16 a1);
char __cdecl sub_4084E5(unsigned __int8 a1);
char __cdecl sub_4085E3(unsigned __int8 a1);
char __cdecl sub_408840(unsigned __int16 *a1);
char __cdecl sub_408912(unsigned __int16 *a1);
char __cdecl sub_408A2F(unsigned __int16 *a1);
char __cdecl sub_408B3E(unsigned __int16 a1);
char __cdecl sub_408C40(unsigned __int16 a1);
char __cdecl sub_408D50(unsigned __int16 a1, int *a2, char *a3);
char __cdecl sub_408D85(int *a1, char *a2);
char __cdecl sub_408E3C(unsigned __int16 a1);
char __cdecl sub_408E9C(unsigned __int16 a1);
char sub_408F6D();
char sub_409005();
char __cdecl sub_40910A(unsigned __int16 a1);
char __cdecl sub_4091B9(__int16 a1);
char __cdecl sub_409CDA(unsigned __int16 a1);
char __cdecl sub_409E07(unsigned __int16 a1);
char __cdecl sub_40A080(unsigned __int16 *a1, _BYTE *a2, _BYTE *a3);
char __cdecl sub_40A247(unsigned __int16 a1);
char __cdecl sub_40A485(unsigned __int16 a1);
char sub_40A65D();
char sub_40A836();
char __cdecl sub_40A9D0(unsigned __int16 a1);
char __cdecl sub_40ABAB(unsigned __int16 a1, _BYTE *a2);
char __cdecl sub_40AC90(__int16 a1, unsigned __int8 a2, char a3);
// int __setargv(void); weak
void sub_40AE73();
int sub_40AE82();
char __cdecl sub_40AE8C(char a1);
char sub_40AE99();
char sub_40AEB0();
char __cdecl sub_40AEF2(int a1);
char __cdecl sub_40AF8D(int a1, _DWORD *a2);
char sub_40B13D();
char __cdecl sub_40B17B(_DWORD *a1);
char sub_40B1B9();
char __cdecl sub_40B217(_DWORD *a1);
char sub_40B2D6();
int sub_40B33C();
char sub_40B36F();
char __cdecl sub_40B47C(_DWORD *a1);
char __cdecl sub_40B4F0(int a1);
char sub_40B70D();
char __cdecl sub_40B940(_BYTE *a1);
char sub_40BAF2();
char sub_40BBE4();
char __cdecl sub_40BC76(_DWORD *a1);
char sub_40BF66();
char sub_40C1CC();
char sub_40C31C();
char sub_40C38E();
char sub_40C3C7();
char __cdecl sub_40C3D8(_BYTE *a1);
char __cdecl sub_40C5B9(unsigned __int8 a1);
char sub_40C6E7();
char sub_40CD04();
char sub_40CED8();
char __cdecl sub_40D675(unsigned __int8 a1);
char __cdecl sub_40D6D9(unsigned __int8 a1);
char __cdecl sub_40D73D(unsigned __int8 a1);
char sub_40D7D6();
char sub_40D891();
char __cdecl sub_40D93B(char a1, unsigned __int8 a2);
char sub_40DA90();
char sub_40DB3A();
char __cdecl sub_40DC5D(char a1);
char __cdecl sub_40DDC3(char a1);
char __cdecl sub_40DEDE(char a1);
char sub_40DFBB();
char sub_40E0BC();
char __cdecl sub_40E268(unsigned __int8 a1);
int sub_40E330();
int sub_40E930();
__int16 __cdecl sub_40EC2D(char *FileName);
__int16 __cdecl sub_40F337(char *Buf1, char *a2, _WORD *a3);
char *__cdecl sub_40FA4C(char *a1, char *a2, char *a3);
__int16 __cdecl sub_40FC1E(char *Str1, char *Source);
char *__cdecl sub_40FE21(char *Str2);
char *__cdecl sub_40FE62(int a1, char *Destination);
int sub_410029();
__int16 __cdecl sub_410170(__int16 a1);
int __cdecl sub_4105EE(__int16 a1, const char *a2, const char *a3, __int16 a4);
int __cdecl sub_4107BD(_BYTE *a1, _BYTE *a2, _BYTE *a3);
char *__cdecl sub_41083F(unsigned __int8 *a1, char *Destination, unsigned __int8 a3);
BOOL __cdecl sub_410A33(char a1, unsigned __int8 *a2);
char __cdecl sub_410A93(char a1, unsigned __int8 *a2, char *Buffer);
int __cdecl sub_410AFD(void *Buf1, _BYTE *a2);
int __cdecl sub_410B92(void *Buf1, _BYTE *a2);
BOOL __cdecl sub_410C27(unsigned __int8 *a1);
BOOL __cdecl sub_410C82(unsigned __int8 *a1);
BOOL __cdecl sub_410CDD(unsigned __int8 *a1);
int __cdecl sub_410D33(unsigned __int8 a1);
int sub_410D70();
// int __cdecl ftell(FILE *Stream);
// int __cdecl fgetc(FILE *Stream);
int __cdecl sub_4111A0(int C); // idb
// char *__cdecl strncpy(char *Destination, const char *Source, size_t Count);
// int __cdecl strcmp(const char *Str1, const char *Str2);
// size_t __cdecl strlen(const char *Str);
// char *__cdecl strcpy(char *Destination, const char *Source);
// char *__cdecl strcat(char *Destination, const char *Source);
// int __cdecl fclose(FILE *Stream);
// int printf(const char *const Format, ...);
// char *__cdecl fgets(char *Buffer, int MaxCount, FILE *Stream);
// int fscanf(FILE *const Stream, const char *const Format, ...);
// FILE *__cdecl fopen(const char *FileName, const char *Mode);
// int __cdecl fseek(FILE *Stream, int Offset, int Origin);
// void __cdecl __noreturn longjmp(jmp_buf Buf, int Value);
// int __cdecl fflush(FILE *Stream);
// char *__cdecl getenv(const char *VarName);
// int __cdecl puts(const char *Buffer);
// int sprintf(char *const Buffer, const char *const Format, ...);
// int __cdecl fputc(int Character, FILE *Stream);
// int __cdecl atol(const char *String);
// int fprintf(FILE *const Stream, const char *const Format, ...);
// char *__cdecl ctime(const __time32_t *const Time);
// __time32_t __cdecl time(__time32_t *const Time);
// int __cdecl system(const char *Command);
// int __cdecl remove(const char *FileName);
// void __cdecl _splitpath(const char *FullPath, char *Drive, char *Dir, char *Filename, char *Ext);
// int __cdecl _findfirst(LPCSTR lpFileName, int); idb
// int __cdecl _findnext(HANDLE hFindFile, int); idb
// char *__cdecl strchr(const char *Str, int Val);
// char *__cdecl strrchr(const char *Str, int Ch);
// void __cdecl _searchenv(const char *Filename, const char *VarName, char *Buffer);
// char *__cdecl strstr(const char *Str, const char *SubStr);
// void __cdecl __noreturn exit(int Code);
// _DWORD __cdecl _setjmp3(_DWORD, _DWORD, _DWORD, _DWORD, char); weak
// int __cdecl fputs(const char *Buffer, FILE *Stream);
// int __cdecl strncmp(const char *Str1, const char *Str2, size_t MaxCount);
// void __cdecl free(void *Block);
// int __cdecl _flsbuf(int Ch, FILE *File);
// void *__cdecl malloc(size_t Size);
// void *__cdecl memset(void *, int Val, size_t Size);
// unsigned int __cdecl _mbcjmstojis(unsigned int C);
int __cdecl sub_412C60(int a1);
// _DWORD __cdecl getSystemCP(_DWORD); weak
// _DWORD __cdecl CPtoLCID(_DWORD); weak
// int setSBCS(void); weak
unsigned int sub_412F60();
UINT sub_413140();
// int __cdecl memcmp(const void *Buf1, const void *Buf2, size_t Size);
// void *__cdecl memcpy(void *, const void *Src, size_t Size);
int __cdecl sub_413A90(LCID Locale, DWORD dwMapFlags, LPCSTR lpSrcStr, LPCWCH lpWideCharStr, LPSTR lpDestStr, int cchDest, UINT CodePage, int a8); // idb
// _DWORD __cdecl strncnt(_DWORD, _DWORD); weak
// int __cdecl _isctype(int C, int Type);
int __cdecl sub_413EB0(int a1);
// int __cdecl _access(const char *FileName, int AccessMode);
// int __cdecl _isatty(int FileHandle);
// void *__cdecl calloc(size_t Count, size_t Size);
int __cdecl sub_417670(DWORD dwInfoType, LPCSTR lpSrcStr, int cchSrc, LPWORD lpCharType, UINT CodePage, LCID Locale, int a7); // idb
BOOL __cdecl sub_4195B0(_DWORD *a1);
// _DWORD __cdecl cvtdate(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD); weak
// char *__cdecl _itoa(int Value, char *Buffer, int Radix);
// char *__cdecl _ltoa(int Value, char *Buffer, int Radix);
// int __cdecl _strnicmp(const char *String1, const char *String2, size_t MaxCount);
// int __cdecl _stat(const char *const FileName, struct _stat32 *const Stat);
int __cdecl sub_41B3F0(int C); // idb
int __cdecl sub_41B4F0(char *String1, char *String2); // idb
unsigned int __cdecl sub_41B6C0(unsigned int SrcStr);
// int __cdecl _strcmpi(const char *String1, const char *String2);

//-------------------------------------------------------------------------
// Data declarations

// extern int (__stdcall *LCMapStringW)(LCID Locale, DWORD dwMapFlags, LPCWSTR lpSrcStr, int cchSrc, LPWSTR lpDestStr, int cchDest);
// extern FARPROC (__stdcall *GetProcAddress)(HMODULE hModule, LPCSTR lpProcName);
// extern HMODULE (__stdcall *LoadLibraryA)(LPCSTR lpLibFileName);
// extern BOOL (__stdcall *GetCPInfo)(UINT CodePage, LPCPINFO lpCPInfo);
// extern int (__stdcall *MultiByteToWideChar)(UINT CodePage, DWORD dwFlags, LPCCH lpMultiByteStr, int cbMultiByte, LPWSTR lpWideCharStr, int cchWideChar);
// extern int (__stdcall *WideCharToMultiByte)(UINT CodePage, DWORD dwFlags, LPCWCH lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr, int cbMultiByte, LPCCH lpDefaultChar, LPBOOL lpUsedDefaultChar);
// extern int (__stdcall *LCMapStringA)(LCID Locale, DWORD dwMapFlags, LPCSTR lpSrcStr, int cchSrc, LPSTR lpDestStr, int cchDest);
// extern BOOL (__stdcall *FreeLibrary)(HMODULE hLibModule);
// extern BOOL (__stdcall *GetStringTypeA)(LCID Locale, DWORD dwInfoType, LPCSTR lpSrcStr, int cchSrc, LPWORD lpCharType);
// extern BOOL (__stdcall *GetStringTypeW)(DWORD dwInfoType, LPCWCH lpSrcStr, int cchSrc, LPWORD lpCharType);
const CHAR String1[4] = { '\0', '\0', '\0', '\0' }; // idb
const WCHAR String2 = 0u; // idb
__int16 word_41D030[] = { 8503 }; // weak
__int16 word_41E398[2484] =
{
  1904,
  512,
  514,
  516,
  518,
  520,
  522,
  524,
  526,
  528,
  530,
  532,
  534,
  536,
  538,
  540,
  542,
  544,
  546,
  548,
  550,
  552,
  554,
  556,
  558,
  560,
  562,
  564,
  566,
  568,
  570,
  572,
  574,
  576,
  578,
  580,
  582,
  584,
  586,
  588,
  590,
  592,
  594,
  596,
  598,
  600,
  602,
  604,
  606,
  608,
  610,
  612,
  614,
  616,
  618,
  620,
  622,
  624,
  626,
  628,
  630,
  632,
  634,
  636,
  638,
  640,
  642,
  644,
  646,
  648,
  650,
  652,
  654,
  656,
  658,
  660,
  662,
  664,
  666,
  668,
  674,
  676,
  1928,
  1930,
  1126,
  1128,
  1130,
  1926,
  1282,
  1284,
  774,
  1090,
  1286,
  1288,
  822,
  1410,
  802,
  900,
  1412,
  814,
  1132,
  1134,
  1136,
  846,
  1290,
  1292,
  1294,
  786,
  1414,
  1978,
  1416,
  1688,
  1418,
  1420,
  1422,
  1424,
  1138,
  1140,
  1142,
  1144,
  1146,
  1980,
  1050,
  1148,
  928,
  1150,
  1296,
  714,
  1298,
  1906,
  1300,
  1302,
  1036,
  1304,
  850,
  1306,
  982,
  980,
  1426,
  1428,
  768,
  1430,
  818,
  1984,
  1152,
  758,
  1154,
  696,
  1156,
  1158,
  1308,
  1310,
  1064,
  1312,
  2006,
  886,
  1854,
  1114,
  1314,
  1976,
  1316,
  1432,
  1434,
  1160,
  950,
  1162,
  1318,
  1988,
  1910,
  1320,
  1322,
  1924,
  838,
  1324,
  1956,
  1326,
  1436,
  964,
  1438,
  1440,
  1442,
  1444,
  1446,
  1120,
  816,
  1028,
  1164,
  864,
  884,
  1166,
  1168,
  1170,
  1172,
  1954,
  1328,
  1330,
  1048,
  1332,
  1334,
  1460,
  1462,
  1464,
  1466,
  1982,
  1458,
  940,
  1866,
  1104,
  1174,
  1176,
  1178,
  1180,
  1182,
  1336,
  1338,
  1340,
  1080,
  1024,
  1342,
  1448,
  912,
  1450,
  1452,
  1454,
  732,
  1052,
  1456,
  868,
  1184,
  1186,
  1074,
  1188,
  1190,
  1192,
  688,
  698,
  1016,
  1124,
  1344,
  1346,
  1348,
  1034,
  1468,
  778,
  684,
  1470,
  1116,
  1194,
  1196,
  1198,
  1200,
  1202,
  1204,
  1206,
  966,
  1208,
  1210,
  832,
  790,
  1350,
  1352,
  1032,
  1008,
  1960,
  1994,
  954,
  1354,
  952,
  1944,
  1474,
  1476,
  1992,
  1478,
  1872,
  1480,
  1472,
  748,
  1212,
  716,
  1214,
  894,
  1934,
  1216,
  1218,
  1220,
  1222,
  888,
  918,
  730,
  934,
  914,
  1356,
  1482,
  944,
  736,
  910,
  1484,
  1486,
  1488,
  742,
  1224,
  1986,
  1226,
  1228,
  1568,
  996,
  972,
  706,
  1358,
  1360,
  1362,
  792,
  672,
  1490,
  810,
  720,
  1492,
  1230,
  1232,
  942,
  1234,
  1236,
  1238,
  820,
  738,
  854,
  1054,
  760,
  1364,
  1066,
  1366,
  794,
  1078,
  1494,
  1864,
  2000,
  962,
  1496,
  1498,
  1004,
  1500,
  1504,
  1502,
  784,
  826,
  1240,
  1000,
  1242,
  844,
  1244,
  766,
  1246,
  1782,
  690,
  852,
  1368,
  1370,
  1372,
  1374,
  1376,
  1378,
  1506,
  1508,
  764,
  870,
  1948,
  812,
  1102,
  678,
  1510,
  858,
  1998,
  1512,
  1068,
  1248,
  880,
  988,
  1250,
  1252,
  1380,
  1382,
  1384,
  1388,
  1386,
  946,
  1514,
  1516,
  974,
  1118,
  1518,
  1030,
  956,
  1520,
  866,
  1254,
  1256,
  708,
  1258,
  1260,
  1262,
  938,
  1390,
  1392,
  1394,
  1996,
  1396,
  1398,
  1968,
  1400,
  740,
  1522,
  1524,
  1526,
  1122,
  1084,
  1528,
  1264,
  1266,
  1056,
  1268,
  1270,
  1272,
  1274,
  1070,
  1276,
  862,
  1278,
  762,
  1280,
  804,
  1402,
  1404,
  1406,
  890,
  1408,
  1860,
  1010,
  1530,
  1532,
  772,
  1534,
  692,
  1536,
  2014,
  686,
  1538,
  724,
  2016,
  1870,
  1540,
  1632,
  1634,
  1636,
  1638,
  2018,
  1640,
  718,
  1642,
  1644,
  896,
  1754,
  1756,
  1758,
  920,
  1760,
  1762,
  1764,
  1766,
  782,
  1018,
  1542,
  1546,
  1544,
  1646,
  670,
  1648,
  1650,
  930,
  1652,
  936,
  808,
  828,
  994,
  1768,
  1908,
  1770,
  754,
  1112,
  1098,
  1548,
  1552,
  1868,
  1946,
  750,
  1550,
  1110,
  1558,
  1942,
  1554,
  1556,
  1654,
  1656,
  1658,
  992,
  1660,
  1662,
  1664,
  1772,
  1060,
  1774,
  712,
  1776,
  1778,
  1780,
  958,
  1020,
  1560,
  872,
  1562,
  908,
  1564,
  702,
  806,
  1666,
  798,
  1668,
  1670,
  776,
  1672,
  1674,
  1784,
  728,
  1786,
  1096,
  1788,
  1790,
  1936,
  1566,
  1570,
  916,
  700,
  1572,
  1970,
  780,
  1676,
  1678,
  1792,
  1076,
  898,
  1046,
  1932,
  1990,
  1794,
  1966,
  1972,
  1574,
  1576,
  770,
  744,
  1680,
  830,
  968,
  726,
  752,
  834,
  1964,
  1914,
  1044,
  1578,
  824,
  1580,
  1582,
  1584,
  1682,
  1100,
  878,
  1684,
  1686,
  1690,
  1692,
  710,
  1796,
  1798,
  836,
  1938,
  2008,
  1586,
  1588,
  1590,
  1952,
  876,
  1940,
  1012,
  2012,
  1694,
  1696,
  1698,
  1700,
  1092,
  1800,
  1802,
  1592,
  1594,
  1596,
  1598,
  2020,
  1042,
  788,
  2022,
  1900,
  1958,
  1950,
  1088,
  734,
  1804,
  1806,
  1808,
  1810,
  948,
  1082,
  1812,
  1600,
  1602,
  998,
  904,
  978,
  842,
  1702,
  1704,
  922,
  1706,
  1814,
  848,
  906,
  1816,
  932,
  1026,
  892,
  1604,
  1606,
  840,
  1912,
  1608,
  1610,
  1612,
  1058,
  1708,
  1022,
  1710,
  1712,
  1006,
  1714,
  986,
  1062,
  1716,
  1718,
  1720,
  1722,
  1818,
  874,
  722,
  1820,
  2010,
  1840,
  746,
  694,
  1614,
  682,
  1072,
  924,
  1842,
  1962,
  1616,
  1830,
  990,
  1618,
  960,
  1002,
  860,
  1724,
  1726,
  704,
  926,
  1728,
  1730,
  1856,
  1824,
  1822,
  1844,
  1834,
  1848,
  1620,
  1038,
  1902,
  1622,
  1624,
  984,
  1734,
  1736,
  1738,
  856,
  1740,
  1742,
  1826,
  2004,
  1838,
  902,
  1832,
  976,
  1626,
  1106,
  1094,
  1628,
  1630,
  882,
  1040,
  2002,
  1744,
  756,
  800,
  1014,
  1862,
  1746,
  680,
  796,
  1852,
  1858,
  1836,
  1828,
  1850,
  1846,
  1108,
  1086,
  970,
  1974,
  1748,
  1750,
  1732,
  1752,
  1874,
  1876,
  1878,
  1880,
  1882,
  1884,
  1886,
  1888,
  1890,
  1892,
  1894,
  1896,
  1898,
  1916,
  1918,
  1920,
  1922,
  484,
  485,
  486,
  487,
  488,
  489,
  490,
  491,
  492,
  493,
  494,
  495,
  496,
  497,
  498,
  499,
  500,
  501,
  502,
  503,
  504,
  505,
  506,
  507,
  508,
  509,
  510,
  511,
  2024,
  2026,
  2028,
  2030,
  2048,
  2050,
  2052,
  2054,
  2056,
  2058,
  2060,
  2062,
  2064,
  2066,
  2068,
  2070,
  2072,
  2074,
  2076,
  2078,
  2080,
  2082,
  2084,
  2086,
  2088,
  2090,
  2092,
  2094,
  2096,
  2098,
  2100,
  2102,
  2104,
  2106,
  2108,
  2110,
  2112,
  2114,
  2116,
  2118,
  2120,
  2122,
  2124,
  2126,
  2128,
  2130,
  2132,
  2134,
  2136,
  2138,
  2140,
  2142,
  2144,
  2146,
  2148,
  2150,
  2152,
  2154,
  2156,
  2158,
  2160,
  2162,
  2164,
  2166,
  2168,
  2170,
  2172,
  2174,
  2176,
  2178,
  2180,
  2182,
  2184,
  2186,
  2188,
  2190,
  2192,
  2194,
  2196,
  2198,
  2200,
  2202,
  2204,
  2206,
  2208,
  2210,
  2212,
  2214,
  2216,
  2218,
  2220,
  2222,
  2224,
  2226,
  2228,
  2230,
  2232,
  2234,
  2236,
  2238,
  2240,
  2242,
  2244,
  2246,
  2248,
  2250,
  2252,
  2254,
  2256,
  2258,
  2260,
  2262,
  2264,
  2266,
  2268,
  2270,
  2272,
  2274,
  2276,
  2278,
  2280,
  2282,
  2284,
  2286,
  2288,
  2290,
  2292,
  2294,
  2296,
  2298,
  2300,
  2302,
  2304,
  2306,
  2308,
  2310,
  2312,
  2314,
  2316,
  2318,
  2320,
  2322,
  2324,
  2326,
  2328,
  2330,
  2332,
  2334,
  2336,
  2338,
  2340,
  2342,
  2344,
  2346,
  2348,
  2350,
  2352,
  2354,
  2356,
  2358,
  2360,
  2362,
  2364,
  2366,
  2368,
  2370,
  2372,
  2374,
  2376,
  2378,
  2380,
  2382,
  2384,
  2386,
  2388,
  2390,
  2392,
  2394,
  2396,
  2398,
  2400,
  2402,
  2404,
  2406,
  2408,
  2410,
  2412,
  2414,
  2416,
  2418,
  2420,
  2422,
  2424,
  2426,
  2428,
  2430,
  2432,
  2434,
  2436,
  2438,
  2440,
  2442,
  2444,
  2446,
  2448,
  2450,
  2452,
  2454,
  2456,
  2458,
  2460,
  2462,
  2464,
  2466,
  2468,
  2470,
  2472,
  2474,
  2476,
  2478,
  2480,
  2482,
  2484,
  2486,
  2488,
  2490,
  2492,
  2494,
  2496,
  2498,
  2500,
  2502,
  2504,
  2506,
  2508,
  2510,
  2512,
  2514,
  2516,
  2518,
  2520,
  2522,
  2524,
  2526,
  2528,
  2530,
  2532,
  2534,
  2536,
  2538,
  2540,
  2542,
  2544,
  2546,
  2548,
  2550,
  2552,
  2554,
  2556,
  2558,
  2560,
  2562,
  2564,
  2566,
  2568,
  2570,
  2572,
  2574,
  2576,
  2578,
  2580,
  2582,
  2584,
  2586,
  2588,
  2590,
  2592,
  2594,
  2596,
  2598,
  2600,
  2602,
  2604,
  2606,
  2608,
  2610,
  2612,
  2614,
  2616,
  2618,
  2620,
  2622,
  2624,
  2626,
  2628,
  2630,
  2632,
  2634,
  2636,
  2638,
  2640,
  2642,
  2644,
  2646,
  2648,
  2650,
  2652,
  2654,
  2656,
  2658,
  2660,
  2662,
  2664,
  2666,
  2668,
  2670,
  2672,
  2674,
  2676,
  2678,
  2680,
  2682,
  2684,
  2686,
  2688,
  2690,
  2692,
  2694,
  2696,
  2698,
  2700,
  2702,
  2704,
  2706,
  2708,
  2710,
  2712,
  2714,
  2716,
  2718,
  2720,
  2722,
  2724,
  2726,
  2728,
  2730,
  2732,
  2734,
  2736,
  2738,
  2740,
  2742,
  2744,
  2746,
  2748,
  2750,
  2752,
  2754,
  2756,
  2758,
  2760,
  2762,
  2764,
  2766,
  2768,
  2770,
  2772,
  2774,
  2776,
  2778,
  2780,
  2782,
  2784,
  2786,
  2788,
  2790,
  2792,
  2794,
  2796,
  2798,
  2800,
  2802,
  2804,
  2806,
  2808,
  2810,
  2812,
  2814,
  2816,
  2818,
  2820,
  2822,
  2824,
  2826,
  2828,
  2830,
  2832,
  2834,
  2836,
  2838,
  2840,
  2842,
  2844,
  2846,
  2848,
  2850,
  2852,
  2854,
  2856,
  2858,
  2860,
  2862,
  2864,
  2866,
  2868,
  2870,
  2872,
  2874,
  2876,
  2878,
  2880,
  2882,
  2884,
  2886,
  2888,
  2890,
  2892,
  2894,
  2896,
  2898,
  2900,
  2902,
  2904,
  2906,
  2908,
  2910,
  2912,
  2914,
  2916,
  2918,
  2920,
  2922,
  2924,
  2926,
  2928,
  2930,
  2932,
  2934,
  2936,
  2938,
  2940,
  2942,
  2944,
  2946,
  2948,
  2950,
  2952,
  2954,
  2956,
  2958,
  2960,
  2962,
  2964,
  2966,
  2968,
  2970,
  2972,
  2974,
  2976,
  2978,
  2980,
  2982,
  2984,
  2986,
  2988,
  2990,
  2992,
  2994,
  2996,
  2998,
  3000,
  3002,
  3004,
  3006,
  3008,
  3010,
  3012,
  3014,
  3016,
  3018,
  3020,
  3022,
  3024,
  3026,
  3028,
  3030,
  3032,
  3034,
  3036,
  3038,
  3040,
  3042,
  3044,
  3046,
  3048,
  3050,
  3052,
  3054,
  3056,
  3058,
  3060,
  3062,
  3064,
  3066,
  3068,
  3070,
  3072,
  3074,
  3076,
  3078,
  3080,
  3082,
  3084,
  3086,
  3088,
  3090,
  3092,
  3094,
  3096,
  3098,
  3100,
  3102,
  3104,
  3106,
  3108,
  3110,
  3112,
  3114,
  3116,
  3118,
  3120,
  3122,
  3124,
  3126,
  3128,
  3130,
  3132,
  3134,
  3136,
  3138,
  3140,
  3142,
  3144,
  3146,
  3148,
  3150,
  3152,
  3154,
  3156,
  3158,
  3160,
  3162,
  3164,
  3166,
  3168,
  3170,
  3172,
  3174,
  3176,
  3178,
  3180,
  3182,
  3184,
  3186,
  3188,
  3190,
  3192,
  3194,
  3196,
  3198,
  3200,
  3202,
  3204,
  3206,
  3208,
  3210,
  3212,
  3214,
  3216,
  3218,
  3220,
  3222,
  3224,
  3226,
  3228,
  3230,
  3232,
  3234,
  3236,
  3238,
  3240,
  3242,
  3244,
  3246,
  3248,
  3250,
  3252,
  3254,
  3256,
  3258,
  3260,
  3262,
  3264,
  3266,
  3268,
  3270,
  3272,
  3274,
  3276,
  3278,
  3280,
  3282,
  3284,
  3286,
  3288,
  3290,
  3292,
  3294,
  3296,
  3298,
  3300,
  3302,
  3304,
  3306,
  3308,
  3310,
  3312,
  3314,
  3316,
  3318,
  3320,
  3322,
  3324,
  3326,
  3328,
  3330,
  3332,
  3334,
  3336,
  3338,
  3340,
  3342,
  3344,
  3346,
  3348,
  3350,
  3352,
  3354,
  3356,
  3358,
  3360,
  3362,
  3364,
  3366,
  3368,
  3370,
  3372,
  3374,
  3376,
  3378,
  3380,
  3382,
  3384,
  3386,
  3388,
  3390,
  3392,
  3394,
  3396,
  3398,
  3400,
  3402,
  3404,
  3406,
  3408,
  3410,
  3412,
  3414,
  3416,
  3418,
  3420,
  3422,
  3424,
  3426,
  3428,
  3430,
  3432,
  3434,
  3436,
  3438,
  3440,
  3442,
  3444,
  3446,
  3448,
  3450,
  3452,
  3454,
  3456,
  3458,
  3460,
  3462,
  3464,
  3466,
  3468,
  3470,
  3472,
  3474,
  3476,
  3478,
  3480,
  3482,
  3484,
  3486,
  3488,
  3490,
  3492,
  3494,
  3496,
  3498,
  3500,
  3502,
  3504,
  3506,
  3508,
  3510,
  3512,
  3514,
  3516,
  3518,
  3520,
  3522,
  3524,
  3526,
  3528,
  3530,
  3532,
  3534,
  3536,
  3538,
  3540,
  3542,
  3544,
  3546,
  3548,
  3550,
  3552,
  3554,
  3556,
  3558,
  3560,
  3562,
  3564,
  3566,
  3568,
  3570,
  3572,
  3574,
  3576,
  3578,
  3580,
  3582,
  3584,
  3586,
  3588,
  3590,
  3592,
  3594,
  3596,
  3598,
  3600,
  3602,
  3604,
  3606,
  3608,
  3610,
  3612,
  3614,
  3616,
  3618,
  3620,
  3622,
  3624,
  3626,
  3628,
  3630,
  3632,
  3634,
  3636,
  3638,
  3640,
  3642,
  3644,
  3646,
  3648,
  3650,
  3652,
  3654,
  3656,
  3658,
  3660,
  3662,
  3664,
  3666,
  3668,
  3670,
  3672,
  3674,
  3676,
  3678,
  3680,
  3682,
  3684,
  3686,
  3688,
  3690,
  3692,
  3694,
  3696,
  3698,
  3700,
  3702,
  3704,
  3706,
  3708,
  3710,
  3712,
  3714,
  3716,
  3718,
  3720,
  3722,
  3724,
  3726,
  3728,
  3730,
  3732,
  3734,
  3736,
  3738,
  3740,
  3742,
  3744,
  3746,
  3748,
  3750,
  3752,
  3754,
  3756,
  3758,
  3760,
  3762,
  3764,
  3766,
  3768,
  3770,
  3772,
  3774,
  3776,
  3778,
  3780,
  3782,
  3784,
  3786,
  3788,
  3790,
  3792,
  3794,
  3796,
  3798,
  3800,
  3802,
  3804,
  3806,
  3808,
  3810,
  3812,
  3814,
  3816,
  3818,
  3820,
  3822,
  3824,
  3826,
  3828,
  3830,
  3832,
  3834,
  3836,
  3838,
  3840,
  3842,
  3844,
  3846,
  3848,
  3850,
  3852,
  3854,
  3856,
  3858,
  3860,
  3862,
  3864,
  3866,
  3868,
  3870,
  3872,
  3874,
  3876,
  3878,
  3880,
  3882,
  3884,
  3886,
  3888,
  3890,
  3892,
  3894,
  3896,
  3898,
  3900,
  3902,
  3904,
  3906,
  3908,
  3910,
  3912,
  3914,
  3916,
  3918,
  3920,
  3922,
  3924,
  3926,
  3928,
  3930,
  3932,
  3934,
  3936,
  3938,
  3940,
  3942,
  3944,
  3946,
  3948,
  3950,
  3952,
  3954,
  3968,
  3969,
  3970,
  3971,
  3972,
  3973,
  3974,
  3975,
  3976,
  3977,
  3978,
  3979,
  3980,
  3981,
  3982,
  3983,
  3984,
  3985,
  3986,
  3987,
  3988,
  3989,
  3990,
  3991,
  3992,
  3993,
  3994,
  3995,
  3996,
  3997,
  4096,
  4098,
  4100,
  4102,
  4104,
  4106,
  4108,
  4110,
  4112,
  4114,
  4116,
  4118,
  4120,
  4122,
  4124,
  4126,
  4128,
  4130,
  4132,
  4134,
  4136,
  4138,
  4140,
  4142,
  4144,
  4146,
  4148,
  4150,
  4152,
  4154,
  4156,
  4158,
  4160,
  4162,
  4164,
  4166,
  4168,
  4170,
  4172,
  4174,
  4176,
  4178,
  4180,
  4182,
  4184,
  4186,
  4188,
  4190,
  4192,
  4194,
  4196,
  4198,
  4208,
  4210,
  4212,
  4214,
  4216,
  4218,
  4220,
  4222,
  4224,
  4272,
  4274,
  4276,
  4278,
  4280,
  4282,
  4284,
  4286,
  4288,
  4290,
  4292,
  4294,
  4296,
  4298,
  4300,
  4302,
  4304,
  4306,
  4308,
  4310,
  4312,
  4314,
  4316,
  4318,
  4320,
  4322,
  4324,
  4326,
  4328,
  4330,
  4332,
  4334,
  4336,
  4338,
  4340,
  4342,
  4344,
  4346,
  4348,
  4350,
  4352,
  4354,
  4356,
  4358,
  4360,
  4362,
  4364,
  4366,
  4368,
  4370,
  4372,
  4374,
  4376,
  4378,
  4380,
  4382,
  4384,
  4386,
  4388,
  4390,
  4392,
  4394,
  4396,
  4398,
  4400,
  4402,
  4404,
  4406,
  4408,
  4410,
  4412,
  4414,
  4416,
  4418,
  4420,
  4422,
  4424,
  4426,
  4428,
  4430,
  4432,
  4434,
  4436,
  4438,
  8224,
  4450,
  4452,
  4454,
  4456,
  4458,
  4460,
  4462,
  4464,
  4466,
  4468,
  4470,
  4472,
  4474,
  4476,
  4478,
  4480,
  4482,
  4484,
  4486,
  4488,
  4490,
  4492,
  4494,
  4496,
  4498,
  4500,
  4502,
  4504,
  4506,
  4508,
  4510,
  4512,
  4514,
  4516,
  4518,
  4520,
  4522,
  4524,
  4526,
  4528,
  4530,
  4532,
  4534,
  4536,
  4538,
  4540,
  4542,
  4544,
  4546,
  4548,
  4550,
  4552,
  4554,
  4556,
  4558,
  4560,
  4562,
  4564,
  4566,
  4568,
  4570,
  4572,
  4574,
  4576,
  4578,
  4580,
  4582,
  4584,
  4586,
  4588,
  4590,
  4592,
  4594,
  4596,
  4598,
  4600,
  4602,
  4604,
  4606,
  4608,
  4610,
  4612,
  4614,
  4616,
  4618,
  4620,
  4622,
  4624,
  4626,
  4628,
  4630,
  4632,
  4634,
  4636,
  4638,
  4640,
  4642,
  4644,
  4646,
  4648,
  4650,
  4652,
  4654,
  4656,
  4658,
  4660,
  4662,
  4736,
  4738,
  4740,
  4742,
  4744,
  4746,
  4748,
  4750,
  4752,
  4754,
  4756,
  4758,
  4760,
  4762,
  4764,
  4766,
  4768,
  4770,
  4772,
  4774,
  4776,
  4778,
  4780,
  4782,
  4784,
  4786,
  4788,
  4790,
  4792,
  4794,
  4796,
  4798,
  4800,
  4802,
  4804,
  4806,
  4808,
  4810,
  4812,
  4814,
  4816,
  4818,
  4820,
  4822,
  4824,
  4826,
  4828,
  4830,
  4832,
  4834,
  4836,
  4838,
  4840,
  4842,
  4844,
  4846,
  4848,
  4850,
  4852,
  4854,
  4856,
  4858,
  4860,
  4862,
  4864,
  4866,
  4868,
  4870,
  4872,
  4874,
  4876,
  4878,
  4880,
  4882,
  4884,
  4886,
  4888,
  4890,
  4892,
  4894,
  4896,
  4898,
  4900,
  4902,
  4904,
  4906,
  4908,
  4910,
  4912,
  4914,
  4916,
  4918,
  4920,
  4922,
  4924,
  4926,
  4928,
  4930,
  4932,
  4934,
  4936,
  4938,
  4940,
  4942,
  4944,
  4946,
  4948,
  4950,
  4952,
  4954,
  4956,
  4958,
  4960,
  4962,
  4964,
  4966,
  4968,
  4970,
  4972,
  4974,
  4976,
  4978,
  4980,
  4982,
  4984,
  4986,
  4988,
  4990,
  4992,
  4994,
  4996,
  4998,
  5000,
  5002,
  5004,
  5006,
  5008,
  5010,
  5012,
  5014,
  5016,
  5018,
  5020,
  5022,
  5024,
  5026,
  5028,
  5030,
  5032,
  5034,
  5036,
  5038,
  5040,
  5042,
  5044,
  5046,
  5048,
  5050,
  5052,
  5054,
  5056,
  5058,
  5060,
  5062,
  5064,
  5066,
  5068,
  5070,
  5072,
  5074,
  5076,
  5078,
  5080,
  5082,
  5084,
  5086,
  5088,
  5090,
  5092,
  5094,
  5096,
  5098,
  5100,
  5102,
  5104,
  5106,
  5108,
  5110,
  5112,
  5114,
  5116,
  5118,
  5120,
  5122,
  5124,
  5126,
  5128,
  5130,
  5132,
  5134,
  5136,
  5138,
  5140,
  5142,
  5144,
  5146,
  5148,
  5150,
  5152,
  5154,
  5156,
  5158,
  5160,
  5162,
  5164,
  5166,
  5168,
  5170,
  5172,
  5174,
  5176,
  5178,
  5180,
  5182,
  5184,
  5186,
  5188,
  5190,
  5192,
  5194,
  5196,
  5198,
  5200,
  5202,
  5204,
  5206,
  5208,
  5210,
  5212,
  5214,
  5216,
  5218,
  5220,
  5222,
  5224,
  5226,
  5228,
  5230,
  5232,
  5234,
  5236,
  5238,
  5240,
  5242,
  5244,
  5246,
  5248,
  5250,
  5252,
  5254,
  5256,
  5258,
  5260,
  5262,
  5264,
  5266,
  5268,
  5270,
  5272,
  5274,
  5276,
  5278,
  5280,
  5282,
  5284,
  5286,
  5288,
  5290,
  5292,
  5294,
  5296,
  5298,
  5300,
  5302,
  5304,
  5306,
  5308,
  5310,
  5312,
  5314,
  5316,
  5318,
  5320,
  5322,
  5324,
  5326,
  5328,
  5330,
  5332,
  5334,
  5336,
  5338,
  5340,
  5342,
  5344,
  5346,
  5348,
  5350,
  5352,
  5354,
  5356,
  5358,
  5360,
  5362,
  5364,
  5366,
  5368,
  5370,
  5372,
  5374,
  5376,
  5378,
  5380,
  5382,
  5384,
  5386,
  5388,
  5390,
  5392,
  5394,
  5396,
  5398,
  5400,
  5402,
  5404,
  5406,
  5408,
  5410,
  5412,
  5414,
  5416,
  5418,
  5420,
  5422,
  5424,
  5426,
  5428,
  5430,
  5432,
  5434,
  5436,
  5438,
  5440,
  5442,
  5444,
  5446,
  5448,
  5450,
  5452,
  5454,
  5456,
  5458,
  5460,
  5462,
  5464,
  5466,
  5468,
  5470,
  5472,
  5474,
  5476,
  5478,
  5480,
  5482,
  5484,
  5486,
  5488,
  5490,
  5492,
  5494,
  5496,
  5498,
  5500,
  5502,
  5504,
  5506,
  5508,
  5510,
  5512,
  5514,
  5516,
  5518,
  5520,
  5522,
  5524,
  5526,
  5528,
  5530,
  5532,
  5534,
  5536,
  5538,
  5540,
  5542,
  5544,
  5546,
  5548,
  5550,
  5552,
  5554,
  5556,
  5558,
  5560,
  5562,
  5564,
  5566,
  5568,
  5570,
  5572,
  5574,
  5576,
  5578,
  5580,
  5582,
  5584,
  5586,
  5588,
  5590,
  5592,
  5594,
  5596,
  5598,
  5600,
  5602,
  5604,
  5606,
  5608,
  5610,
  5612,
  5614,
  5616,
  5618,
  5620,
  5622,
  5624,
  5626,
  5628,
  7472,
  7474,
  7476,
  7478,
  7480,
  7482,
  7484,
  7486,
  7488,
  7490,
  3998,
  0
}; // weak
__int16 word_41F700[784] =
{
  8503,
  9249,
  9250,
  9251,
  9252,
  9253,
  9254,
  9255,
  9256,
  9257,
  9258,
  9259,
  9260,
  9261,
  9262,
  9263,
  9264,
  9265,
  9266,
  9267,
  9268,
  9269,
  9270,
  9271,
  9272,
  9273,
  9274,
  9275,
  9276,
  9277,
  9278,
  9279,
  9280,
  9281,
  9282,
  9283,
  9284,
  9285,
  9286,
  9287,
  9288,
  9289,
  9290,
  9291,
  9292,
  9293,
  9294,
  9295,
  9296,
  9297,
  9298,
  9299,
  9300,
  9301,
  9302,
  9303,
  9304,
  9305,
  9306,
  9307,
  9308,
  9309,
  9310,
  9311,
  9312,
  9313,
  9314,
  9315,
  9316,
  9317,
  9318,
  9319,
  9320,
  9321,
  9322,
  9323,
  9324,
  9325,
  9326,
  9327,
  9330,
  9331,
  9793,
  9794,
  12334,
  12341,
  12343,
  12354,
  12357,
  12362,
  12364,
  12367,
  12373,
  12379,
  12380,
  12387,
  12392,
  12396,
  12405,
  12410,
  12578,
  12579,
  12582,
  12607,
  12614,
  12628,
  12635,
  12639,
  12648,
  12655,
  12659,
  12666,
  12667,
  12668,
  12669,
  12670,
  12833,
  12835,
  12843,
  12847,
  12848,
  12857,
  12860,
  12861,
  12862,
  12863,
  12865,
  12867,
  12868,
  12872,
  12874,
  12876,
  12884,
  12885,
  12889,
  12893,
  12897,
  12904,
  12913,
  12914,
  12915,
  12926,
  13091,
  13094,
  13096,
  13099,
  13100,
  13104,
  13109,
  13114,
  13126,
  13128,
  13130,
  13131,
  13134,
  13137,
  13140,
  13142,
  13144,
  13147,
  13149,
  13156,
  13160,
  13356,
  13360,
  13369,
  13377,
  13382,
  13385,
  13386,
  13393,
  13395,
  13398,
  13400,
  13405,
  13406,
  13418,
  13423,
  13424,
  13425,
  13427,
  13428,
  13435,
  13436,
  13601,
  13602,
  13604,
  13612,
  13613,
  13615,
  13616,
  13627,
  13631,
  13633,
  13649,
  13650,
  13653,
  13657,
  13662,
  13665,
  13669,
  13670,
  13673,
  13675,
  13676,
  13678,
  13686,
  13687,
  13857,
  13862,
  13869,
  13871,
  13877,
  13896,
  13898,
  13905,
  13906,
  13912,
  13914,
  13921,
  13922,
  13928,
  13931,
  13934,
  13937,
  13941,
  13942,
  13945,
  14113,
  14123,
  14130,
  14136,
  14137,
  14143,
  14145,
  14146,
  14159,
  14160,
  14161,
  14167,
  14170,
  14181,
  14183,
  14184,
  14186,
  14187,
  14191,
  14369,
  14370,
  14374,
  14378,
  14379,
  14387,
  14389,
  14390,
  14393,
  14394,
  14395,
  14397,
  14400,
  14402,
  14404,
  14406,
  14407,
  14410,
  14412,
  14431,
  14437,
  14438,
  14444,
  14445,
  14446,
  14450,
  14458,
  14460,
  14461,
  14462,
  14630,
  14633,
  14634,
  14637,
  14643,
  14645,
  14649,
  14651,
  14653,
  14658,
  14661,
  14675,
  14676,
  14685,
  14687,
  14688,
  14690,
  14694,
  14695,
  14703,
  14704,
  14709,
  14718,
  14892,
  14894,
  14904,
  14905,
  14911,
  14914,
  14918,
  14919,
  14926,
  14929,
  14937,
  14943,
  14944,
  14946,
  14958,
  14959,
  14966,
  15144,
  15154,
  15155,
  15158,
  15162,
  15163,
  15172,
  15173,
  15176,
  15181,
  15183,
  15185,
  15186,
  15191,
  15192,
  15199,
  15205,
  15207,
  15209,
  15211,
  15214,
  15217,
  15221,
  15222,
  15223,
  15229,
  15230,
  15393,
  15395,
  15400,
  15402,
  15403,
  15408,
  15412,
  15418,
  15420,
  15425,
  15426,
  15436,
  15437,
  15440,
  15444,
  15446,
  15450,
  15457,
  15461,
  15463,
  15464,
  15465,
  15466,
  15468,
  15471,
  15477,
  15479,
  15481,
  15485,
  15486,
  15652,
  15658,
  15672,
  15677,
  15678,
  15684,
  15685,
  15696,
  15697,
  15698,
  15712,
  15715,
  15719,
  15720,
  15721,
  15722,
  15729,
  15733,
  15736,
  15740,
  15905,
  15910,
  15918,
  15919,
  15920,
  15930,
  15939,
  15940,
  15944,
  15946,
  15950,
  15951,
  15962,
  15964,
  15965,
  15973,
  15978,
  15980,
  15983,
  15986,
  15989,
  15998,
  16162,
  16167,
  16168,
  16169,
  16173,
  16174,
  16175,
  16180,
  16182,
  16183,
  16187,
  16188,
  16191,
  16199,
  16200,
  16202,
  16205,
  16207,
  16222,
  16226,
  16228,
  16229,
  16237,
  16244,
  16248,
  16419,
  16425,
  16429,
  16430,
  16432,
  16437,
  16440,
  16442,
  16445,
  16452,
  16458,
  16464,
  16465,
  16467,
  16470,
  16474,
  16476,
  16478,
  16479,
  16481,
  16482,
  16484,
  16488,
  16489,
  16492,
  16501,
  16507,
  16510,
  16682,
  16688,
  16691,
  16692,
  16710,
  16711,
  16719,
  16720,
  16731,
  16732,
  16734,
  16736,
  16737,
  16746,
  16749,
  16757,
  16758,
  16759,
  16765,
  16934,
  16935,
  16936,
  16940,
  16941,
  16942,
  16944,
  16947,
  16952,
  16955,
  16958,
  16959,
  16960,
  16967,
  16974,
  16976,
  16980,
  16982,
  16984,
  16992,
  16997,
  16998,
  16999,
  17000,
  17002,
  17006,
  17010,
  17187,
  17195,
  17201,
  17205,
  17210,
  17211,
  17212,
  17223,
  17226,
  17229,
  17230,
  17231,
  17238,
  17239,
  17241,
  17253,
  17254,
  17260,
  17261,
  17266,
  17274,
  17445,
  17447,
  17460,
  17462,
  17465,
  17466,
  17467,
  17470,
  17481,
  17484,
  17507,
  17508,
  17514,
  17516,
  17528,
  17529,
  17531,
  17706,
  17708,
  17716,
  17722,
  17726,
  17728,
  17729,
  17733,
  17744,
  17747,
  17753,
  17770,
  17782,
  17785,
  17960,
  17964,
  17968,
  17969,
  17971,
  17979,
  17984,
  17987,
  17992,
  17993,
  17996,
  17997,
  18015,
  18018,
  18041,
  18044,
  18046,
  18212,
  18215,
  18222,
  18223,
  18235,
  18236,
  18237,
  18251,
  18255,
  18259,
  18260,
  18261,
  18264,
  18267,
  18268,
  18290,
  18294,
  18466,
  18479,
  18484,
  18492,
  18493,
  18494,
  18495,
  18498,
  18500,
  18502,
  18508,
  18511,
  18518,
  18534,
  18537,
  18543,
  18547,
  18551,
  18553,
  18558,
  18732,
  18740,
  18744,
  18749,
  18753,
  18755,
  18762,
  18772,
  18773,
  18779,
  18785,
  18793,
  18804,
  18810,
  18811,
  18812,
  18813,
  18979,
  18986,
  18988,
  18996,
  19000,
  19001,
  19003,
  19007,
  19010,
  19012,
  19015,
  19020,
  19025,
  19026,
  19028,
  19029,
  19030,
  19033,
  19035,
  19037,
  19042,
  19044,
  19055,
  19057,
  19059,
  19068,
  19069,
  19233,
  19258,
  19264,
  19292,
  19296,
  19303,
  19304,
  19318,
  19324,
  19492,
  19497,
  19509,
  19518,
  19519,
  19520,
  19527,
  19532,
  19543,
  19546,
  19548,
  19553,
  19556,
  19559,
  19571,
  19573,
  19581,
  19757,
  19763,
  19773,
  19774,
  19775,
  19782,
  19785,
  19789,
  19791,
  19793,
  19799,
  19806,
  19821,
  19822,
  19824,
  19831,
  19832,
  19837,
  20002,
  20005,
  20008,
  20009,
  20012,
  20027,
  20030,
  20033,
  20041,
  20044,
  20046,
  20047,
  20048,
  20056,
  20064,
  20065,
  20067,
  20068,
  20073,
  20083,
  20084,
  20093,
  20258,
  20265,
  20287,
  20288,
  20290,
  20291,
  20292,
  20296,
  12096,
  12097,
  12098,
  12099,
  12100,
  12101,
  12102,
  12103,
  12104,
  12105,
  12106,
  12107,
  12108,
  12112,
  12113,
  12114,
  12115,
  12128,
  12129,
  12130,
  12131,
  12132,
  12133,
  12134,
  12135,
  12136,
  12137,
  12138,
  12139,
  12140,
  12141,
  12142,
  12143,
  12144,
  12145,
  12146,
  12147,
  12148,
  12149,
  12150,
  12151,
  12152,
  12153,
  12154,
  12155
}; // weak
__int16 word_41FD20[784] =
{
  1904,
  512,
  514,
  516,
  518,
  520,
  522,
  524,
  526,
  528,
  530,
  532,
  534,
  536,
  538,
  540,
  542,
  544,
  546,
  548,
  550,
  552,
  554,
  556,
  558,
  560,
  562,
  564,
  566,
  568,
  570,
  572,
  574,
  576,
  578,
  580,
  582,
  584,
  586,
  588,
  590,
  592,
  594,
  596,
  598,
  600,
  602,
  604,
  606,
  608,
  610,
  612,
  614,
  616,
  618,
  620,
  622,
  624,
  626,
  628,
  630,
  632,
  634,
  636,
  638,
  640,
  642,
  644,
  646,
  648,
  650,
  652,
  654,
  656,
  658,
  660,
  662,
  664,
  666,
  668,
  674,
  676,
  1928,
  1930,
  1126,
  1128,
  1130,
  1926,
  1282,
  1284,
  774,
  1090,
  1286,
  1288,
  822,
  1410,
  802,
  900,
  1412,
  814,
  1132,
  1134,
  1136,
  846,
  1290,
  1292,
  1294,
  786,
  1414,
  1978,
  1416,
  1688,
  1418,
  1420,
  1422,
  1424,
  1138,
  1140,
  1142,
  1144,
  1146,
  1980,
  1050,
  1148,
  928,
  1150,
  1296,
  714,
  1298,
  1906,
  1300,
  1302,
  1036,
  1304,
  850,
  1306,
  982,
  980,
  1426,
  1428,
  768,
  1430,
  818,
  1984,
  1152,
  758,
  1154,
  696,
  1156,
  1158,
  1308,
  1310,
  1064,
  1312,
  2006,
  886,
  1854,
  1114,
  1314,
  1976,
  1316,
  1432,
  1434,
  1160,
  950,
  1162,
  1318,
  1988,
  1910,
  1320,
  1322,
  1924,
  838,
  1324,
  1956,
  1326,
  1436,
  964,
  1438,
  1440,
  1442,
  1444,
  1446,
  1120,
  816,
  1028,
  1164,
  864,
  884,
  1166,
  1168,
  1170,
  1172,
  1954,
  1328,
  1330,
  1048,
  1332,
  1334,
  1460,
  1462,
  1464,
  1466,
  1982,
  1458,
  940,
  1866,
  1104,
  1174,
  1176,
  1178,
  1180,
  1182,
  1336,
  1338,
  1340,
  1080,
  1024,
  1342,
  1448,
  912,
  1450,
  1452,
  1454,
  732,
  1052,
  1456,
  868,
  1184,
  1186,
  1074,
  1188,
  1190,
  1192,
  688,
  698,
  1016,
  1124,
  1344,
  1346,
  1348,
  1034,
  1468,
  778,
  684,
  1470,
  1116,
  1194,
  1196,
  1198,
  1200,
  1202,
  1204,
  1206,
  966,
  1208,
  1210,
  832,
  790,
  1350,
  1352,
  1032,
  1008,
  1960,
  1994,
  954,
  1354,
  952,
  1944,
  1474,
  1476,
  1992,
  1478,
  1872,
  1480,
  1472,
  748,
  1212,
  716,
  1214,
  894,
  1934,
  1216,
  1218,
  1220,
  1222,
  888,
  918,
  730,
  934,
  914,
  1356,
  1482,
  944,
  736,
  910,
  1484,
  1486,
  1488,
  742,
  1224,
  1986,
  1226,
  1228,
  1568,
  996,
  972,
  706,
  1358,
  1360,
  1362,
  792,
  672,
  1490,
  810,
  720,
  1492,
  1230,
  1232,
  942,
  1234,
  1236,
  1238,
  820,
  738,
  854,
  1054,
  760,
  1364,
  1066,
  1366,
  794,
  1078,
  1494,
  1864,
  2000,
  962,
  1496,
  1498,
  1004,
  1500,
  1504,
  1502,
  784,
  826,
  1240,
  1000,
  1242,
  844,
  1244,
  766,
  1246,
  1782,
  690,
  852,
  1368,
  1370,
  1372,
  1374,
  1376,
  1378,
  1506,
  1508,
  764,
  870,
  1948,
  812,
  1102,
  678,
  1510,
  858,
  1998,
  1512,
  1068,
  1248,
  880,
  988,
  1250,
  1252,
  1380,
  1382,
  1384,
  1388,
  1386,
  946,
  1514,
  1516,
  974,
  1118,
  1518,
  1030,
  956,
  1520,
  866,
  1254,
  1256,
  708,
  1258,
  1260,
  1262,
  938,
  1390,
  1392,
  1394,
  1996,
  1396,
  1398,
  1968,
  1400,
  740,
  1522,
  1524,
  1526,
  1122,
  1084,
  1528,
  1264,
  1266,
  1056,
  1268,
  1270,
  1272,
  1274,
  1070,
  1276,
  862,
  1278,
  762,
  1280,
  804,
  1402,
  1404,
  1406,
  890,
  1408,
  1860,
  1010,
  1530,
  1532,
  772,
  1534,
  692,
  1536,
  2014,
  686,
  1538,
  724,
  2016,
  1870,
  1540,
  1632,
  1634,
  1636,
  1638,
  2018,
  1640,
  718,
  1642,
  1644,
  896,
  1754,
  1756,
  1758,
  920,
  1760,
  1762,
  1764,
  1766,
  782,
  1018,
  1542,
  1546,
  1544,
  1646,
  670,
  1648,
  1650,
  930,
  1652,
  936,
  808,
  828,
  994,
  1768,
  1908,
  1770,
  754,
  1112,
  1098,
  1548,
  1552,
  1868,
  1946,
  750,
  1550,
  1110,
  1558,
  1942,
  1554,
  1556,
  1654,
  1656,
  1658,
  992,
  1660,
  1662,
  1664,
  1772,
  1060,
  1774,
  712,
  1776,
  1778,
  1780,
  958,
  1020,
  1560,
  872,
  1562,
  908,
  1564,
  702,
  806,
  1666,
  798,
  1668,
  1670,
  776,
  1672,
  1674,
  1784,
  728,
  1786,
  1096,
  1788,
  1790,
  1936,
  1566,
  1570,
  916,
  700,
  1572,
  1970,
  780,
  1676,
  1678,
  1792,
  1076,
  898,
  1046,
  1932,
  1990,
  1794,
  1966,
  1972,
  1574,
  1576,
  770,
  744,
  1680,
  830,
  968,
  726,
  752,
  834,
  1964,
  1914,
  1044,
  1578,
  824,
  1580,
  1582,
  1584,
  1682,
  1100,
  878,
  1684,
  1686,
  1690,
  1692,
  710,
  1796,
  1798,
  836,
  1938,
  2008,
  1586,
  1588,
  1590,
  1952,
  876,
  1940,
  1012,
  2012,
  1694,
  1696,
  1698,
  1700,
  1092,
  1800,
  1802,
  1592,
  1594,
  1596,
  1598,
  2020,
  1042,
  788,
  2022,
  1900,
  1958,
  1950,
  1088,
  734,
  1804,
  1806,
  1808,
  1810,
  948,
  1082,
  1812,
  1600,
  1602,
  998,
  904,
  978,
  842,
  1702,
  1704,
  922,
  1706,
  1814,
  848,
  906,
  1816,
  932,
  1026,
  892,
  1604,
  1606,
  840,
  1912,
  1608,
  1610,
  1612,
  1058,
  1708,
  1022,
  1710,
  1712,
  1006,
  1714,
  986,
  1062,
  1716,
  1718,
  1720,
  1722,
  1818,
  874,
  722,
  1820,
  2010,
  1840,
  746,
  694,
  1614,
  682,
  1072,
  924,
  1842,
  1962,
  1616,
  1830,
  990,
  1618,
  960,
  1002,
  860,
  1724,
  1726,
  704,
  926,
  1728,
  1730,
  1856,
  1824,
  1822,
  1844,
  1834,
  1848,
  1620,
  1038,
  1902,
  1622,
  1624,
  984,
  1734,
  1736,
  1738,
  856,
  1740,
  1742,
  1826,
  2004,
  1838,
  902,
  1832,
  976,
  1626,
  1106,
  1094,
  1628,
  1630,
  882,
  1040,
  2002,
  1744,
  756,
  800,
  1014,
  1862,
  1746,
  680,
  796,
  1852,
  1858,
  1836,
  1828,
  1850,
  1846,
  1108,
  1086,
  970,
  1974,
  1748,
  1750,
  1732,
  1752,
  1874,
  1876,
  1878,
  1880,
  1882,
  1884,
  1886,
  1888,
  1890,
  1892,
  1894,
  1896,
  1898,
  1916,
  1918,
  1920,
  1922,
  484,
  485,
  486,
  487,
  488,
  489,
  490,
  491,
  492,
  493,
  494,
  495,
  496,
  497,
  498,
  499,
  500,
  501,
  502,
  503,
  504,
  505,
  506,
  507,
  508,
  509,
  510,
  511
}; // weak
char Source[2] = "#"; // idb
char aErrorDoc[] = "error.doc"; // idb
char Mode[] = "r"; // idb
char aErrorDocFileNo[] = " << ERROR.DOC file nothing !! >>\n"; // idb
char aRb[] = "rb"; // idb
char VarName[] = "MEOR"; // idb
char aYes[] = "YES"; // idb
char aYes_0[] = "yes"; // idb
char aW[] = "w"; // idb
char aWb[] = "wb"; // idb
char aProgramO[] = "\n---------- program O"; // idb
char aProgram[] = "\n---------- program :"; // idb
char asc_4203E8[] = " "; // idb
char asc_4203EC[] = "-"; // idb
char asc_4203F0[] = "\n\n"; // idb
char aGLinePLine[] = "    G-Line  P-Line\n"; // idb
char asc_420418[] = "-"; // idb
char asc_42041C[] = "^\n"; // idb
char asc_420434[] = "\n"; // idb
char asc_420438[] = "-"; // idb
char asc_42043C[] = "\n\n"; // idb
char asc_420440[] = "                    "; // idb
char aErrors[] = " errors, "; // idb
char aBlocks[] = " blocks, "; // idb
char aTotalLines[] = " total lines\n\n"; // idb
char aProgramSize[] = "                  program size = "; // idb
char aBytes[] = " bytes\n\n"; // idb
char aCanTMakeCrossR[82] = "---------- Can't make Cross Reference !!!--------------------------------------\n\n"; // weak
char asc_420574[2] = "\n"; // weak
char aCrossReference[71] = "---------- Cross Reference -------------------------------------------"; // weak
char asc_4205C0[3] = "\n\n"; // weak
char asc_4205D4[] = "\n"; // idb
char asc_4205D8[] = "           : "; // idb
char asc_4205E8[] = "\n"; // idb
char byte_4205EC = '\f'; // idb
char asc_420804[] = "\n"; // idb
char asc_420820[] = "\n"; // idb
char aV010[6] = "V01.0"; // weak
char Str2[] = "-NR"; // idb
char aL1[] = "-L1"; // idb
char aL2[] = "-L2"; // idb
char aL3[] = "-L3"; // idb
char aP[] = "-P"; // idb
char aNs[] = "-NS"; // idb
char off_420880[] = { '-', 'L', 'C', '\0' }; // idb
char aG_0[3] = "-G"; // idb
char aC_1[3] = "-C"; // idb
char aF0_0[4] = "-F0"; // idb
char aF15[] = "-F15"; // idb
char aFs0[] = "-FS0"; // idb
char aPr[] = "-PR"; // idb
char aNcross[] = "-NCROSS"; // idb
char off_4208AC[] = { '-', 'F', 'C', '\0' }; // idb
char a0_0[3] = "-0"; // idb
char a30_0[4] = "-30"; // idb
char SubStr[4] = "-FO"; // idb
char aFl_0[4] = "-FL"; // idb
char aFr_0[4] = "-FR"; // idb
char aFp_0[4] = "-FP"; // idb
char asc_4208C8[2] = " "; // idb
char aNr_0[] = "-NR "; // idb
char aL1_0[] = "-L1 "; // idb
char aL2_0[] = "-L2 "; // idb
char aL3_0[] = "-L3 "; // idb
char aP_0[] = "-P "; // idb
char aNs_0[] = "-NS "; // idb
char aLc[] = "-LC "; // idb
char aG[] = "-G "; // idb
char aC[] = "-C "; // idb
char aF0[] = "-F0 "; // idb
char aF15_0[] = "-F15 "; // idb
char aFs0_0[] = "-FS0 "; // idb
char aPr_0[] = "-PR "; // idb
char aNcross_0[] = "-NCROSS "; // idb
char aFc[] = "-FC "; // idb
char aFo[] = "-FO"; // idb
char aFl[] = "-FL"; // idb
char aFr[] = "-FR"; // idb
char aFp[] = "-FP"; // idb
char a0[] = "-0 "; // idb
char a30[] = "-30 "; // idb
char aPath[] = "PATH"; // idb
char aMcompiExe[] = "MCOMPI.EXE"; // idb
char asc_42096C[] = ".\\"; // idb
char aMtmp[] = "MTMP"; // idb
char asc_420978[] = "\\"; // idb
char aPp[] = "pp.$$$"; // idb
char aPp_0[] = "pp.$$$"; // idb
char aW_0[] = "w"; // idb
char aSrc[] = ".SRC"; // idb
char aR_0[] = "r"; // idb
char aTmp[] = ".TMP"; // idb
char aRe[] = ".RE$"; // idb
char aRel[] = ".REL"; // idb
char aPrg[] = ".PRG"; // idb
char aRef[] = ".ref"; // idb
char aLst[] = ".LST"; // idb
char aLnk[] = ".LNK"; // idb
char aR_1[] = "r"; // idb
char aFile[] = "FILE"; // idb
char aSrc_0[] = ".SRC"; // idb
char asc_420A4C[] = "\n"; // idb
char aR_2[] = "r"; // idb
char aR_3[] = "r"; // idb
char aW_1[] = "w"; // idb
char byte_420C78 = '\f'; // idb
char aError[] = "error"; // idb
char byte_420C84 = '\f'; // idb
__int16 word_420CA0 = 20; // weak
char byte_420CA8[64] =
{
  '€',
  '€',
  '\0',
  '€',
  '\0',
  '\0',
  '\x02',
  '€',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x01',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '\x03',
  '€',
  '€',
  '\0',
  '\x01',
  '€',
  '€',
  '€',
  '€',
  '€',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x01',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\x01',
  '\0',
  '\x01',
  '\x01',
  '\x02',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // weak
char byte_420CE8[16] =
{
  '€',
  '€',
  '€',
  '€',
  '€',
  '€',
  '€',
  '€',
  '\x03',
  '\x02',
  '\x03',
  '\x01',
  '\x03',
  '\x03',
  '\x03',
  '€'
}; // weak
char byte_420CF8[4] = { '\b', '\t', '\f', '\x0E' }; // weak
char byte_420CFC[4] = { '\n', '\v', '\r', '\x0F' }; // weak
char byte_420D00[24] =
{
  '\0',
  '\x01',
  '\x02',
  '\x03',
  '\x04',
  '\x05',
  '\x06',
  '\a',
  '\b',
  '\n',
  '\v',
  '\f',
  '\r',
  '\x0E',
  '\x0F',
  '\x10',
  '\x12',
  '\x11',
  '\x13',
  '\x14',
  '\x15',
  '\x16',
  '\0',
  '\0'
}; // weak
char byte_420D18[8] = { '\x11', '\x12', '\x13', '\x16', '\x15', '\x14', '\x10', '@' }; // weak
_UNKNOWN unk_420D20; // weak
char byte_420F48[] = { '0' }; // weak
char *off_420F90 = &off_4211C0; // idb
char asc_4210A8[18] = " \t[]()+-*/=&;%,<>#"; // idb
char asc_4210BC[4] = "%;\n"; // idb
char a00[7] = "&0'&0*"; // weak
int dword_4210C8[] = { 0 }; // weak
int dword_4210CC[61] =
{
  0,
  640102694,
  76337,
  2,
  1,
  640102950,
  141874,
  1,
  1,
  640103206,
  207411,
  0,
  0,
  640103462,
  272948,
  0,
  0,
  640103718,
  338485,
  0,
  0,
  640103974,
  404022,
  0,
  0,
  640104230,
  469559,
  0,
  0,
  640104486,
  535096,
  0,
  0,
  640104742,
  600633,
  0,
  0,
  640106790,
  666177,
  0,
  0,
  640107046,
  731714,
  0,
  0,
  640107302,
  797251,
  0,
  0,
  640107558,
  862788,
  0,
  0,
  640107814,
  928325,
  0,
  0,
  640108070,
  993862,
  0,
  0
}; // weak
char aW_3[2] = "w"; // idb
char aMeor_0[] = "MEOR"; // idb
char aYes_1[] = "YES"; // idb
char aYes_2[] = "yes"; // idb
char aW_2[] = "w"; // idb
char aR_4[] = "r"; // idb
char aMeor_1[] = "MEOR"; // idb
char aYes_3[] = "YES"; // idb
char aYes_4[] = "yes"; // idb
char aN[] = "N"; // idb
char asc_4213C8[] = ");"; // idb
char asc_4213CC[] = ");"; // idb
char aInclude[] = "$INCLUDE"; // idb
char aNolist[] = "$NOLIST"; // idb
char aList[] = "$LIST"; // idb
char aEject[] = "$EJECT"; // idb
char asc_4213F8[] = "(*"; // idb
char asc_42140C[] = " "; // idb
char asc_421410[] = "*)"; // idb
char byte_421414 = '\f'; // idb
char asc_4216BC[] = "                                   "; // idb
char asc_4216E4[] = "                     "; // idb
char asc_4218E0[] = " "; // idb
char asc_4218E4[] = "*)"; // idb
char aPath_0[] = "PATH"; // idb
char aMcsmanDll[] = "MCSMan.dll"; // idb
char asc_421910[] = ".\\"; // idb
char aMcsmanDll_0[] = "MCSMan.dll"; // idb
CHAR ProcName[] = "SetAppliType"; // idb
CHAR aReggetserialnu[] = "RegGetSerialNumber"; // idb
CHAR aCheckserialnum[] = "CheckSerialNumber"; // idb
CHAR aReggetinstalli[] = "RegGetInstallInfo"; // idb
CHAR aCheckevaluatio[] = "CheckEvaluationLimit"; // idb
FILE File = { NULL, 0, NULL, 2, 1, 0, 0, NULL }; // idb
_UNKNOWN unk_421A30; // weak
char byte_421C70[8] = { '\x01', '\x02', '\x04', '\b', '\0', '\0', '\0', '\0' }; // weak
_UNKNOWN unk_421C78; // weak
int dword_421C7C[] = { -2105965984 }; // weak
int dword_421C80[] = { 33 }; // weak
_UNKNOWN unk_421C88; // weak
_DWORD dword_421D68[2] = { 0, 0 }; // weak
void *off_421D80 = &unk_421D8A; // weak
size_t SrcSizeInBytes = 1u; // idb
int dword_4242A4 = 1; // weak
int dword_424338 = -1; // weak
int dword_42433C = 0; // weak
int dword_424340 = 0; // weak
int dword_424348 = -1; // weak
int dword_42434C = 0; // weak
int dword_424350 = 0; // weak
char Destination[12] = { '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0', '\0' }; // idb
int dword_4243DC = 0; // weak
char byte_4243E0 = '\0'; // idb
char byte_4243E1[135] =
{
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  
}; // weak
char Command[135]; // idb
char byte_4244EF[]; // weak
char byte_4244F0; // idb
char byte_4244F1[135]; // weak
char byte_424578[136]; // idb
char byte_424600[2456]; // weak
char byte_424F98[135]; // idb
char byte_42501F[]; // weak
char byte_425020[135]; // weak
char byte_4250A7[]; // weak
char byte_4250A8; // idb
char byte_4250A9[134]; // weak
char byte_42512F[]; // weak
char byte_425130; // idb
char byte_425131[131]; // weak
int dword_4251B4; // weak
char byte_4251B8; // weak
char byte_4251C8; // weak
int dword_4251CC; // weak
__int16 word_4251D0; // weak
__int16 word_4251D4; // weak
__int16 word_4251D8; // weak
char byte_4251DC; // weak
char byte_4251E0; // weak
char byte_4251E4; // weak
char byte_4251E8; // weak
char byte_4251EC; // weak
char byte_4251F0; // weak
char byte_4251F4; // weak
char byte_4251F8; // weak
char byte_4251FC; // weak
char byte_425200; // weak
char byte_425204; // weak
__int16 word_425208; // weak
__int16 word_42520C; // weak
int dword_425210; // weak
int dword_425218; // weak
int dword_42521C; // weak
__int16 word_425220; // weak
__int16 word_425222; // weak
int dword_425224; // weak
__int16 word_425228; // weak
int dword_42522A; // weak
char byte_42522E[42]; // weak
int dword_425258; // weak
int dword_42525C; // weak
__int16 word_425260; // weak
char byte_425262[54]; // weak
__int16 word_425298; // weak
char byte_42529C; // weak
char byte_4252A0; // weak
int dword_4252A4; // weak
int dword_4252A8; // weak
int dword_4252AC; // weak
int dword_4252B0; // weak
char byte_4252B4; // weak
char byte_4252B8; // weak
char byte_4252BC; // weak
__int16 word_4252C0; // weak
char byte_4252C4; // weak
char byte_4252C8; // weak
char byte_4252CC; // weak
__int16 word_4252D0; // weak
char byte_4252D8; // weak
char byte_4252D9; // weak
int dword_4252DA; // idb
char byte_4252DE; // weak
char byte_4252DF; // weak
__int16 word_4252E0; // weak
__int16 word_4252E2; // weak
int dword_4252E4; // weak
char byte_4252E8; // weak
char byte_4252E9; // weak
int dword_4252EC; // weak
int dword_4252F0; // weak
char byte_4252F4; // weak
char byte_4252F8; // weak
__int16 word_4252FC; // weak
char byte_425300; // weak
char byte_425304; // weak
char byte_425308; // weak
char byte_42530C; // weak
char byte_425310; // weak
char byte_425318[]; // weak
char byte_425319[]; // weak
int dword_42531A[]; // weak
char byte_42531E[]; // weak
char byte_42531F[]; // weak
char byte_425320; // weak
char byte_425321; // weak
int dword_425322; // weak
char byte_425326; // weak
char byte_425327; // weak
char byte_425328; // weak
char byte_425329; // weak
int dword_42532A; // weak
char byte_42532E; // weak
char byte_42532F; // weak
char byte_425330; // weak
char byte_425331; // weak
char byte_425332; // weak
char byte_425333; // weak
int dword_425334; // weak
char byte_425338; // weak
char byte_425339; // weak
char byte_42533C; // weak
char byte_425340; // weak
char byte_425344; // weak
char byte_425348; // weak
char byte_42534C; // weak
char byte_425350; // weak
char byte_425354; // weak
char byte_425358; // weak
char byte_42535C; // weak
char byte_425360; // weak
char byte_425364; // weak
int dword_425368; // weak
__int16 word_42536C; // weak
__int16 word_425370; // weak
__int16 word_425374; // weak
char byte_425378; // weak
char byte_42537C; // weak
int dword_425380; // weak
int dword_425388; // weak
int dword_42538C; // weak
int dword_425390; // weak
int dword_425394; // idb
int dword_425398; // weak
int dword_42539C; // weak
__int16 word_4253A0; // weak
char byte_4253BC[4]; // weak
int dword_425424; // weak
_UNKNOWN unk_425428; // weak
char byte_425429[263]; // weak
char byte_425530[256]; // weak
UINT CodePage; // idb
LCID Locale; // idb
int dword_425638; // weak
int dword_42563C; // weak
int dword_425640; // weak
int dword_425644; // weak
int dword_425658; // weak
LCID dword_425668; // idb
UINT dword_425678; // idb
int dword_425680[]; // weak
int dword_4256B4; // weak
int dword_4257E0; // weak
struct _TIME_ZONE_INFORMATION TimeZoneInformation; // idb
char byte_4258DF[]; // weak
char byte_4258E0; // idb
char byte_4258E1; // weak
__int16 word_425CE0; // weak
char byte_425D00[1024]; // idb
char *dword_426100; // idb
__int16 word_426104; // weak
__int16 word_426106; // weak
__int16 word_426108; // weak
char byte_426120[1400]; // idb
char *dword_426698; // idb
char byte_4266A0[1400]; // idb
__int16 word_426C18; // weak
struct _stat32 Stat; // idb
__int16 word_426C44; // weak
int dword_426C48; // weak
__int16 word_426C4C; // weak
char byte_426C60[2300]; // idb
__int16 word_42755C; // weak
int dword_427560; // weak
char byte_427564; // weak
int dword_427568; // weak
int dword_42756C; // idb
__int16 word_427570; // weak
char byte_427572; // weak
int dword_427574; // weak
int dword_427578; // weak
__int16 word_42757C; // weak
char byte_4278A0[]; // weak
char byte_4278A1; // weak
char byte_4278A2; // weak
int dword_427E20[]; // weak
char byte_427E24[]; // weak
int dword_427E28[898]; // weak
__int16 word_428C30; // weak
char byte_428C40[255]; // weak
char byte_428D3F; // weak
int dword_428D40[200]; // weak
char byte_429060; // weak
__int16 word_42907E[257]; // weak
char Ext[256]; // idb
char byte_429380[]; // weak
int dword_4293C0[24]; // weak
__int16 word_429420[]; // weak
int dword_429422; // weak
char byte_429D80[]; // weak
__int16 word_429D90; // weak
char FullPath[130]; // weak
__int16 word_429E22; // weak
CHAR Str[128]; // weak
char Drive[32]; // idb
char byte_429EE0[160]; // idb
char byte_429F80[200]; // weak
char byte_42A048; // weak
char byte_42A060[1400]; // weak
char byte_42A5D8; // weak
int dword_42A5E0[10000]; // weak
char byte_434220[160]; // idb
char byte_4342C0[132]; // idb
int dword_434344; // weak
__int16 word_43435E[257]; // weak
char byte_434560[]; // weak
char byte_434570; // weak
char Dir[173]; // idb
char byte_434680[256]; // idb
char byte_434780; // weak
__int16 word_434782; // weak
int dword_4347A0[]; // weak
int dword_4347A4[290]; // weak
char byte_438620; // weak
char byte_438640[1024]; // idb
char byte_438A40; // weak
__int16 word_438A42; // weak
char byte_438A60[18]; // idb
char byte_438A72[1006]; // idb
int dword_438E60[200]; // weak
char byte_439180[129]; // idb
char byte_439201; // weak
char byte_439202; // weak
char byte_439220[144]; // idb
int dword_4392B0[]; // weak
char byte_4392C0[132]; // idb
int dword_439344; // weak
int dword_439348; // idb
char byte_43934C; // weak
char byte_439360[129]; // idb
char byte_4393E1; // weak
char byte_4393E2; // weak
char Str1; // idb
char byte_439401[7999]; // weak
__int16 word_43B340; // weak
char byte_43B360[256]; // weak
__int16 word_43B460; // weak
char byte_43B480[160]; // idb
__int16 word_43B520[10000]; // weak
char byte_440340; // weak
char FileName[130]; // idb
__int16 word_4403E2; // weak
char byte_440400[130]; // idb
__int16 word_440482; // weak
int dword_4404A0[198]; // weak
int dword_4407B8[]; // weak
int dword_4407BC[]; // weak
int dword_4407C0[]; // weak
int dword_4407C4[1999]; // weak
int Offset; // idb
char byte_442720[]; // weak
char byte_442721[]; // weak
int dword_442722[]; // weak
char byte_442726[]; // weak
char byte_442727[393]; // weak
int Value; // idb
int dword_4428B4; // weak
__int16 word_4428C0[]; // weak
int dword_4428C4[]; // weak
__int16 word_4428C8[3389]; // weak
int dword_4457A0; // weak
char byte_4457B4[260]; // idb
int dword_4458B8; // weak
jmp_buf Buf; // idb
int dword_445900; // weak
char Buffer[1400]; // idb
__int16 word_445E98; // weak
__int16 word_445E9A; // weak
FILE *dword_445E9C; // idb
FILE *dword_445EA0; // idb
FILE *dword_445EA4; // idb
FILE *dword_445EA8; // idb
FILE *dword_445EAC; // idb
FILE *dword_445EB0; // idb
FILE *Stream; // idb
FILE *dword_445EB8; // idb
int dword_445FC8; // weak


//----- (004010A0) --------------------------------------------------------
int __cdecl sub_4010A0(unsigned __int16 *a1)
{
  if ( *a1 <= 0x40u )
    *a1 = (unsigned __int8)byte_420F48[(__int16)*a1];
  return 0;
}

//----- (004010E0) --------------------------------------------------------
int __cdecl sub_4010E0(_WORD *a1)
{
  __int16 v2; // [esp+0h] [ebp-8h]
  __int16 i; // [esp+4h] [ebp-4h]

  v2 = 0;
  for ( i = 2483; i > 0 && word_41D030[v2] != *a1; --i )
    ++v2;
  if ( i <= 0 )
    *a1 = 0;
  else
    *a1 = word_41E398[v2];
  return 0;
}
// 41D030: using guessed type __int16 word_41D030[];
// 41E398: using guessed type __int16 word_41E398[2484];

//----- (00401158) --------------------------------------------------------
int __cdecl sub_401158(_WORD *a1)
{
  __int16 v2; // [esp+0h] [ebp-8h]
  __int16 i; // [esp+4h] [ebp-4h]

  v2 = 0;
  for ( i = 784; i > 0 && word_41F700[v2] != *a1; --i )
    ++v2;
  if ( i <= 0 )
    *a1 = 0;
  else
    *a1 = word_41FD20[v2];
  return 0;
}
// 41F700: using guessed type __int16 word_41F700[784];
// 41FD20: using guessed type __int16 word_41FD20[784];

//----- (004011D0) --------------------------------------------------------
char __cdecl sub_4011D0(_WORD *a1)
{
  char v2[4]; // [esp+0h] [ebp-Ch] BYREF
  int v3; // [esp+4h] [ebp-8h] BYREF
  char v4; // [esp+8h] [ebp-4h]

  v4 = 0;
  v4 = sub_40125D((unsigned __int8 *)&v3);
  if ( v4 || (unsigned __int8)v3 == 255 )
  {
    if ( (unsigned __int8)v3 == 255 )
      *a1 = 255;
  }
  else
  {
    v4 = sub_4019F0(v3, v2);
    *a1 = (unsigned __int8)v2[0];
    if ( v4 )
    {
      *a1 = 0;
      word_425208 = -32767;
      return -1;
    }
  }
  return v4;
}
// 425208: using guessed type __int16 word_425208;
// 4011D0: using guessed type char var_C[4];

//----- (0040125D) --------------------------------------------------------
char __cdecl sub_40125D(unsigned __int8 *a1)
{
  int v1; // edx
  __int16 v3; // [esp+0h] [ebp-10h]
  __int16 v4; // [esp+4h] [ebp-Ch]
  __int16 v5; // [esp+8h] [ebp-8h]
  char v6; // [esp+Ch] [ebp-4h]

  v6 = 0;
  v4 = 1;
  while ( v4 )
  {
    if ( !word_428C30 )
    {
      if ( !byte_425204 )
        dword_4428B4 = ftell(Stream);
      v6 = sub_4015F6();
      word_428C30 = 1;
      word_429D90 = 0;
      word_42757C = 0;
    }
    if ( v6 == 99 )
    {
      word_428C30 = 0;
      word_42755C = 3;
      word_43B340 = 0;
      *(_WORD *)a1 = 37;
      word_4403E2 = 2;
      v4 = 0;
    }
    else
    {
      v3 = byte_4278A0[word_429D90++];
      word_42757C = 0;
      v5 = 0;
      if ( byte_4278A0[0] == 40 && byte_4278A1 == 42 )
      {
        word_42757C = 0;
      }
      else
      {
        while ( v5 != word_429D90 )
        {
          v1 = byte_42A060[word_42757C++];
          if ( v1 != 32 )
            ++v5;
        }
      }
      if ( word_429D90 == 1 )
      {
        if ( byte_4278A0[0] == 47 && byte_4278A1 == 42 )
        {
          word_428C30 = 0;
        }
        else if ( v3 == 37 )
        {
          word_428C30 = 0;
          word_42755C = 2;
          word_43B340 = 0;
          if ( word_4403E2 != 2 )
            word_4403E2 = 1;
          if ( !byte_425204 )
            ++word_440482;
          v4 = 0;
        }
        else if ( word_43B340 || v3 != 79 )
        {
          if ( word_43B340 || v3 != 58 )
          {
            if ( word_43B340 == 1 && (v3 == 79 || v3 == 58) )
            {
              word_428C30 = 0;
              word_43B340 = 0;
              word_42755C = 1;
              v3 = 37;
              if ( !byte_425204 )
                ++word_440482;
              v4 = 0;
            }
            else if ( v3 )
            {
              word_42755C = 0;
              if ( !byte_425204 )
                ++word_440482;
              v4 = 0;
            }
            else
            {
              v3 = 255;
              word_428C30 = 0;
              word_42755C = 3;
              v4 = 0;
            }
          }
          else
          {
            dword_425380 = 2;
            word_43B340 = 1;
            v4 = 0;
          }
        }
        else
        {
          dword_425380 = 1;
          word_43B340 = 1;
          v4 = 0;
        }
      }
      else if ( v3 )
      {
        word_428C30 = 1;
        word_42755C = 0;
        v4 = 0;
      }
      else
      {
        v3 = 255;
        v4 = 0;
        word_428C30 = 0;
      }
      *(_WORD *)a1 = v3;
      if ( !byte_425204 && dword_427568 < 1000 && dword_439344 < 2000 )
        sub_401A56(*a1);
    }
  }
  return v6;
}
// 425204: using guessed type char byte_425204;
// 425380: using guessed type int dword_425380;
// 42755C: using guessed type __int16 word_42755C;
// 427568: using guessed type int dword_427568;
// 42757C: using guessed type __int16 word_42757C;
// 4278A1: using guessed type char byte_4278A1;
// 428C30: using guessed type __int16 word_428C30;
// 429D90: using guessed type __int16 word_429D90;
// 439344: using guessed type int dword_439344;
// 43B340: using guessed type __int16 word_43B340;
// 4403E2: using guessed type __int16 word_4403E2;
// 440482: using guessed type __int16 word_440482;
// 4428B4: using guessed type int dword_4428B4;

//----- (004015F6) --------------------------------------------------------
char sub_4015F6()
{
  unsigned __int16 v1; // [esp+0h] [ebp-14h]
  __int16 v2; // [esp+8h] [ebp-Ch]
  __int16 v3; // [esp+Ch] [ebp-8h]
  char v4; // [esp+10h] [ebp-4h]

  v4 = 0;
  v3 = 1;
  v2 = 0;
  while ( v3 )
  {
    v1 = fgetc(Stream);
    if ( v1 == 10 )
    {
      byte_42A060[v2++] = v1;
      ++word_429E22;
      v3 = 0;
    }
    else if ( v1 != 13 )
    {
      if ( v1 == 0xFFFF )
      {
        if ( v2 )
        {
          byte_42A060[v2++] = 10;
          v3 = 0;
        }
        else
        {
          byte_42A060[0] = 37;
          byte_42A060[1] = 10;
          v2 = 2;
          if ( !word_4403E2 )
            word_4403E2 = 2;
          v4 = 99;
          v3 = 0;
        }
      }
      else
      {
        byte_42A060[v2++] = v1;
      }
    }
    if ( v2 >= 1397 )
    {
      byte_42A060[v2++] = 10;
      v3 = 0;
    }
  }
  byte_42A060[v2] = 0;
  sub_4017C1(byte_42A060, &byte_4278A0);
  if ( byte_4278A0 == 37 && byte_4278A1 == 10 && !byte_4278A2 && word_429E22 > 1 )
    v4 = 0;
  dword_434344 = ftell(Stream);
  return v4;
}
// 4278A0: using guessed type char byte_4278A0;
// 4278A1: using guessed type char byte_4278A1;
// 4278A2: using guessed type char byte_4278A2;
// 429E22: using guessed type __int16 word_429E22;
// 434344: using guessed type int dword_434344;
// 4403E2: using guessed type __int16 word_4403E2;

//----- (004017C1) --------------------------------------------------------
int __cdecl sub_4017C1(_BYTE *a1, _BYTE *a2)
{
  int v3; // [esp+0h] [ebp-20h]
  char v4; // [esp+4h] [ebp-1Ch]
  bool v5; // [esp+8h] [ebp-18h]
  int v6; // [esp+Ch] [ebp-14h]
  int i; // [esp+10h] [ebp-10h]
  int j; // [esp+10h] [ebp-10h]
  int k; // [esp+10h] [ebp-10h]
  char v10; // [esp+14h] [ebp-Ch]
  char v11; // [esp+14h] [ebp-Ch]
  int v12; // [esp+18h] [ebp-8h]
  int v13; // [esp+1Ch] [ebp-4h]

  v6 = 0;
  v12 = 0;
  v3 = 0;
  v13 = 0;
  v4 = 0;
  v5 = 0;
  if ( *a1 )
  {
    for ( i = 0; i < 1397; ++i )
    {
      v10 = sub_4111A0((char)a1[i]);
      if ( !v10 )
        break;
      if ( v4 )
      {
        if ( v4 == 1 )
        {
          if ( v10 == 42 )
          {
            v4 = 2;
            v3 = i;
          }
          else
          {
            v4 = 0;
          }
        }
        else if ( v4 == 2 )
        {
          if ( v5 )
          {
            if ( v5 )
            {
              if ( v10 == 41 )
              {
                v5 = 0;
                v12 = i;
              }
              else
              {
                v5 = 0;
              }
            }
          }
          else
          {
            v5 = v10 == 42;
          }
        }
      }
      else
      {
        v4 = v10 == 40;
      }
    }
    for ( j = 0; j < 1397; ++j )
    {
      v11 = sub_4111A0((char)a1[j]);
      if ( !v11 )
        break;
      if ( v12 <= 0 )
      {
        a2[v6++] = v11;
      }
      else if ( j <= v3 || j >= v12 )
      {
        a2[v6++] = v11;
      }
      else
      {
        if ( v11 == 32 || v11 == 9 )
          ++v13;
        else
          v13 = 0;
        a2[v6++] = v11;
      }
    }
    a2[v6] = 0;
    for ( k = 0; k < 1397 && a2[k]; ++k )
    {
      if ( a2[k] == 59 )
      {
        a2[k] = 10;
        a2[++k] = 0;
        return k;
      }
    }
    return k;
  }
  else
  {
    *a2 = 0;
    return 0;
  }
}

//----- (004019F0) --------------------------------------------------------
int __cdecl sub_4019F0(char a1, _BYTE *a2)
{
  int i; // [esp+0h] [ebp-Ch]
  int v4; // [esp+8h] [ebp-4h]

  v4 = 0;
  for ( i = 0; i < 65 && byte_420F48[i] != a1; ++i )
    ;
  *a2 = i;
  if ( i >= 65 )
    return 1;
  return v4;
}

//----- (00401A56) --------------------------------------------------------
size_t __cdecl sub_401A56(unsigned __int8 a1)
{
  size_t result; // eax
  char Source[8]; // [esp+0h] [ebp-10h] BYREF
  int i; // [esp+8h] [ebp-8h]
  int v4; // [esp+Ch] [ebp-4h]

  v4 = 0;
  result = a1;
  if ( a1 == 35 )
  {
    dword_4243DC = 1;
    return (size_t)strcpy(Destination, ::Source);
  }
  else if ( dword_4243DC == 1 && a1 >= 0x30u && a1 <= 0x39u )
  {
    Source[0] = a1;
    Source[1] = 0;
    return (size_t)strcat(Destination, Source);
  }
  else if ( dword_4243DC == 1 )
  {
    if ( a1 < 0x30u || (result = a1, a1 > 0x39u) )
    {
      dword_4243DC = 0;
      result = strlen(Destination);
      if ( result > 1 )
      {
        v4 = 0;
        for ( i = 0; i <= dword_427568 && strcmp((const char *)(8 * i + 4428800), Destination); ++i )
          ++v4;
        if ( --i == dword_427568 )
        {
          strncpy((char *)(8 * i + 4428800), Destination, 7u);
          dword_4347A0[2 * dword_439344] = i;
          dword_4347A4[2 * dword_439344] = (unsigned __int16)word_440482 + 1;
          ++dword_427568;
          result = dword_439344 + 1;
        }
        else
        {
          dword_4347A0[2 * dword_439344] = v4;
          result = (unsigned __int16)word_440482 + 1;
          dword_4347A4[2 * dword_439344] = result;
        }
        ++dword_439344;
      }
    }
  }
  return result;
}
// 4243DC: using guessed type int dword_4243DC;
// 427568: using guessed type int dword_427568;
// 4347A0: using guessed type int dword_4347A0[];
// 4347A4: using guessed type int dword_4347A4[290];
// 439344: using guessed type int dword_439344;
// 440482: using guessed type __int16 word_440482;

//----- (00401C1E) --------------------------------------------------------
int __cdecl sub_401C1E(unsigned __int16 a1, char *Buffer)
{
  int v3; // [esp+0h] [ebp-84h] BYREF
  char Destination[128]; // [esp+4h] [ebp-80h] BYREF

  strcpy(Destination, byte_440400);
  strcat(Destination, aErrorDoc);
  dword_445EA8 = fopen(Destination, Mode);
  if ( dword_445EA8 )
  {
    while ( fscanf(dword_445EA8, "%x", &v3) != -1 )
    {
      fgets(Buffer, 80, dword_445EA8);
      if ( a1 == (unsigned __int16)v3 )
      {
        printf("    %s(%u) : ERROR %04X : %s", byte_439360, word_445E9A, v3, Buffer);
        fclose(dword_445EA8);
        return 0;
      }
      if ( v3 == 9999 )
      {
        fclose(dword_445EA8);
        return 0;
      }
    }
    strcpy(Buffer, aErrorDocFileNo);
    fclose(dword_445EA8);
  }
  else
  {
    sub_4052AE(11);
  }
  return 1;
}
// 445E9A: using guessed type __int16 word_445E9A;

//----- (00401D4C) --------------------------------------------------------
char __cdecl sub_401D4C(int a1, int a2)
{
  __int16 v3; // [esp+0h] [ebp-10h]
  int Offset; // [esp+4h] [ebp-Ch]
  char v5; // [esp+8h] [ebp-8h]

  v5 = 0;
  Offset = a1;
  if ( byte_425204 == 2 )
  {
    fseek(Stream, a1, 0);
    v3 = 1;
    while ( v3 )
    {
      if ( Offset >= a2 )
      {
        v3 = 0;
      }
      else
      {
        v5 = sub_4015F6();
        if ( word_42755C != 1 )
          sub_402593();
        Offset = ftell(Stream);
      }
    }
    dword_427560 = Offset;
    if ( !byte_43934C )
      ::Offset = ftell(dword_445EAC);
  }
  return v5;
}
// 425204: using guessed type char byte_425204;
// 42755C: using guessed type __int16 word_42755C;
// 427560: using guessed type int dword_427560;
// 43934C: using guessed type char byte_43934C;

//----- (00401E02) --------------------------------------------------------
char sub_401E02()
{
  __int16 i; // [esp+0h] [ebp-4h]

  for ( i = 0; i < dword_42539C; ++i )
  {
    if ( dword_4428C4[3 * i] == dword_427560 && word_4428C0[6 * i] )
    {
      if ( !byte_43934C )
      {
        fflush(dword_445EAC);
        if ( (dword_445EAC->_flag & 0x20) != 0 )
          longjmp(Buf, 9);
        fseek(dword_445EAC, Offset, 0);
      }
      sub_401F69(dword_427560);
    }
  }
  return 0;
}
// 42539C: using guessed type int dword_42539C;
// 427560: using guessed type int dword_427560;
// 43934C: using guessed type char byte_43934C;
// 4428C0: using guessed type __int16 word_4428C0[];
// 4428C4: using guessed type int dword_4428C4[];

//----- (00401EBD) --------------------------------------------------------
__int16 __cdecl sub_401EBD(__int16 a1)
{
  int v1; // eax
  __int16 v3; // [esp+0h] [ebp-8h]
  __int16 i; // [esp+4h] [ebp-4h]

  v3 = 0;
  for ( i = 0; i < dword_42539C; ++i )
  {
    v1 = dword_4428C4[3 * i];
    if ( v1 == dword_434344 )
    {
      v3 = 1;
      break;
    }
    LOWORD(v1) = i + 1;
  }
  if ( !v3 )
  {
    word_4428C0[6 * i] = a1;
    dword_4428C4[3 * i] = dword_434344;
    v1 = 12 * i;
    *(__int16 *)((char *)&word_4428C8 + v1) = word_42757C;
    if ( dword_42539C < 1000 )
      ++dword_42539C;
  }
  return v1;
}
// 401F65: variable 'v1' is possibly undefined
// 42539C: using guessed type int dword_42539C;
// 42757C: using guessed type __int16 word_42757C;
// 434344: using guessed type int dword_434344;
// 4428C0: using guessed type __int16 word_4428C0[];
// 4428C4: using guessed type int dword_4428C4[];
// 4428C8: using guessed type __int16 word_4428C8;

//----- (00401F69) --------------------------------------------------------
__int16 __cdecl sub_401F69(int a1)
{
  __int16 result; // ax
  __int16 i; // [esp+0h] [ebp-4h]

  for ( i = 0; i < dword_42539C; ++i )
  {
    if ( dword_4428C4[3 * i] <= a1 )
    {
      if ( word_4428C0[6 * i] )
      {
        sub_402616(word_4428C0[6 * i], word_4428C8[6 * i]);
        word_4428C0[6 * i] = 0;
      }
    }
    result = i + 1;
  }
  return result;
}
// 42539C: using guessed type int dword_42539C;
// 4428C0: using guessed type __int16 word_4428C0[];
// 4428C4: using guessed type int dword_4428C4[];
// 4428C8: using guessed type __int16 word_4428C8[3389];

//----- (00401FF0) --------------------------------------------------------
int sub_401FF0()
{
  int *v1; // [esp+0h] [ebp-10h] BYREF
  int v2; // [esp+4h] [ebp-Ch]
  char *Str1; // [esp+8h] [ebp-8h]
  int v4; // [esp+Ch] [ebp-4h]

  v1 = &dword_4293C0;
  LOWORD(v4) = 0;
  puts(byte_439220);
  Stream = fopen(byte_434220, aRb);
  if ( Stream )
  {
    Str1 = getenv(VarName);
    if ( Str1 && (!strcmp(Str1, aYes) || !strcmp(Str1, aYes_0)) )
      fgets(Buffer, 1400, Stream);
    if ( byte_43934C || (puts(byte_439360), (dword_445EAC = fopen(byte_439360, aW)) != 0) )
    {
      if ( byte_42A048 || (puts(byte_4392C0), (dword_445E9C = fopen(byte_43B480, aWb)) != 0) )
      {
        byte_425204 = 0;
        dword_439348 = ftell(Stream);
        dword_4428B4 = dword_439348;
        word_42755C = 0;
        word_428C30 = 0;
        dword_427574 = 0;
        word_4403E2 = 0;
        dword_425388 = 0;
        word_445E98 = 0;
        sub_4033C6(256);
        LOWORD(v2) = 1;
        while ( (_WORD)v2 )
        {
          if ( dword_427574 >= 1000 )
          {
            LOWORD(v4) = 12;
            break;
          }
          Value = 0;
          dword_4252EC = 0;
          dword_42756C = 0;
          dword_427568 = 0;
          dword_439344 = 0;
          word_440482 = 0;
          word_429D90 = 0;
          word_42757C = 0;
          dword_425398 = 0;
          dword_42539C = 0;
          word_427570 = 0;
          dword_425390 = 55;
          dword_42538C = 1;
          dword_425394 = 0;
          sub_40E330();
          for ( byte_425204 = 0; (unsigned __int8)byte_425204 < 3u; ++byte_425204 )
          {
            LOWORD(v4) = 0;
            word_429D90 = 0;
            word_42757C = 0;
            word_429E22 = 0;
            dword_427578 = 0;
            dword_425398 = 0;
            fseek(Stream, dword_439348, 0);
            dword_427560 = dword_439348;
            dword_434344 = dword_439348;
            LOWORD(v4) = (char)sub_40B4F0((char)&v1);
            if ( byte_425204 == 2 )
            {
              sub_402705(*v1);
              sub_402A16();
            }
            if ( (unsigned __int16)v4 == 99 )
            {
              if ( byte_425204 == 2 )
              {
                LOWORD(v2) = 0;
                LOWORD(v4) = 0;
              }
            }
            else if ( word_42755C == 3 )
            {
              LOWORD(v2) = 0;
            }
          }
          if ( dword_427574 > 0 && dword_42756C )
          {
            dword_4407BC[2 * dword_427574] = dword_42756C;
            dword_439348 = dword_4428B4;
          }
          if ( word_4403E2 )
          {
            if ( word_4403E2 == 2 || word_4403E2 == 3 )
              LOWORD(v4) = 13;
            else
              LOWORD(v4) = 0;
            LOWORD(v2) = 0;
          }
        }
        sub_403482();
        if ( !byte_42A048 && fclose(dword_445E9C) )
          LOWORD(v4) = 10;
        if ( !byte_43934C && fclose(dword_445EAC) )
          LOWORD(v4) = 9;
        if ( fclose(Stream) )
          LOWORD(v4) = 8;
      }
      else
      {
        fclose(Stream);
        if ( !byte_43934C )
          fclose(dword_445EAC);
        LOWORD(v4) = 10;
      }
    }
    else
    {
      fclose(Stream);
      LOWORD(v4) = 9;
    }
  }
  else
  {
    LOWORD(v4) = 8;
  }
  return (unsigned __int16)v4;
}
// 402705: using guessed type _DWORD __cdecl sub_402705(_DWORD);
// 402A16: using guessed type int sub_402A16(void);
// 4033C6: using guessed type _DWORD __cdecl sub_4033C6(_DWORD);
// 403482: using guessed type int sub_403482(void);
// 40B4F0: using guessed type _DWORD __cdecl sub_40B4F0(char);
// 40E330: using guessed type int sub_40E330(void);
// 425204: using guessed type char byte_425204;
// 4252EC: using guessed type int dword_4252EC;
// 425388: using guessed type int dword_425388;
// 42538C: using guessed type int dword_42538C;
// 425390: using guessed type int dword_425390;
// 425398: using guessed type int dword_425398;
// 42539C: using guessed type int dword_42539C;
// 42755C: using guessed type __int16 word_42755C;
// 427560: using guessed type int dword_427560;
// 427568: using guessed type int dword_427568;
// 427570: using guessed type __int16 word_427570;
// 427574: using guessed type int dword_427574;
// 427578: using guessed type int dword_427578;
// 42757C: using guessed type __int16 word_42757C;
// 428C30: using guessed type __int16 word_428C30;
// 4293C0: using guessed type int dword_4293C0;
// 429D90: using guessed type __int16 word_429D90;
// 429E22: using guessed type __int16 word_429E22;
// 42A048: using guessed type char byte_42A048;
// 434344: using guessed type int dword_434344;
// 439344: using guessed type int dword_439344;
// 43934C: using guessed type char byte_43934C;
// 4403E2: using guessed type __int16 word_4403E2;
// 440482: using guessed type __int16 word_440482;
// 4407BC: using guessed type int dword_4407BC[];
// 4428B4: using guessed type int dword_4428B4;
// 445E98: using guessed type __int16 word_445E98;

//----- (00402486) --------------------------------------------------------
int __cdecl sub_402486(int Value)
{
  unsigned __int8 v2; // [esp+0h] [ebp-18h]
  __int16 i; // [esp+4h] [ebp-14h]
  char Str[12]; // [esp+8h] [ebp-10h] BYREF
  int v5; // [esp+14h] [ebp-4h]

  v5 = 0;
  if ( dword_425380 == 1 )
    strcpy(byte_438A60, aProgramO);
  else
    strcpy(byte_438A60, aProgram);
  _ltoa(Value, Str, 10);
  v2 = 8 - strlen(Str);
  strcat(byte_438A60, Str);
  strcat(byte_438A60, asc_4203E8);
  for ( i = 0; i < v2 + 41; ++i )
    strcat(byte_438A60, asc_4203EC);
  strcat(byte_438A60, asc_4203F0);
  strcat(byte_438A60, aGLinePLine);
  sub_402FA2(1, byte_438A60);
  word_445E9A += 4;
  return v5;
}
// 425380: using guessed type int dword_425380;
// 445E9A: using guessed type __int16 word_445E9A;

//----- (00402593) --------------------------------------------------------
int sub_402593()
{
  int result; // eax

  ++dword_425394;
  strcpy(byte_438A60, byte_42A060);
  if ( !sub_4017C1(byte_42A060, byte_438A60) )
    return sub_402FA2(3, byte_42A060);
  result = sub_402FA2(0, byte_42A060);
  ++dword_42538C;
  ++word_445E9A;
  return result;
}
// 42538C: using guessed type int dword_42538C;
// 445E9A: using guessed type __int16 word_445E9A;

//----- (00402616) --------------------------------------------------------
int __cdecl sub_402616(signed __int16 a1, __int16 a2)
{
  __int16 i; // [esp+0h] [ebp-4h]

  sprintf(byte_438A60, "error #%04hX ", a1);
  for ( i = 0; i < a2 + 7; ++i )
    strcat(byte_438A60, asc_420418);
  strcat(byte_438A60, asc_42041C);
  sub_402FA2(1, byte_438A60);
  ++word_445E9A;
  sprintf(byte_438A60, "***** ERROR : %04hX", a1);
  sub_401C1E(a1, byte_438A72);
  sub_402FA2(1, byte_438A60);
  ++word_445E9A;
  ++Value;
  return ++dword_445900;
}
// 445900: using guessed type int dword_445900;
// 445E9A: using guessed type __int16 word_445E9A;

//----- (00402705) --------------------------------------------------------
int __cdecl sub_402705(int a1)
{
  __int16 i; // [esp+0h] [ebp-14h]
  char Source[12]; // [esp+4h] [ebp-10h] BYREF
  int v4; // [esp+10h] [ebp-4h]

  v4 = 0;
  strcpy(byte_438A60, asc_420434);
  for ( i = 0; i < 70; ++i )
    strcat(byte_438A60, asc_420438);
  strcat(byte_438A60, asc_42043C);
  sub_402FA2(1, byte_438A60);
  word_445E9A += 3;
  strcpy(byte_438A60, asc_420440);
  _itoa(Value, Source, 10);
  strcat(byte_438A60, Source);
  strcat(byte_438A60, aErrors);
  _itoa(dword_42538C - 1, Source, 10);
  strcat(byte_438A60, Source);
  strcat(byte_438A60, aBlocks);
  _itoa(dword_425394, Source, 10);
  strcat(byte_438A60, Source);
  strcat(byte_438A60, aTotalLines);
  sub_402FA2(1, byte_438A60);
  word_445E9A += 2;
  strcpy(byte_438A60, aProgramSize);
  _ltoa(dword_42756C, Source, 10);
  strcat(byte_438A60, Source);
  strcat(byte_438A60, aBytes);
  sub_402FA2(1, byte_438A60);
  word_445E9A += 2;
  sub_402FA2(2, byte_438A60);
  if ( dword_425380 == 1 )
    printf("Program count = %d   Program No.= O%08lu   Error=%d \n", dword_427574, a1, Value);
  else
    printf("Program count = %d   Program No.= :%08lu   Error=%d \n", dword_427574, a1, Value);
  return v4;
}
// 402FA2: using guessed type _DWORD __cdecl sub_402FA2(_DWORD, _DWORD);
// 425380: using guessed type int dword_425380;
// 42538C: using guessed type int dword_42538C;
// 427574: using guessed type int dword_427574;
// 445E9A: using guessed type __int16 word_445E9A;

//----- (0040292E) --------------------------------------------------------
char __cdecl sub_40292E(char a1)
{
  if ( byte_425204 == 2 )
  {
    sub_4029B2(a1);
    if ( sub_402976(a1) )
      return 10;
    ++dword_42756C;
  }
  return 0;
}
// 425204: using guessed type char byte_425204;

//----- (00402976) --------------------------------------------------------
int __cdecl sub_402976(char a1)
{
  if ( byte_42A048 )
    return 0;
  fputc(a1, dword_445E9C);
  if ( (dword_445E9C->_flag & 0x20) == 0 )
    return 0;
  else
    return 10;
}
// 42A048: using guessed type char byte_42A048;

//----- (004029B2) --------------------------------------------------------
int __cdecl sub_4029B2(char a1)
{
  if ( dword_425398 >= 300 )
    return 1;
  dword_427E20[3 * dword_425398] = dword_42756C;
  byte_427E24[12 * dword_425398] = a1;
  dword_427E28[3 * dword_425398++] = (unsigned __int8)byte_425330;
  return 0;
}
// 425330: using guessed type char byte_425330;
// 425398: using guessed type int dword_425398;
// 427E20: using guessed type int dword_427E20[];
// 427E28: using guessed type int dword_427E28[898];

//----- (00402A16) --------------------------------------------------------
int sub_402A16()
{
  int result; // eax
  int v1; // esi
  char v2[12]; // [esp+4h] [ebp-40h] BYREF
  char String[12]; // [esp+10h] [ebp-34h] BYREF
  int k; // [esp+1Ch] [ebp-28h]
  int j; // [esp+20h] [ebp-24h]
  int i; // [esp+24h] [ebp-20h]
  char Destination[12]; // [esp+28h] [ebp-1Ch] BYREF
  int v8; // [esp+34h] [ebp-10h]
  char Source[12]; // [esp+38h] [ebp-Ch] BYREF

  if ( !byte_438A40 )
    return 0;
  if ( dword_427568 < 999 && dword_439344 < 1999 )
  {
    for ( i = 0; i < dword_439344 - 1; ++i )
    {
      for ( j = i + 1; j < dword_439344; ++j )
      {
        if ( dword_4347A0[2 * i] > dword_4347A0[2 * j] )
        {
          v8 = dword_4347A0[2 * i];
          dword_4347A0[2 * i] = dword_4347A0[2 * j];
          dword_4347A0[2 * j] = v8;
          v8 = dword_4347A4[2 * i];
          dword_4347A4[2 * i] = dword_4347A4[2 * j];
          dword_4347A4[2 * j] = v8;
        }
      }
    }
    for ( i = 0; i < dword_427568 - 1; ++i )
    {
      for ( j = i + 1; j < dword_427568; ++j )
      {
        for ( k = 0; *(&Str1 + 8 * i + k); ++k )
          String[k] = byte_439401[8 * i + k];
        String[k] = 0;
        for ( k = 0; *(&Str1 + 8 * j + k); ++k )
          v2[k] = byte_439401[8 * j + k];
        v2[k] = 0;
        v1 = atol(String);
        if ( v1 > atol(v2) )
        {
          strcpy(Destination, (const char *)(8 * i + 4428800));
          strcpy((char *)(8 * i + 4428800), (const char *)(8 * j + 4428800));
          strcpy((char *)(8 * j + 4428800), Destination);
          sub_402EAE(i, j);
        }
      }
    }
    for ( i = 0; i < dword_439344 - 1; ++i )
    {
      for ( j = i + 1; j < dword_439344; ++j )
      {
        if ( dword_4347A4[2 * i] > dword_4347A4[2 * j] )
        {
          v8 = dword_4347A0[2 * i];
          dword_4347A0[2 * i] = dword_4347A0[2 * j];
          dword_4347A0[2 * j] = v8;
          v8 = dword_4347A4[2 * i];
          dword_4347A4[2 * i] = dword_4347A4[2 * j];
          dword_4347A4[2 * j] = v8;
        }
      }
    }
    sub_402FA2(1, asc_420574);
    sub_402FA2(1, aCrossReference);
    sub_402FA2(1, asc_4205C0);
    word_445E9A += 3;
    for ( i = 0; ; ++i )
    {
      result = i;
      if ( i >= dword_427568 )
        break;
      sprintf(byte_438A60, "%10s : ", (const char *)(8 * i + 4428800));
      for ( j = 0; j < dword_439344; ++j )
      {
        if ( i == dword_4347A0[2 * j] )
        {
          sprintf(Source, "%d, ", dword_4347A4[2 * j]);
          strcat(byte_438A60, Source);
          if ( strlen(byte_438A60) > 0x48 )
          {
            strcat(byte_438A60, asc_4205D4);
            sub_402FA2(1, byte_438A60);
            ++word_445E9A;
            strcpy(byte_438A60, asc_4205D8);
          }
        }
      }
      strcat(byte_438A60, asc_4205E8);
      sub_402FA2(1, byte_438A60);
      ++word_445E9A;
    }
  }
  else
  {
    result = sub_402FA2(1, aCanTMakeCrossR);
    word_445E9A += 2;
  }
  return result;
}
// 427568: using guessed type int dword_427568;
// 4347A0: using guessed type int dword_4347A0[];
// 4347A4: using guessed type int dword_4347A4[290];
// 438A40: using guessed type char byte_438A40;
// 439344: using guessed type int dword_439344;
// 445E9A: using guessed type __int16 word_445E9A;
// 402A16: using guessed type char String[12];
// 402A16: using guessed type char var_40[12];

//----- (00402EAE) --------------------------------------------------------
int __cdecl sub_402EAE(int a1, int a2)
{
  int result; // eax
  int v3; // [esp+0h] [ebp-14h]
  int i; // [esp+4h] [ebp-10h]
  int j; // [esp+4h] [ebp-10h]
  int k; // [esp+4h] [ebp-10h]
  int m; // [esp+4h] [ebp-10h]
  int v8; // [esp+8h] [ebp-Ch]
  int v9; // [esp+Ch] [ebp-8h]
  int v10; // [esp+10h] [ebp-4h]

  for ( i = 0; a1 != dword_4347A0[2 * i]; ++i )
    ;
  v8 = i;
  while ( a1 == dword_4347A0[2 * i] )
    ++i;
  v10 = i;
  for ( j = 0; a2 != dword_4347A0[2 * j]; ++j )
    ;
  v9 = j;
  while ( a2 == dword_4347A0[2 * j] )
    ++j;
  v3 = j;
  result = v8;
  for ( k = v8; k < v10; ++k )
  {
    result = k;
    dword_4347A0[2 * k] = a2;
  }
  for ( m = v9; m < v3; ++m )
  {
    dword_4347A0[2 * m] = a1;
    result = m + 1;
  }
  return result;
}
// 4347A0: using guessed type int dword_4347A0[];

//----- (00402FA2) --------------------------------------------------------
int __cdecl sub_402FA2(int a1, const char *a2)
{
  int result; // eax
  char *v3; // eax
  __time32_t Time; // [esp+8h] [ebp-40h] BYREF
  char Destination[28]; // [esp+Ch] [ebp-3Ch] BYREF
  int i; // [esp+28h] [ebp-20h]
  char v7[28]; // [esp+2Ch] [ebp-1Ch] BYREF

  if ( (unsigned __int8)byte_43934C == 255 )
    return 0;
  time(&Time);
  v3 = ctime(&Time);
  strcpy(Destination, v3);
  v7[0] = Destination[8];
  v7[1] = Destination[9];
  v7[2] = 45;
  v7[3] = Destination[4];
  v7[4] = Destination[5];
  v7[5] = Destination[6];
  v7[6] = 45;
  for ( i = 7; i < 11; ++i )
    v7[i] = Destination[i + 13];
  v7[11] = 32;
  for ( i = 12; i < 20; ++i )
    v7[i] = Destination[i - 1];
  v7[20] = 0;
  if ( ++dword_425390 >= 55 )
  {
    fprintf(dword_445EAC, &byte_4205EC);
    if ( (dword_445EAC->_flag & 0x20) != 0 )
      return 9;
    dword_425390 = 4;
    ++dword_425388;
    fprintf(dword_445EAC, "\n");
    if ( (dword_445EAC->_flag & 0x20) != 0 )
      return 9;
    ++word_445E9A;
    fprintf(dword_445EAC, "                                        %s      Page %4d \n", v7, dword_425388);
    if ( (dword_445EAC->_flag & 0x20) != 0 )
      return 9;
    ++word_445E9A;
    if ( byte_434780 )
    {
      fprintf(
        dword_445EAC,
        "                          (FS30i/FS0i)    Macro Compiler %s      %-13s\n",
        aV010,
        byte_439220);
      if ( (unsigned __int8)byte_439202 == 255 )
        fprintf(dword_445EAC, "                                          Select Series : 0i\n");
      else
        fprintf(dword_445EAC, "                                          Select Series : 30i\n");
    }
    else
    {
      fprintf(
        dword_445EAC,
        "                             (F15)      Macro Compiler %s      %-13s\n",
        aV010,
        byte_439220);
    }
    fprintf(dword_445EAC, "\n");
    if ( (dword_445EAC->_flag & 0x20) != 0 )
      return 9;
    word_445E9A += 2;
    if ( dword_425388 == 1 )
    {
      dword_425390 += 4;
      fprintf(dword_445EAC, "---------- Compile Parameter -----------------------------------------\n\n");
      fprintf(dword_445EAC, "        %s\n", byte_43B360);
      if ( (dword_445EAC->_flag & 0x20) != 0 )
        return 9;
      word_445E9A += 3;
    }
  }
  switch ( a1 )
  {
    case 0:
      fprintf(dword_445EAC, "    %04d    %4d     ", ++word_445E98, dword_42538C);
      if ( (dword_445EAC->_flag & 0x20) != 0 )
        return 9;
      fprintf(dword_445EAC, "%s", a2);
      if ( (dword_445EAC->_flag & 0x20) == 0 )
        goto LABEL_41;
      return 9;
    case 1:
      fprintf(dword_445EAC, "%s", a2);
      if ( (dword_445EAC->_flag & 0x20) == 0 )
        goto LABEL_41;
      return 9;
    case 2:
      dword_425390 = 55;
      goto LABEL_41;
    case 3:
      fprintf(dword_445EAC, "                ");
      if ( (dword_445EAC->_flag & 0x20) != 0 )
      {
        result = 9;
      }
      else
      {
        fprintf(dword_445EAC, "%s", a2);
        if ( (dword_445EAC->_flag & 0x20) != 0 )
          result = 9;
        else
LABEL_41:
          result = 0;
      }
      break;
    default:
      goto LABEL_41;
  }
  return result;
}
// 425388: using guessed type int dword_425388;
// 42538C: using guessed type int dword_42538C;
// 425390: using guessed type int dword_425390;
// 434780: using guessed type char byte_434780;
// 439202: using guessed type char byte_439202;
// 43934C: using guessed type char byte_43934C;
// 445E98: using guessed type __int16 word_445E98;
// 445E9A: using guessed type __int16 word_445E9A;

//----- (004033C6) --------------------------------------------------------
void __cdecl sub_4033C6(int a1)
{
  int i; // [esp+0h] [ebp-4h]

  for ( i = 0; i < a1 && !sub_402976(0); ++i )
    ;
}

//----- (004033FF) --------------------------------------------------------
int __cdecl sub_4033FF(__int16 a1)
{
  sub_402976(a1);
  return sub_402976(SHIBYTE(a1));
}

//----- (0040343B) --------------------------------------------------------
char *__cdecl sub_40343B(char a1)
{
  char *result; // eax
  char v2; // [esp+3h] [ebp-9h]
  int v3; // [esp+4h] [ebp-8h]
  char *v4; // [esp+8h] [ebp-4h]

  v3 = 0;
  result = &a1;
  v4 = &a1;
  while ( v3 < 4 )
  {
    v2 = *v4++;
    result = (char *)sub_402976(v2);
    ++v3;
  }
  return result;
}

//----- (00403482) --------------------------------------------------------
char *sub_403482()
{
  char *result; // eax
  int i; // [esp+0h] [ebp-10h]
  int j; // [esp+0h] [ebp-10h]
  int Offset; // [esp+4h] [ebp-Ch]
  int v4; // [esp+8h] [ebp-8h]
  char v5; // [esp+Ch] [ebp-4h]

  if ( (unsigned __int8)byte_42A048 == 255 )
    return 0;
  v4 = 0;
  for ( i = 0; i < dword_427574; ++i )
    v4 += dword_4407C4[2 * i];
  v5 = v4 + 8 * dword_427574;
  fflush(dword_445E9C);
  if ( (dword_445E9C->_flag & 0x20) != 0 )
    longjmp(Buf, 10);
  fseek(dword_445E9C, 0, 0);
  sub_4033FF(dword_427574);
  result = sub_40343B(v5);
  Offset = 256;
  for ( j = 0; j < dword_427574; ++j )
  {
    fflush(dword_445E9C);
    if ( (dword_445E9C->_flag & 0x20) != 0 )
      longjmp(Buf, 10);
    fseek(dword_445E9C, Offset, 0);
    sub_40343B(dword_4407C0[2 * j]);
    sub_40343B(dword_4407C4[2 * j]);
    Offset += dword_4407C4[2 * j] + 8;
    result = (char *)(j + 1);
  }
  return result;
}
// 427574: using guessed type int dword_427574;
// 42A048: using guessed type char byte_42A048;
// 4407C0: using guessed type int dword_4407C0[];
// 4407C4: using guessed type int dword_4407C4[1999];

//----- (004035F1) --------------------------------------------------------
int sub_4035F1()
{
  __int16 i; // [esp+8h] [ebp-14h]
  int v2; // [esp+Ch] [ebp-10h]
  char Source[12]; // [esp+10h] [ebp-Ch] BYREF

  v2 = -1;
  for ( i = 0; i < dword_425398; ++i )
  {
    if ( i )
    {
      if ( v2 != dword_427E28[3 * i] && v2 != -1 )
      {
        strcat(byte_438640, asc_420804);
        sub_403826();
        dword_427578 = 2;
      }
      if ( dword_427578 == 1 )
      {
        sprintf(Source, " %02hX", (unsigned __int8)byte_427E24[12 * i]);
        strcat(byte_438640, Source);
      }
      else
      {
        sprintf(byte_438640, "%08lX    %02hX", dword_427E20[3 * i], (unsigned __int8)byte_427E24[12 * i]);
        dword_427578 = 1;
      }
      v2 = dword_427E28[3 * i];
    }
    else
    {
      if ( dword_427578 )
      {
        if ( (byte_427E24[0] & 0x1F) == 30 )
        {
          sprintf(byte_438640, "%08lX  %02hX\n", dword_427E20[0], (unsigned __int8)byte_427E24[0]);
          sub_403826();
          dword_427578 = 2;
        }
        else
        {
          sprintf(byte_438640, "%08lX    %02hX", dword_427E20[0], (unsigned __int8)byte_427E24[0]);
          dword_427578 = 1;
        }
      }
      else
      {
        sprintf(byte_438640, "%08lX  %02hX\n", dword_427E20[0], (unsigned __int8)byte_427E24[0]);
        sub_403826();
        dword_427578 = 2;
      }
      v2 = -1;
    }
  }
  if ( dword_427578 == 1 && dword_425398 )
  {
    strcat(byte_438640, asc_420820);
    sub_403826();
  }
  dword_425398 = 0;
  return 0;
}
// 425398: using guessed type int dword_425398;
// 427578: using guessed type int dword_427578;
// 427E20: using guessed type int dword_427E20[];
// 427E28: using guessed type int dword_427E28[898];

//----- (00403826) --------------------------------------------------------
__int16 sub_403826()
{
  int v0; // eax
  __int16 v2; // [esp+0h] [ebp-8h]
  __int16 i; // [esp+4h] [ebp-4h]

  v2 = 0;
  LOWORD(v0) = (unsigned __int8)byte_428D3F;
  if ( (unsigned __int8)byte_428D3F == 255 )
  {
    for ( i = 0; i < dword_42539C; ++i )
    {
      v0 = 12 * i;
      if ( *(int *)((char *)dword_4428C4 + v0) == dword_427560 )
      {
        LOWORD(v0) = word_4428C0[6 * i];
        if ( (_WORD)v0 )
          v2 = 1;
      }
    }
    if ( !v2 )
    {
      LOWORD(v0) = sub_402FA2(1, byte_438640);
      ++word_445E9A;
    }
  }
  return v0;
}
// 42539C: using guessed type int dword_42539C;
// 427560: using guessed type int dword_427560;
// 428D3F: using guessed type char byte_428D3F;
// 4428C0: using guessed type __int16 word_4428C0[];
// 4428C4: using guessed type int dword_4428C4[];
// 445E9A: using guessed type __int16 word_445E9A;

//----- (004038C0) --------------------------------------------------------
int __cdecl __noreturn main(int argc, const char **argv, const char **envp)
{
  char v3; // [esp+0h] [ebp-1C8h]
  int v4; // [esp+4h] [ebp-1C4h]
  const char *Source; // [esp+8h] [ebp-1C0h]
  int k; // [esp+Ch] [ebp-1BCh]
  char *v7; // [esp+10h] [ebp-1B8h]
  char *v8; // [esp+10h] [ebp-1B8h]
  int i; // [esp+14h] [ebp-1B4h]
  int j; // [esp+14h] [ebp-1B4h]
  int m; // [esp+14h] [ebp-1B4h]
  int n; // [esp+14h] [ebp-1B4h]
  int ii; // [esp+14h] [ebp-1B4h]
  int jj; // [esp+14h] [ebp-1B4h]
  int kk; // [esp+14h] [ebp-1B4h]
  int mm; // [esp+14h] [ebp-1B4h]
  int nn; // [esp+14h] [ebp-1B4h]
  int i1; // [esp+14h] [ebp-1B4h]
  int i2; // [esp+14h] [ebp-1B4h]
  int i3; // [esp+14h] [ebp-1B4h]
  int i4; // [esp+14h] [ebp-1B4h]
  int i5; // [esp+14h] [ebp-1B4h]
  int i6; // [esp+14h] [ebp-1B4h]
  char *v24; // [esp+18h] [ebp-1B0h]
  char *v25; // [esp+18h] [ebp-1B0h]
  char *v26; // [esp+1Ch] [ebp-1ACh]
  char *v27; // [esp+1Ch] [ebp-1ACh]
  int v28; // [esp+20h] [ebp-1A8h]
  char v29; // [esp+24h] [ebp-1A4h]
  char v30; // [esp+28h] [ebp-1A0h]
  HANDLE hFindFile; // [esp+2Ch] [ebp-19Ch]
  char v32; // [esp+30h] [ebp-198h]
  char Buffer[132]; // [esp+34h] [ebp-194h] BYREF
  char *v34; // [esp+B8h] [ebp-110h]
  char *v35; // [esp+BCh] [ebp-10Ch]
  char Destination[132]; // [esp+C0h] [ebp-108h] BYREF
  char v37[132]; // [esp+144h] [ebp-84h] BYREF

  printf("Macro Compiler Start      %s \n", aV010);
  for ( i = 0; i < 128; ++i )
    Str[i] = 0;
  for ( j = 0; j < 19; ++j )
  {
    for ( k = 0; k < 128; ++k )
      byte_424600[129 * j + k] = 0;
  }
  for ( m = 0; m < 256; ++m )
    byte_43B360[m] = 0;
  for ( n = 0; n < 128; ++n )
  {
    byte_425020[n] = 0;
    *(&byte_4244F0 + n) = 0;
    *(&byte_4250A8 + n) = 0;
    *(&byte_4243E0 + n) = 0;
    *(&byte_425130 + n) = 0;
  }
  if ( sub_410D70() )
  {
    printf("Macro Compiler Error End\n");
    exit(-1);
  }
  if ( argc < 2 )
  {
LABEL_19:
    sub_4052AE(23);
    goto LABEL_252;
  }
  if ( strlen(argv[1]) > 0x7F )
  {
    sub_4052AE(2);
    goto LABEL_252;
  }
  for ( ii = 2; ii < argc; ++ii )
  {
    if ( strlen(argv[ii]) > 0x80 )
      goto LABEL_184;
  }
  strcpy(Str, argv[1]);
  for ( jj = 2; jj < argc; ++jj )
    sub_404FBF(argv[jj], &byte_424600[129 * jj - 258]);
  for ( kk = 2; kk < argc; ++kk )
  {
    if ( strcmp(&byte_424600[129 * kk - 258], Str2)
      && strcmp(&byte_424600[129 * kk - 258], aL1)
      && strcmp(&byte_424600[129 * kk - 258], aL2)
      && strcmp(&byte_424600[129 * kk - 258], aL3)
      && strcmp(&byte_424600[129 * kk - 258], aP)
      && strcmp(&byte_424600[129 * kk - 258], aNs)
      && strcmp(&byte_424600[129 * kk - 258], off_420880)
      && strcmp(&byte_424600[129 * kk - 258], aG_0)
      && strcmp(&byte_424600[129 * kk - 258], aC_1)
      && strcmp(&byte_424600[129 * kk - 258], aF0_0)
      && strcmp(&byte_424600[129 * kk - 258], aF15)
      && strcmp(&byte_424600[129 * kk - 258], aFs0)
      && strcmp(&byte_424600[129 * kk - 258], aPr)
      && strcmp(&byte_424600[129 * kk - 258], aNcross)
      && strcmp(&byte_424600[129 * kk - 258], off_4208AC)
      && strcmp(&byte_424600[129 * kk - 258], a0_0)
      && strcmp(&byte_424600[129 * kk - 258], a30_0)
      && !strstr(&byte_424600[129 * kk - 258], SubStr)
      && !strstr(&byte_424600[129 * kk - 258], aFl_0)
      && !strstr(&byte_424600[129 * kk - 258], aFr_0)
      && !strstr(&byte_424600[129 * kk - 258], aFp_0) )
    {
      goto LABEL_184;
    }
  }
  byte_434780 = 0;
  byte_42A048 = 0;
  byte_43934C = 0;
  byte_428D3F = 0;
  byte_439201 = 0;
  byte_427572 = 0;
  byte_42A5D8 = 1;
  byte_4393E1 = 1;
  byte_440340 = 0;
  byte_434570 = 1;
  byte_429060 = 0;
  byte_427564 = 0;
  v29 = 0;
  v30 = 0;
  v3 = 0;
  v32 = 1;
  byte_438A40 = 0;
  for ( mm = 2; mm < argc; ++mm )
  {
    strcat(byte_43B360, &byte_424600[129 * mm - 258]);
    strcat(byte_43B360, asc_4208C8);
  }
  if ( strstr(byte_43B360, aNr_0) )
    byte_42A048 = 1;
  if ( strstr(byte_43B360, aL1_0) )
    byte_43934C = 1;
  if ( strstr(byte_43B360, aL2_0) )
    byte_440340 = 1;
  if ( strstr(byte_43B360, aL3_0) )
    byte_434570 = 0;
  if ( strstr(byte_43B360, aP_0) )
    byte_428D3F = 1;
  if ( strstr(byte_43B360, aNs_0) )
    byte_439201 = 1;
  if ( strstr(byte_43B360, aLc) )
    byte_427572 = 1;
  if ( strstr(byte_43B360, aG) )
    byte_42A5D8 = 0;
  if ( strstr(byte_43B360, aC) )
    byte_4393E1 = 0;
  if ( strstr(byte_43B360, aF0) )
    byte_434780 = 0;
  if ( strstr(byte_43B360, aF15_0) )
    byte_434780 = 1;
  if ( strstr(byte_43B360, aFs0_0) )
    byte_4393E2 = 1;
  if ( strstr(byte_43B360, aPr_0) )
    byte_429060 = 1;
  if ( strstr(byte_43B360, aNcross_0) )
    byte_438A40 = 1;
  if ( strstr(byte_43B360, aFc) )
    byte_427564 = 1;
  v26 = strstr(byte_43B360, aFo);
  if ( v26 )
    v29 = 1;
  v7 = strstr(byte_43B360, aFl);
  if ( v7 )
    v30 = 1;
  v24 = strstr(byte_43B360, aFr);
  if ( v24 )
    v3 = 1;
  v34 = strstr(byte_43B360, aFp);
  if ( v34 )
  {
    v32 = 0;
    byte_434570 = 0;
  }
  if ( strstr(byte_43B360, a0) )
    byte_439202 = 1;
  if ( strstr(byte_43B360, a30) )
    byte_438620 = 1;
  if ( byte_438620 == byte_439202 )
    goto LABEL_19;
  _searchenv(aMcompiExe, aPath, byte_440400);
  v35 = strrchr(byte_440400, 92);
  if ( v35 )
    v35[1] = 0;
  else
    strcpy(byte_440400, asc_42096C);
  byte_4251E0 = 0;
  if ( byte_42A048 == 1 )
    byte_42A048 = -1;
  else
    byte_42A048 = 0;
  if ( byte_43934C )
    byte_43934C = -1;
  else
    byte_43934C = 0;
  if ( byte_440340 )
  {
    byte_427564 = -1;
    byte_440340 = -1;
  }
  else
  {
    byte_440340 = 0;
    if ( byte_427564 == 1 )
      byte_427564 = 0;
    else
      byte_427564 = -1;
  }
  if ( byte_434570 )
    byte_434570 = -1;
  else
    byte_434570 = 0;
  if ( byte_428D3F == 1 )
    byte_428D3F = -1;
  else
    byte_428D3F = 0;
  if ( byte_439201 == 1 )
    byte_4251EC = 0;
  else
    byte_4251EC = -1;
  if ( byte_427572 == 1 )
    byte_4251F0 = -1;
  else
    byte_4251F0 = 0;
  if ( byte_42A5D8 == 1 )
    byte_4251F4 = -1;
  else
    byte_4251F4 = 0;
  if ( byte_4393E1 == 1 )
    byte_4251F8 = 0;
  else
    byte_4251F8 = -1;
  if ( byte_438A40 == 1 )
    byte_438A40 = 0;
  else
    byte_438A40 = -1;
  if ( byte_434780 == 1 )
    byte_434780 = 0;
  else
    byte_434780 = -1;
  if ( byte_429060 )
    byte_429060 = -1;
  else
    byte_429060 = 0;
  if ( byte_439202 )
    byte_439202 = -1;
  else
    byte_439202 = 0;
  if ( byte_438620 )
    byte_438620 = -1;
  else
    byte_438620 = 0;
  if ( v29 == 1 )
  {
    v27 = v26 + 3;
    for ( nn = 0; ; ++nn )
    {
      if ( nn >= 128 )
        goto LABEL_155;
      *(&byte_4244F0 + nn) = *v27;
      if ( *(&byte_4244F0 + nn) == 32 )
        break;
      ++v27;
    }
    if ( byte_4244EF[nn] == 92 )
    {
      *(&byte_4244F0 + nn) = 0;
    }
    else
    {
      *(&byte_4244F0 + nn) = 92;
      byte_4244F1[nn] = 0;
    }
LABEL_155:
    if ( nn >= 128 )
      goto LABEL_184;
  }
  if ( v30 == 1 )
  {
    v8 = v7 + 3;
    for ( i1 = 0; ; ++i1 )
    {
      if ( i1 >= 128 )
        goto LABEL_164;
      *(&byte_4250A8 + i1) = *v8;
      if ( *(&byte_4250A8 + i1) == 32 )
        break;
      ++v8;
    }
    if ( byte_4250A7[i1] == 92 )
    {
      *(&byte_4250A8 + i1) = 0;
    }
    else
    {
      *(&byte_4250A8 + i1) = 92;
      byte_4250A9[i1] = 0;
    }
LABEL_164:
    if ( i1 >= 128 )
      goto LABEL_184;
  }
  if ( v3 == 1 )
  {
    v25 = v24 + 3;
    for ( i2 = 0; ; ++i2 )
    {
      if ( i2 >= 128 )
        goto LABEL_174;
      *(&byte_4243E0 + i2) = *v25;
      if ( *(&byte_4243E0 + i2) == 32 )
        break;
      ++v25;
    }
    if ( *(_BYTE *)(i2 + 4342751) == 92 )
    {
      *(&byte_4243E0 + i2) = 0;
    }
    else
    {
      *(&byte_4243E0 + i2) = 92;
      byte_4243E1[i2] = 0;
    }
LABEL_174:
    if ( i2 >= 128 )
      goto LABEL_184;
  }
  if ( !v32 )
  {
    v34 += 3;
    for ( i3 = 0; ; ++i3 )
    {
      if ( i3 >= 128 )
        goto LABEL_183;
      *(&byte_425130 + i3) = *v34;
      if ( *(&byte_425130 + i3) == 32 )
        break;
      ++v34;
    }
    if ( byte_42512F[i3] == 92 )
    {
      *(&byte_425130 + i3) = 0;
    }
    else
    {
      *(&byte_425130 + i3) = 92;
      byte_425131[i3] = 0;
    }
LABEL_183:
    if ( i3 >= 128 )
    {
LABEL_184:
      sub_4052AE(3);
      goto LABEL_252;
    }
  }
  Source = getenv(aMtmp);
  if ( Source )
  {
    strcpy(byte_425020, Source);
    if ( byte_42501F[strlen(byte_425020)] != 92 )
      strcat(byte_425020, asc_420978);
    strcpy(byte_424F98, byte_425020);
    strcat(byte_424F98, aPp);
  }
  else
  {
    strcpy(byte_424F98, aPp_0);
  }
  dword_445EA0 = fopen(byte_424F98, aW_0);
  if ( !dword_445EA0 )
  {
    sub_4052AE(6);
    goto LABEL_252;
  }
  if ( !strchr(Str, 64) )
  {
    if ( !strchr(Str, 46) )
      strcat(Str, aSrc);
    v37[0] = 0;
    if ( strchr(Str, 92) )
    {
      for ( i4 = 0; Str[i4]; ++i4 )
        v37[i4] = Str[i4];
      for ( i5 = i4 - 1; Str[i5] != 92; --i5 )
        ;
      v37[i5 + 1] = 0;
    }
    v4 = 0;
    hFindFile = (HANDLE)_findfirst(Str, (int)&dword_4457A0);
    if ( hFindFile == (HANDLE)-1 )
    {
      v28 = 1;
      fclose(dword_445EA0);
      goto LABEL_250;
    }
    while ( 1 )
    {
      if ( (dword_4457A0 & 0x16) == 0 )
      {
        if ( ++v4 > 500 )
        {
          v28 = 4;
          fclose(dword_445EA0);
          goto LABEL_250;
        }
        strcpy(Destination, v37);
        strcat(Destination, byte_4457B4);
        fprintf(dword_445EA0, "%s\n", Destination);
        if ( (dword_445EA0->_flag & 0x20) != 0 )
          goto LABEL_216;
      }
      if ( _findnext(hFindFile, (int)&dword_4457A0) )
        goto LABEL_213;
    }
  }
  v28 = sub_405005(Str);
  if ( v28 )
    goto LABEL_250;
LABEL_213:
  if ( !fclose(dword_445EA0) )
  {
    v28 = _setjmp3(Buf, 0, v3, v4, (char)Source);
    if ( !v28 )
    {
      dword_445EA0 = fopen(byte_424F98, aR_0);
      if ( !dword_445EA0 )
        goto LABEL_216;
      dword_4458B8 = 0;
      while ( fgets(Buffer, 129, dword_445EA0) )
      {
        for ( i6 = 0; Buffer[i6] != 10; ++i6 )
          FullPath[i6] = Buffer[i6];
        FullPath[i6] = 0;
        _splitpath(FullPath, Drive, Dir, byte_434680, Ext);
        strcpy(byte_439180, FullPath);
        sub_4107BD(byte_439220, byte_434680, Ext);
        strcpy(byte_434220, byte_425020);
        strcat(byte_434220, byte_434680);
        strcat(byte_434220, aTmp);
        strcpy(byte_43B480, byte_425020);
        strcat(byte_43B480, byte_434680);
        strcat(byte_43B480, aRe);
        strcpy(byte_4392C0, &byte_4244F0);
        strcat(byte_4392C0, byte_434680);
        strcat(byte_4392C0, aRel);
        strcpy(FileName, &byte_425130);
        strcat(FileName, byte_434680);
        strcat(FileName, aPrg);
        strcpy(byte_429EE0, &byte_4243E0);
        strcat(byte_429EE0, byte_434680);
        strcat(byte_429EE0, aRef);
        strcpy(byte_439360, &byte_4250A8);
        strcat(byte_439360, byte_434680);
        strcat(byte_439360, aLst);
        dword_445900 = 0;
        word_445E9A = 0;
        v28 = sub_40E930();
        if ( !v28 )
          v28 = sub_401FF0();
        if ( dword_445900 )
          ++dword_4458B8;
        if ( (v28 == 13 || !v28) && !dword_445900 && !byte_429060 && !byte_434570 )
        {
          remove(FileName);
          sprintf(Command, "copy %s %s > NUL", byte_434220, FileName);
          if ( system(Command) == -1 )
          {
            remove(byte_434220);
            v28 = 21;
            goto LABEL_250;
          }
        }
        remove(byte_434220);
        if ( (v28 == 13 || !v28) && !dword_445900 && !byte_42A048 )
        {
          remove(byte_4392C0);
          sprintf(Command, "copy %s %s > NUL", byte_43B480, byte_4392C0);
          if ( system(Command) == -1 )
          {
            remove(byte_43B480);
            v28 = 20;
            goto LABEL_250;
          }
        }
        remove(byte_43B480);
        if ( v28 == 13 || v28 == 99 )
        {
          sub_4052AE(13);
          v28 = 0;
        }
        if ( v28 )
          goto LABEL_250;
        if ( dword_445900 && !sub_40546B() )
        {
          v28 = 22;
          goto LABEL_250;
        }
      }
      if ( !dword_4458B8 )
      {
        fclose(dword_445EA0);
        remove(byte_424F98);
        printf("Macro Compiler Normal End\n");
        exit(0);
      }
      v28 = -1;
LABEL_250:
      fclose(dword_445EA0);
      remove(byte_424F98);
    }
    sub_4052AE(v28);
LABEL_252:
    printf("Macro Compiler Error End\n");
    exit(-1);
  }
LABEL_216:
  sub_4052AE(6);
  goto LABEL_252;
}
// 404AEB: variable 'v4' is possibly undefined
// 401FF0: using guessed type int sub_401FF0(void);
// 404FBF: using guessed type _DWORD __cdecl sub_404FBF(_DWORD, _DWORD);
// 4052AE: using guessed type _DWORD __cdecl sub_4052AE(_DWORD);
// 40546B: using guessed type int sub_40546B(void);
// 40E930: using guessed type int sub_40E930(void);
// 4107BD: using guessed type _DWORD __cdecl sub_4107BD(_DWORD, _DWORD, _DWORD);
// 410D70: using guessed type int sub_410D70(void);
// 412730: using guessed type _DWORD __cdecl _setjmp3(_DWORD, _DWORD, _DWORD, _DWORD, char);
// 4251E0: using guessed type char byte_4251E0;
// 4251EC: using guessed type char byte_4251EC;
// 4251F0: using guessed type char byte_4251F0;
// 4251F4: using guessed type char byte_4251F4;
// 4251F8: using guessed type char byte_4251F8;
// 427564: using guessed type char byte_427564;
// 427572: using guessed type char byte_427572;
// 428D3F: using guessed type char byte_428D3F;
// 429060: using guessed type char byte_429060;
// 42A048: using guessed type char byte_42A048;
// 42A5D8: using guessed type char byte_42A5D8;
// 434570: using guessed type char byte_434570;
// 434780: using guessed type char byte_434780;
// 438620: using guessed type char byte_438620;
// 438A40: using guessed type char byte_438A40;
// 439201: using guessed type char byte_439201;
// 439202: using guessed type char byte_439202;
// 43934C: using guessed type char byte_43934C;
// 4393E1: using guessed type char byte_4393E1;
// 4393E2: using guessed type char byte_4393E2;
// 440340: using guessed type char byte_440340;
// 4457A0: using guessed type int dword_4457A0;
// 4458B8: using guessed type int dword_4458B8;
// 445900: using guessed type int dword_445900;
// 445E9A: using guessed type __int16 word_445E9A;
// 4038C0: using guessed type char Buffer[132];

//----- (00404FBF) --------------------------------------------------------
_BYTE *__cdecl sub_404FBF(_BYTE *a1, _BYTE *a2)
{
  _BYTE *result; // eax
  int v3; // [esp-4h] [ebp-8h]

  while ( *a1 )
  {
    v3 = (char)*a1++;
    *a2++ = sub_4111A0(v3);
  }
  result = a2;
  *a2 = 0;
  return result;
}

//----- (00405005) --------------------------------------------------------
int __cdecl sub_405005(char *Str)
{
  char Destination[80]; // [esp+0h] [ebp-A4h] BYREF
  char Buffer[80]; // [esp+50h] [ebp-54h] BYREF
  char *v4; // [esp+A0h] [ebp-4h]

  sub_40517C(Str, (int)byte_4342C0);
  strcat(byte_4342C0, aLnk);
  dword_445EA4 = fopen(byte_4342C0, aR_1);
  if ( !dword_445EA4 )
    return 5;
  while ( fgets(Buffer, 80, dword_445EA4) )
  {
    if ( !_strnicmp(Buffer, aFile, 4u) )
    {
      v4 = strchr(Buffer, 61);
      if ( v4 )
      {
        v4 = sub_40526F(v4);
        while ( 1 )
        {
          v4 = sub_4051E4(v4, Destination);
          if ( !Destination[0] )
            break;
          if ( !strchr(Destination, 46) )
            strcat(Destination, aSrc_0);
          if ( _access(Destination, 0) == -1 )
          {
            fclose(dword_445EA4);
            return 1;
          }
          strcat(Destination, asc_420A4C);
          fputs(Destination, dword_445EA0);
        }
      }
    }
  }
  fclose(dword_445EA4);
  return 0;
}

//----- (0040517C) --------------------------------------------------------
size_t __cdecl sub_40517C(char *Str, int a2)
{
  size_t result; // eax
  int v3; // [esp+0h] [ebp-8h]
  unsigned int i; // [esp+4h] [ebp-4h]

  v3 = 0;
  for ( i = 0; ; ++i )
  {
    result = strlen(Str);
    if ( i >= result )
      break;
    if ( Str[i] != 64 )
    {
      *(_BYTE *)(v3 + a2) = Str[i];
      ++v3;
    }
  }
  *(_BYTE *)(v3 + a2) = 0;
  return result;
}

//----- (004051E4) --------------------------------------------------------
_BYTE *__cdecl sub_4051E4(_BYTE *a1, _BYTE *a2)
{
  _BYTE *i; // [esp+0h] [ebp-4h]

  for ( i = sub_40526F(a1); *i != 32 && *i != 9 && *i != 44 && *i && *i != 10 && *i != 47 && i[1] != 42; ++i )
    *a2++ = *i;
  *a2 = 0;
  return i;
}

//----- (0040526F) --------------------------------------------------------
_BYTE *__cdecl sub_40526F(_BYTE *a1)
{
  while ( *a1 == 32 || *a1 == 9 || *a1 == 44 || *a1 == 61 )
    ++a1;
  return a1;
}

//----- (004052AE) --------------------------------------------------------
int __cdecl sub_4052AE(int a1)
{
  int result; // eax

  if ( a1 != 13 )
    ++dword_445900;
  result = a1 - 1;
  switch ( a1 )
  {
    case 1:
      result = printf("source file not found.\n");
      break;
    case 2:
      result = printf("file name error.\n");
      break;
    case 3:
      result = printf("parameters error.\n");
      break;
    case 4:
      result = printf("too many sorce files.\n");
      break;
    case 5:
      result = printf("link file not found.\n");
      break;
    case 6:
      result = printf("program name work file access error.\n");
      break;
    case 7:
      result = printf("can't open src_f.$$$ file.\n");
      break;
    case 8:
      result = printf("xxxxxx.SRC file access error.\n");
      break;
    case 9:
      result = printf("xxxxxx.LST file access error.\n");
      break;
    case 10:
      result = printf("xxxxxx.REL file access error.\n");
      break;
    case 11:
      result = printf("can not open error.doc!\n");
      break;
    case 12:
      result = printf("source file program number over!!\n");
      break;
    case 20:
      result = printf("xxxxxx.REL is not builded.\n");
      break;
    case 21:
      result = printf("xxxxxx.PRG is not builded.\n");
      break;
    case 22:
      result = printf("xxxxxx.REF is not builded.\n");
      break;
    case 23:
      printf("usage: mcompi [SRC File] [-0/-30]\n");
      printf("       -0  : Macro compile for FS0i-D\n");
      result = printf("       -30 : Macro compile for FS30i\n");
      break;
    default:
      return result;
  }
  return result;
}
// 445900: using guessed type int dword_445900;

//----- (0040546B) --------------------------------------------------------
int sub_40546B()
{
  int v1; // [esp+0h] [ebp-210h]
  char Destination[8]; // [esp+4h] [ebp-20Ch] BYREF
  char v3[4]; // [esp+Ch] [ebp-204h] BYREF
  char Source[5]; // [esp+10h] [ebp-200h] BYREF
  char Str1[247]; // [esp+15h] [ebp-1FBh] BYREF
  char Buffer[256]; // [esp+10Ch] [ebp-104h] BYREF
  int v7; // [esp+20Ch] [ebp-4h]

  v1 = 0;
  if ( (unsigned __int8)byte_440340 == 255 || (unsigned __int8)byte_43934C == 255 )
    return -1;
  dword_445EAC = fopen(byte_439360, aR_2);
  if ( !dword_445EAC )
    return -2;
  dword_445EB0 = fopen(byte_429EE0, aR_3);
  if ( dword_445EB0 )
  {
    dword_445EB8 = fopen(byte_434220, aW_1);
    if ( dword_445EB8 )
    {
      if ( !fgets(Buffer, 256, dword_445EAC) )
        v1 = -3;
      while ( !v1 )
      {
        strcpy(v3, Buffer);
        v1 = fgets(Buffer, 256, dword_445EAC) == 0;
        if ( !strncmp(Buffer, &byte_420C78, 1u) )
        {
          if ( !fgets(Buffer, 256, dword_445EAC) )
            v1 = 1;
          if ( !fgets(Buffer, 256, dword_445EAC) )
            v1 = 1;
          if ( !fgets(Buffer, 256, dword_445EAC) )
            v1 = 1;
          if ( !fgets(Buffer, 256, dword_445EAC) )
            v1 = 1;
        }
        if ( !strncmp(Buffer, aError, 5u) )
        {
          strncpy(Destination, Source, 4u);
          v7 = 0;
          while ( !v1 && !v7 )
          {
            if ( !fgets(v3, 256, dword_445EB0) )
              v1 = -4;
            if ( fputs(v3, dword_445EB8) )
              v1 = -5;
            if ( !strncmp(Str1, Destination, 4u) )
            {
              if ( fputs(Buffer, dword_445EB8) )
                v1 = -5;
              fgets(v3, 256, dword_445EAC);
              if ( !strncmp(v3, &byte_420C84, 1u) )
              {
                fgets(v3, 256, dword_445EAC);
                fgets(v3, 256, dword_445EAC);
                fgets(v3, 256, dword_445EAC);
                fgets(v3, 256, dword_445EAC);
              }
              if ( fputs(v3, dword_445EB8) )
                v1 = -5;
              if ( !fgets(Buffer, 256, dword_445EAC) )
                v1 = 1;
              v7 = 1;
            }
          }
        }
      }
      if ( v1 == 1 )
      {
        v1 = 0;
        while ( !v1 )
        {
          if ( fgets(v3, 256, dword_445EB0) )
          {
            if ( fputs(v3, dword_445EB8) )
              v1 = -5;
          }
          else
          {
            v1 = 1;
          }
        }
      }
      fclose(dword_445EAC);
      fclose(dword_445EB0);
      fclose(dword_445EB8);
      sprintf(byte_424578, "copy %s %s > NUL", byte_434220, byte_429EE0);
      if ( system(byte_424578) == -1 )
        v1 = 0;
      remove(byte_434220);
      return v1;
    }
    else
    {
      fclose(dword_445EAC);
      fclose(dword_445EB0);
      return -2;
    }
  }
  else
  {
    fclose(dword_445EAC);
    return -2;
  }
}
// 43934C: using guessed type char byte_43934C;
// 440340: using guessed type char byte_440340;
// 40546B: using guessed type char var_204[4];
// 40546B: using guessed type char Source[5];
// 40546B: using guessed type char Str1[247];

//----- (00405950) --------------------------------------------------------
char sub_405950()
{
  char v1; // [esp+0h] [ebp-4h]

  v1 = 0;
  if ( (unsigned __int8)++byte_4252C8 > 5u )
  {
    word_425208 = 4609;
    return -1;
  }
  return v1;
}
// 425208: using guessed type __int16 word_425208;
// 4252C8: using guessed type char byte_4252C8;

//----- (00405985) --------------------------------------------------------
char sub_405985()
{
  --byte_4252C8;
  return 0;
}
// 4252C8: using guessed type char byte_4252C8;

//----- (004059A0) --------------------------------------------------------
char sub_4059A0()
{
  char v1; // [esp+8h] [ebp-4h]

  v1 = sub_405950();
  if ( !v1 )
  {
    v1 = sub_40A65D();
    if ( !v1 )
    {
      sub_40626B();
      if ( (unsigned __int8)byte_4252D8 == 131 )
      {
        v1 = sub_407BA9(2, 0);
        if ( !v1 )
          return sub_405985();
      }
      else
      {
        v1 = -1;
        if ( word_4252E2 )
        {
          word_425208 = 4619;
          word_4252E2 = 0;
        }
        if ( word_425208 != 4619 )
          word_425208 = 4610;
      }
    }
  }
  return v1;
}
// 425208: using guessed type __int16 word_425208;
// 4252D8: using guessed type char byte_4252D8;
// 4252E2: using guessed type __int16 word_4252E2;

//----- (00405A5A) --------------------------------------------------------
char sub_405A5A()
{
  char v1; // [esp+0h] [ebp-4h]
  char v2; // [esp+0h] [ebp-4h]

  v1 = sub_405950();
  if ( !v1 )
  {
    v1 = sub_40A65D();
    if ( !v1 )
    {
      v2 = sub_40626B();
      if ( (unsigned __int8)byte_4252D8 != 131 || v2 )
      {
        word_425208 = 4611;
        return -1;
      }
      else
      {
        return sub_405985();
      }
    }
  }
  return v1;
}
// 40626B: using guessed type int sub_40626B(void);
// 425208: using guessed type __int16 word_425208;
// 4252D8: using guessed type char byte_4252D8;

//----- (00405AC0) --------------------------------------------------------
char __cdecl sub_405AC0(char a1, _DWORD *a2)
{
  int v3; // [esp+0h] [ebp-4h]

  LOBYTE(v3) = sub_40626B(0);
  if ( a1 == 5 && !(_BYTE)v3 )
  {
    if ( (unsigned __int8)byte_4252D8 == 131 )
    {
      LOBYTE(v3) = sub_40A65D();
      if ( !(_BYTE)v3 )
      {
        if ( byte_4252D8 == 5 && byte_4252D9 == 1 )
        {
          LOBYTE(v3) = sub_40A65D();
          if ( !(_BYTE)v3 )
          {
            if ( (unsigned __int8)byte_4252D8 == 130 )
            {
              LOBYTE(v3) = sub_40A65D();
              if ( !(_BYTE)v3 )
                LOBYTE(v3) = sub_40626B(v3);
            }
            else
            {
              word_425208 = 4612;
              LOBYTE(v3) = -1;
            }
          }
        }
        else
        {
          *a2 = 1;
        }
      }
    }
    else if ( (unsigned __int8)byte_4252D8 == 133 )
    {
      LOBYTE(v3) = sub_40A65D();
      if ( !(_BYTE)v3 )
        LOBYTE(v3) = sub_40626B(v3);
    }
    else
    {
      word_425208 = 4614;
      LOBYTE(v3) = -1;
    }
  }
  if ( a1 == 16 && !(_BYTE)v3 )
  {
    if ( (unsigned __int8)byte_4252D8 == 133 )
    {
      LOBYTE(v3) = sub_40A65D();
      if ( !(_BYTE)v3 )
        LOBYTE(v3) = sub_40626B(v3);
    }
    else
    {
      word_425208 = 5132;
      LOBYTE(v3) = -1;
    }
  }
  if ( a1 == 18 && !(_BYTE)v3 )
  {
    if ( (unsigned __int8)byte_4252D8 == 131 )
    {
      LOBYTE(v3) = sub_40A65D();
      if ( !(_BYTE)v3 )
      {
        if ( byte_4252D8 == 5 && byte_4252D9 == 1 )
        {
          LOBYTE(v3) = sub_40A65D();
          if ( !(_BYTE)v3 )
          {
            if ( (unsigned __int8)byte_4252D8 == 130 )
            {
              LOBYTE(v3) = sub_40A65D();
              if ( !(_BYTE)v3 )
              {
                LOBYTE(v3) = sub_40626B(v3);
                *a2 = 2;
              }
            }
            else
            {
              word_425208 = 5132;
              LOBYTE(v3) = -1;
            }
          }
        }
        else
        {
          *a2 = 0;
        }
      }
    }
    else if ( (unsigned __int8)byte_4252D8 == 133 )
    {
      LOBYTE(v3) = sub_40A65D();
      if ( !(_BYTE)v3 )
      {
        sub_40626B(v3);
        *a2 = 1;
        LOBYTE(v3) = sub_40A65D();
        if ( byte_4252D8 == 5 && byte_4252D9 == 1 )
        {
          LOBYTE(v3) = sub_40A65D();
          if ( !(_BYTE)v3 )
          {
            if ( (unsigned __int8)byte_4252D8 == 130 )
            {
              LOBYTE(v3) = sub_40A65D();
              if ( !(_BYTE)v3 )
              {
                LOBYTE(v3) = sub_40626B(v3);
                *a2 = 3;
              }
            }
            else
            {
              word_425208 = 5132;
              LOBYTE(v3) = -1;
            }
          }
        }
      }
    }
    else
    {
      word_425208 = 5132;
      LOBYTE(v3) = -1;
    }
  }
  return v3;
}
// 405B57: variable 'v3' is possibly undefined
// 40626B: using guessed type int __cdecl sub_40626B(_DWORD);
// 425208: using guessed type __int16 word_425208;
// 4252D8: using guessed type char byte_4252D8;
// 4252D9: using guessed type char byte_4252D9;

//----- (00405D73) --------------------------------------------------------
char __cdecl sub_405D73(char a1, _DWORD *a2)
{
  char v3; // [esp+4h] [ebp-4h]

  v3 = sub_405950();
  if ( !v3 )
  {
    v3 = sub_40A65D();
    if ( !v3 )
    {
      v3 = sub_405AC0(a1, a2);
      if ( !v3 )
      {
        if ( a1 == 18 )
        {
          v3 = sub_407BA9(6, *(_BYTE *)a2 + 18);
        }
        else if ( a1 == 5 && *a2 )
        {
          v3 = sub_407BA9(6, 0x11u);
        }
        else if ( (unsigned __int8)byte_4252D8 == 131 )
        {
          v3 = sub_407BA9(6, a1);
        }
        else
        {
          word_425208 = 4615;
          v3 = -1;
        }
        if ( !v3 )
          return sub_405985();
      }
    }
  }
  return v3;
}
// 425208: using guessed type __int16 word_425208;
// 4252D8: using guessed type char byte_4252D8;

//----- (00405E67) --------------------------------------------------------
char sub_405E67()
{
  switch ( byte_4252D8 )
  {
    case 0:
      return sub_407BA9(0, byte_4252D9);
    case 2:
      return sub_4059A0();
    case -126:
      return sub_405A5A();
  }
  word_425208 = 4618;
  return -1;
}
// 425208: using guessed type __int16 word_425208;
// 4252D8: using guessed type char byte_4252D8;
// 4252D9: using guessed type char byte_4252D9;

//----- (00405ED7) --------------------------------------------------------
char sub_405ED7()
{
  char v1; // [esp+0h] [ebp-4h]
  char v2; // [esp+0h] [ebp-4h]

  v1 = 0;
  v2 = sub_405E67(v1);
  if ( !v2 )
    return sub_40A836();
  return v2;
}
// 405E67: using guessed type int __cdecl sub_405E67(_DWORD);

//----- (00405EFE) --------------------------------------------------------
char __cdecl sub_405EFE(unsigned __int8 a1)
{
  char v2; // [esp+0h] [ebp-8h]
  char v3; // [esp+4h] [ebp-4h]

  v3 = sub_40A836();
  if ( !v3 )
  {
    v3 = sub_405ED7();
    if ( !v3 )
    {
      if ( (unsigned __int8)byte_4252D8 == 132 )
      {
        v3 = sub_40A836();
        if ( !v3 )
        {
          v3 = sub_405ED7();
          if ( !v3 )
            v2 = 8;
        }
      }
      else
      {
        v2 = 7;
      }
      if ( !v3 )
        return sub_407BA9(v2, a1);
    }
  }
  return v3;
}
// 405F72: variable 'v2' is possibly undefined
// 4252D8: using guessed type char byte_4252D8;

//----- (00405F84) --------------------------------------------------------
char sub_405F84()
{
  char v1; // [esp+4h] [ebp-10h]
  char v2; // [esp+8h] [ebp-Ch]
  char v3; // [esp+Ch] [ebp-8h]
  unsigned int v4; // [esp+10h] [ebp-4h] BYREF

  v2 = 0;
  v1 = 0;
  v4 = 0;
  switch ( byte_4252D8 )
  {
    case 0:
      v2 = 0;
      v1 = byte_4252D9;
      v3 = sub_407BA9(0, byte_4252D9);
      break;
    case 2:
      v3 = sub_4059A0((unsigned __int8)byte_4252D8);
      break;
    case 6:
      v2 = 6;
      v1 = byte_4252D9;
      v3 = sub_405D73(byte_4252D9, &v4);
      break;
    case 14:
      v2 = 14;
      v1 = byte_4252D9;
      v3 = sub_405EFE(byte_4252D9);
      break;
    case -126:
      v3 = sub_405A5A();
      break;
    default:
      word_425208 = 4616;
      v3 = -1;
      break;
  }
  if ( !v3 && v2 != 14 && (v2 != 6 || v1 != 5 || !v4) && (v2 != 6 || v1 != 18 || v4 >= 2) )
    return sub_40A65D();
  return v3;
}
// 4059A0: using guessed type int __cdecl sub_4059A0(_DWORD);
// 425208: using guessed type __int16 word_425208;
// 4252D8: using guessed type char byte_4252D8;
// 4252D9: using guessed type char byte_4252D9;

//----- (00406150) --------------------------------------------------------
char sub_406150()
{
  char v1; // [esp+8h] [ebp-4h]

  if ( byte_4252D8 || byte_4252D9 != 1 )
  {
    if ( byte_4252D8 == 2 )
    {
      v1 = sub_4059A0();
    }
    else
    {
      word_425208 = 4617;
      v1 = -1;
    }
  }
  else
  {
    v1 = sub_407BA9(0, byte_4252D9);
  }
  if ( !v1 )
    return sub_40A65D();
  return v1;
}
// 425208: using guessed type __int16 word_425208;
// 4252D8: using guessed type char byte_4252D8;
// 4252D9: using guessed type char byte_4252D9;

//----- (004061CF) --------------------------------------------------------
char sub_4061CF()
{
  char v1; // [esp+0h] [ebp-4h]

  v1 = sub_405E67();
  if ( !v1 )
    return sub_40A65D();
  return v1;
}

//----- (004061F6) --------------------------------------------------------
char sub_4061F6()
{
  unsigned __int8 v1; // [esp+4h] [ebp-Ch]
  char v2; // [esp+Ch] [ebp-4h]

  v2 = sub_405F84();
  while ( byte_4252D8 == 5 && !v2 )
  {
    v1 = byte_4252D9;
    v2 = sub_40A65D();
    if ( !v2 )
    {
      v2 = sub_405F84();
      if ( !v2 )
        v2 = sub_407BA9(5, v1);
    }
  }
  return v2;
}
// 4252D8: using guessed type char byte_4252D8;
// 4252D9: using guessed type char byte_4252D9;

//----- (0040626B) --------------------------------------------------------
char sub_40626B()
{
  char v1; // [esp+4h] [ebp-Ch]
  unsigned __int8 v2; // [esp+4h] [ebp-Ch]
  char v3; // [esp+Ch] [ebp-4h]

  if ( byte_4252D8 == 4 && (!byte_4252D9 || byte_4252D9 == 1) )
  {
    v1 = byte_4252D9;
    v3 = sub_40A65D();
    if ( !v3 )
    {
      v3 = sub_4061F6();
      if ( !v3 && v1 == 1 )
        v3 = sub_407BA9(3, 0);
    }
  }
  else
  {
    v3 = sub_4061F6();
  }
  while ( byte_4252D8 == 4 && !v3 )
  {
    v2 = byte_4252D9;
    v3 = sub_40A65D();
    if ( !v3 )
    {
      v3 = sub_4061F6();
      if ( !v3 )
        v3 = sub_407BA9(4, v2);
    }
  }
  return v3;
}
// 4252D8: using guessed type char byte_4252D8;
// 4252D9: using guessed type char byte_4252D9;

//----- (00406357) --------------------------------------------------------
char sub_406357()
{
  char v1; // [esp+4h] [ebp-Ch]
  char v2; // [esp+Ch] [ebp-4h]

  if ( byte_4252D8 != 4 || byte_4252D9 && byte_4252D9 != 1 )
    return sub_4061CF();
  v1 = byte_4252D9;
  v2 = sub_40A65D();
  if ( !v2 )
  {
    v2 = sub_4061CF();
    if ( !v2 )
    {
      if ( v1 )
        return sub_407BA9(3, 0);
    }
  }
  return v2;
}
// 4252D8: using guessed type char byte_4252D8;
// 4252D9: using guessed type char byte_4252D9;

//----- (004063F0) --------------------------------------------------------
char sub_4063F0()
{
  byte_425344 = 0;
  byte_425348 = 0;
  return 0;
}
// 425344: using guessed type char byte_425344;
// 425348: using guessed type char byte_425348;

//----- (0040640D) --------------------------------------------------------
char sub_40640D()
{
  char v1; // [esp+0h] [ebp-4h]

  v1 = 0;
  sub_40AEB0();
  byte_4252F4 = 0;
  byte_425304 = -1;
  byte_42530C = 0;
  byte_42533C = 0;
  byte_425340 = 0;
  if ( !byte_4251F4 )
    v1 = sub_4063F0();
  word_4252FC = 0;
  return v1;
}
// 4251F4: using guessed type char byte_4251F4;
// 4252F4: using guessed type char byte_4252F4;
// 4252FC: using guessed type __int16 word_4252FC;
// 425304: using guessed type char byte_425304;
// 42530C: using guessed type char byte_42530C;
// 42533C: using guessed type char byte_42533C;
// 425340: using guessed type char byte_425340;

//----- (00406460) --------------------------------------------------------
char sub_406460()
{
  byte_425304 = -1;
  byte_42530C = 0;
  byte_42533C = 0;
  byte_425340 = 0;
  word_4252FC = 0;
  return 0;
}
// 4252FC: using guessed type __int16 word_4252FC;
// 425304: using guessed type char byte_425304;
// 42530C: using guessed type char byte_42530C;
// 42533C: using guessed type char byte_42533C;
// 425340: using guessed type char byte_425340;

//----- (0040648C) --------------------------------------------------------
char __cdecl sub_40648C(char a1)
{
  char v2; // [esp+0h] [ebp-4h]

  if ( !word_427570 || dword_425398 )
  {
    v2 = sub_40292E(a1);
    if ( !v2 )
    {
      ++dword_4252EC;
      if ( byte_425204 == 2 )
        ++dword_4252F0;
    }
    return v2;
  }
  else
  {
    word_427570 = 0;
    return 0;
  }
}
// 425204: using guessed type char byte_425204;
// 4252EC: using guessed type int dword_4252EC;
// 4252F0: using guessed type int dword_4252F0;
// 425398: using guessed type int dword_425398;
// 427570: using guessed type __int16 word_427570;

//----- (00406503) --------------------------------------------------------
char __cdecl sub_406503(_BYTE *a1)
{
  char v2; // [esp+0h] [ebp-4h]

  v2 = 0;
  if ( *a1 == 27 )
    return sub_406A6A((int)a1);
  if ( *a1 != 64 )
  {
    v2 = sub_406578((int)a1);
    if ( !v2 )
    {
      v2 = sub_4067B6(a1);
      if ( !v2 )
        return sub_406879(a1);
    }
  }
  return v2;
}

//----- (00406578) --------------------------------------------------------
char __cdecl sub_406578(int a1)
{
  char v2; // [esp+0h] [ebp-Ch]
  char v3[4]; // [esp+4h] [ebp-8h] BYREF
  int v4; // [esp+8h] [ebp-4h]

  LOBYTE(v4) = *(_BYTE *)a1 & 0x1F;
  byte_425330 = v4;
  if ( byte_425308 )
  {
    if ( (unsigned __int8)v4 == 28 )
      byte_425332 = byte_429380[(unsigned __int8)byte_425354++];
  }
  else if ( (*(_BYTE *)a1 & 0x20) != 0 )
  {
    byte_425330 = 24;
    byte_425331 = v4;
    if ( (unsigned __int8)byte_4252B4 == 255 && (unsigned __int8)v4 == 8 )
    {
      byte_425331 = 9;
      byte_425332 = byte_4252B8;
    }
  }
  else if ( *(_BYTE *)a1 == 28 || *(_BYTE *)a1 == 25 || *(_BYTE *)a1 == 26 )
  {
    byte_425332 = byte_42534C;
  }
  v2 = sub_4066E9(a1, v3);
  if ( !v2 )
  {
    byte_425333 = v3[0];
    byte_425330 |= v3[0];
    dword_425334 = *(_DWORD *)(a1 + 2);
    if ( *(_BYTE *)(a1 + 1) != 64 )
      *(_BYTE *)(a1 + 7) = 0;
    if ( *(unsigned __int8 *)(a1 + 7) != 255 )
    {
      byte_425330 |= 0x80u;
      byte_425338 = *(_BYTE *)(a1 + 7) | *(_BYTE *)(a1 + 1);
    }
  }
  return v2;
}
// 4252B4: using guessed type char byte_4252B4;
// 4252B8: using guessed type char byte_4252B8;
// 425308: using guessed type char byte_425308;
// 425330: using guessed type char byte_425330;
// 425331: using guessed type char byte_425331;
// 425332: using guessed type char byte_425332;
// 425333: using guessed type char byte_425333;
// 425334: using guessed type int dword_425334;
// 425338: using guessed type char byte_425338;
// 42534C: using guessed type char byte_42534C;
// 425354: using guessed type char byte_425354;
// 406578: using guessed type char var_8[4];

//----- (004066E9) --------------------------------------------------------
char __cdecl sub_4066E9(int a1, _BYTE *a2)
{
  char v3; // [esp+0h] [ebp-4h]

  v3 = 0;
  if ( *(_BYTE *)(a1 + 1) == 79 )
  {
    *(_BYTE *)(a1 + 1) = 64;
    *(_BYTE *)(a1 + 7) = -1;
    if ( byte_4251F0 )
    {
      *a2 = 96;
    }
    else if ( *(_DWORD *)(a1 + 2) > 0xFFFFu )
    {
      word_425208 = 5634;
      return -1;
    }
    else
    {
      *a2 = 64;
    }
  }
  else if ( (*(_BYTE *)(a1 + 1) & 0x20) == 0 && *(_BYTE *)(a1 + 6) )
  {
    if ( *(int *)(a1 + 2) < -128 || *(int *)(a1 + 2) > 127 )
    {
      if ( *(int *)(a1 + 2) < -32768 || *(int *)(a1 + 2) > 0x7FFF )
        *a2 = 96;
      else
        *a2 = 64;
    }
    else
    {
      *a2 = 32;
    }
  }
  else
  {
    *a2 = 0;
  }
  return v3;
}
// 4251F0: using guessed type char byte_4251F0;
// 425208: using guessed type __int16 word_425208;

//----- (004067B6) --------------------------------------------------------
char __cdecl sub_4067B6(_BYTE *a1)
{
  unsigned __int8 v2; // [esp+0h] [ebp-8h]
  char v3; // [esp+4h] [ebp-4h]

  v3 = 0;
  if ( byte_425308 )
  {
    if ( !byte_425333 )
      --byte_4252F4;
  }
  else
  {
    if ( *a1 == 28 )
      v2 = byte_420CE8[(unsigned __int8)byte_425332];
    else
      v2 = byte_420CA8[(unsigned __int8)*a1];
    if ( v2 != 128 )
    {
      if ( byte_425333 )
        ++byte_4252F4;
      byte_4252F4 -= v2;
    }
  }
  if ( (unsigned __int8)byte_4252F4 >= 0x14u )
  {
    word_425208 = 5633;
    return -1;
  }
  return v3;
}
// 425208: using guessed type __int16 word_425208;
// 4252F4: using guessed type char byte_4252F4;
// 425308: using guessed type char byte_425308;
// 425332: using guessed type char byte_425332;
// 425333: using guessed type char byte_425333;

//----- (00406879) --------------------------------------------------------
char __cdecl sub_406879(_BYTE *a1)
{
  char v2; // [esp+0h] [ebp-Ch]
  int v3; // [esp+4h] [ebp-8h]
  int v4; // [esp+4h] [ebp-8h]
  int v5; // [esp+4h] [ebp-8h]
  char v6; // [esp+8h] [ebp-4h]

  v6 = sub_40648C(byte_425330);
  if ( !v6 )
  {
    if ( byte_425308 )
    {
      if ( (*a1 & 0x1F) == 28 )
        v6 = sub_40648C(byte_425332);
    }
    else
    {
      v2 = byte_425330 & 0x1F;
      if ( (byte_425330 & 0x1F) == 24 )
      {
        v6 = sub_40648C(byte_425331);
        if ( !v6 && byte_425331 == 9 )
          v6 = sub_40648C(byte_425332);
      }
      else if ( v2 == 25 || v2 == 28 || v2 == 26 )
      {
        v6 = sub_40648C(byte_425332);
      }
    }
    if ( !v6 )
    {
      if ( byte_425333 )
      {
        v3 = dword_425334;
        v6 = sub_40648C(dword_425334);
        if ( !v6 && byte_425333 != 32 )
        {
          v4 = v3 >> 8;
          v6 = sub_40648C(v4);
          if ( !v6 && byte_425333 != 64 )
          {
            v5 = v4 >> 8;
            v6 = sub_40648C(v5);
            if ( !v6 )
              v6 = sub_40648C(SBYTE1(v5));
          }
        }
      }
      if ( !v6 && (byte_425330 & 0x80) != 0 )
        return sub_40648C(byte_425338);
    }
  }
  return v6;
}
// 425308: using guessed type char byte_425308;
// 425330: using guessed type char byte_425330;
// 425331: using guessed type char byte_425331;
// 425332: using guessed type char byte_425332;
// 425333: using guessed type char byte_425333;
// 425334: using guessed type int dword_425334;
// 425338: using guessed type char byte_425338;

//----- (00406A6A) --------------------------------------------------------
char __cdecl sub_406A6A(int a1)
{
  char v1; // al
  __int16 v3; // [esp+4h] [ebp-Ch]
  char v4; // [esp+8h] [ebp-8h]
  __int16 v5; // [esp+Ch] [ebp-4h]

  if ( sub_40AE82() )
  {
    sub_40648C(28);
    v1 = sub_40AE99();
    sub_40648C(v1);
  }
  v4 = sub_40648C(59);
  if ( !v4 )
  {
    v4 = sub_40648C(*(_BYTE *)(a1 + 6));
    if ( !v4 )
    {
      v5 = *(unsigned __int8 *)(a1 + 7);
      v3 = *(unsigned __int8 *)(a1 + 6);
      while ( v3 > 0 && !v4 )
      {
        v4 = sub_40648C(byte_428C40[v5]);
        if ( !v4 )
        {
          ++v5;
          --v3;
        }
      }
    }
  }
  if ( sub_40AE82() )
  {
    sub_40648C(28);
    sub_40648C(80);
  }
  return v4;
}

//----- (00406B58) --------------------------------------------------------
char __cdecl sub_406B58(char a1)
{
  char v2; // [esp+0h] [ebp-4h]

  v2 = 0;
  while ( (unsigned __int8)byte_425340 < (int)(unsigned __int8)byte_42533C && !v2 )
  {
    if ( !a1 && byte_442720[8 * (unsigned __int8)byte_425340] != 29 )
      return 0;
    v2 = sub_406503((_BYTE *)(8 * (unsigned __int8)byte_425340 + 4466464));
    ++byte_425340;
  }
  byte_42533C = 0;
  byte_425340 = 0;
  return v2;
}
// 42533C: using guessed type char byte_42533C;
// 425340: using guessed type char byte_425340;

//----- (00406BE7) --------------------------------------------------------
char __cdecl sub_406BE7(char a1)
{
  char v2; // [esp+4h] [ebp-Ch]
  char v3; // [esp+8h] [ebp-8h]

  byte_425304 = 0;
  if ( !byte_4251F4 )
    sub_4063F0();
  byte_425308 = 0;
  if ( (a1 & 0x40) != 0 )
    byte_425308 = -1;
  v3 = sub_40648C(a1);
  if ( !v3 )
  {
    v3 = sub_406D17();
    if ( !v3 )
    {
      v2 = 0;
      do
      {
        if ( (unsigned __int8)byte_425340 < (int)(unsigned __int8)byte_42533C )
        {
          if ( !byte_425308 && byte_442720[8 * (unsigned __int8)byte_425340] != 29 )
            v2 = 1;
          if ( !v2 )
          {
            v3 = sub_406503((_BYTE *)(8 * (unsigned __int8)byte_425340 + 4466464));
            if ( !v3 )
              ++byte_425340;
          }
        }
        else
        {
          byte_425340 = 0;
          byte_42533C = 0;
          v2 = 1;
        }
      }
      while ( !v3 && !v2 );
    }
  }
  return v3;
}
// 4251F4: using guessed type char byte_4251F4;
// 425304: using guessed type char byte_425304;
// 425308: using guessed type char byte_425308;
// 42533C: using guessed type char byte_42533C;
// 425340: using guessed type char byte_425340;

//----- (00406D17) --------------------------------------------------------
char sub_406D17()
{
  char v1; // [esp+0h] [ebp-8h]

  v1 = 0;
  *(&byte_425328 + 1) = 64;
  *(&byte_425328 + 6) = 1;
  *(&byte_425328 + 7) = -1;
  if ( dword_4252A4 == -1 )
  {
    if ( dword_4252AC != -1 && byte_4251EC )
    {
      byte_425328 = 1;
      *(_DWORD *)(&byte_425328 + 2) = dword_4252AC;
      dword_4252AC = -1;
      return sub_406503(&byte_425328);
    }
  }
  else
  {
    byte_425328 = 0;
    *(_DWORD *)(&byte_425328 + 2) = dword_4252A4;
    dword_4252A4 = -1;
    return sub_406503(&byte_425328);
  }
  return v1;
}
// 4251EC: using guessed type char byte_4251EC;
// 4252A4: using guessed type int dword_4252A4;
// 4252AC: using guessed type int dword_4252AC;
// 425328: using guessed type char byte_425328;

//----- (00406DBA) --------------------------------------------------------
char __cdecl sub_406DBA(unsigned __int16 a1)
{
  char v2; // [esp+0h] [ebp-8h]

  v2 = 0;
  if ( byte_425319[8 * a1] == 64 && (unsigned __int8)byte_42531F[8 * a1] == 255 )
  {
    if ( byte_425318[8 * a1] == 2 && dword_42531A[2 * a1] == 65 )
    {
      byte_425344 = -1;
    }
    else if ( byte_425318[8 * a1] == 20 && dword_42531A[2 * a1] >= 80 && dword_42531A[2 * a1] <= 86 )
    {
      byte_425348 = -1;
    }
  }
  else if ( byte_425318[8 * a1] == 21
         && byte_425319[8 * a1] == 64
         && (unsigned __int8)byte_425344 == 255
         && (unsigned __int8)byte_425348 == 255 )
  {
    return sub_406E8B(a1);
  }
  return v2;
}
// 42531A: using guessed type int dword_42531A[];
// 425344: using guessed type char byte_425344;
// 425348: using guessed type char byte_425348;

//----- (00406E8B) --------------------------------------------------------
char __cdecl sub_406E8B(unsigned __int16 a1)
{
  int v2; // [esp+0h] [ebp-Ch] BYREF
  char v3; // [esp+4h] [ebp-8h]
  int v4; // [esp+8h] [ebp-4h]

  v3 = 0;
  v4 = 8 * a1 + 4346648;
  word_425208 = sub_406F2C(0, (unsigned __int8)byte_42531E[8 * a1]);
  if ( word_425208 )
    return -1;
  if ( *(unsigned __int8 *)(v4 + 7) == 255 )
  {
    *(_BYTE *)v4 = 28;
    *(_BYTE *)(v4 + 1) = 79;
    v3 = sub_40AF8D(*(_DWORD *)(v4 + 2), &v2);
    if ( !v3 )
      *(_DWORD *)(v4 + 2) = v2;
  }
  else
  {
    word_425208 = 5640;
    return -1;
  }
  return v3;
}
// 425208: using guessed type __int16 word_425208;

//----- (00406F2C) --------------------------------------------------------
__int16 __cdecl sub_406F2C(int a1, int a2)
{
  unsigned __int16 v3; // [esp+0h] [ebp-Ch]
  __int16 v4; // [esp+4h] [ebp-8h]
  __int16 v5; // [esp+8h] [ebp-4h]

  v4 = 0;
  if ( a1 )
  {
    if ( (unsigned __int8)byte_439202 == 255 )
    {
      v3 = 5;
      v5 = 5641;
    }
    else
    {
      v3 = 8;
      v5 = 5639;
    }
  }
  else if ( (unsigned __int8)byte_439202 == 255 )
  {
    v3 = 5;
    v5 = 5146;
  }
  else
  {
    v3 = 8;
    v5 = 5126;
  }
  if ( v3 < a2 )
    return v5;
  return v4;
}
// 439202: using guessed type char byte_439202;

//----- (00406FBC) --------------------------------------------------------
char __cdecl sub_406FBC(unsigned __int8 a1, char a2)
{
  char v3; // [esp+0h] [ebp-8h]

  v3 = 0;
  byte_425318[8 * a1] = a2;
  if ( a1 )
  {
    byte_42530C = 0;
    if ( (byte_425321 & 0x20) != 0 )
      byte_425321 |= 0x60u;
  }
  else
  {
    byte_425319[0] = 64;
    dword_42531A[0] = 0;
    if ( a2 == 27 )
    {
      byte_42531E[8 * a1] = byte_4252DE;
      byte_42531F[8 * a1] = byte_4252DF;
    }
    else
    {
      byte_42531E[8 * a1] = 0;
      byte_42531F[8 * a1] = -1;
      if ( byte_425318[8 * a1] == 29 )
        byte_42531E[8 * a1] = 1;
    }
  }
  if ( !byte_4251F4 )
    v3 = sub_406DBA(a1);
  if ( !v3 )
    return sub_40713F(a1);
  return v3;
}
// 4251F4: using guessed type char byte_4251F4;
// 4252DE: using guessed type char byte_4252DE;
// 4252DF: using guessed type char byte_4252DF;
// 42530C: using guessed type char byte_42530C;
// 42531A: using guessed type int dword_42531A[];
// 425321: using guessed type char byte_425321;

//----- (004070AB) --------------------------------------------------------
char sub_4070AB()
{
  char *v1; // [esp+0h] [ebp-10h]
  _BYTE *v2; // [esp+4h] [ebp-Ch]
  unsigned __int16 i; // [esp+8h] [ebp-8h]
  char v4; // [esp+Ch] [ebp-4h]

  v4 = 0;
  if ( (unsigned __int8)byte_42533C < 0x32u )
  {
    v1 = &byte_425328;
    v2 = (_BYTE *)(8 * (unsigned __int8)byte_42533C + 4466464);
    for ( i = 0; i < 8u; ++i )
      *v2++ = *v1++;
    ++byte_42533C;
  }
  else
  {
    word_425208 = 5635;
    return -1;
  }
  return v4;
}
// 425208: using guessed type __int16 word_425208;
// 425328: using guessed type char byte_425328;
// 42533C: using guessed type char byte_42533C;

//----- (0040713F) --------------------------------------------------------
char __cdecl sub_40713F(unsigned __int16 a1)
{
  _BYTE *v2; // [esp+0h] [ebp-10h]
  char i; // [esp+4h] [ebp-Ch]
  char v4; // [esp+8h] [ebp-8h]
  _BYTE *v5; // [esp+Ch] [ebp-4h]

  v4 = 0;
  if ( (unsigned __int8)byte_42533C < 0x32u )
  {
    v2 = (_BYTE *)(8 * a1 + 4346648);
    v5 = (_BYTE *)(8 * (unsigned __int8)byte_42533C + 4466464);
    for ( i = 0; i < 8; ++i )
      *v5++ = *v2++;
    ++byte_42533C;
  }
  else
  {
    word_425208 = 5635;
    return -1;
  }
  return v4;
}
// 425208: using guessed type __int16 word_425208;
// 42533C: using guessed type char byte_42533C;

//----- (004071D1) --------------------------------------------------------
char __cdecl sub_4071D1(unsigned __int8 a1, char a2)
{
  char *v3; // [esp+0h] [ebp-10h]
  char *v4; // [esp+4h] [ebp-Ch]
  char i; // [esp+8h] [ebp-8h]
  char v6; // [esp+Ch] [ebp-4h]

  v6 = 0;
  byte_425318[8 * a1] = a2;
  if ( a1 )
  {
    byte_42530C = 0;
    return sub_40739D(1u);
  }
  else
  {
    if ( (unsigned __int8)byte_42530C == 255 )
    {
      byte_42530C = 0;
      v6 = sub_4072D7();
    }
    if ( !v6 )
    {
      if ( a2 == 2 )
      {
        byte_42530C = -1;
        v4 = byte_425318;
        v3 = &byte_425320;
        for ( i = 8; i > 0; --i )
          *v3++ = *v4++;
      }
      else
      {
        byte_425319[0] = 64;
        byte_42531E[0] = 0;
        byte_42531F[0] = -1;
        return sub_40739D(0);
      }
    }
  }
  return v6;
}
// 42530C: using guessed type char byte_42530C;
// 425320: using guessed type char byte_425320;

//----- (004072D7) --------------------------------------------------------
char sub_4072D7()
{
  char v1; // [esp+0h] [ebp-Ch]
  char v2; // [esp+8h] [ebp-4h]

  v2 = 0;
  v1 = byte_425321;
  if ( (byte_425321 & 0x20) == 0 )
    return sub_40739D(1u);
  byte_425321 = 64;
  byte_425326 = 0;
  byte_425327 = -1;
  if ( (v1 & 0x10) != 0 )
  {
    byte_425320 = 5;
    v2 = sub_40739D(1u);
  }
  if ( !v2 && (v1 & 0x80) != 0 )
  {
    byte_425320 = 4;
    return sub_40739D(1u);
  }
  return v2;
}
// 425320: using guessed type char byte_425320;
// 425321: using guessed type char byte_425321;
// 425326: using guessed type char byte_425326;
// 425327: using guessed type char byte_425327;

//----- (0040739D) --------------------------------------------------------
char __cdecl sub_40739D(unsigned __int8 a1)
{
  char v2; // [esp+0h] [ebp-Ch]
  char v3; // [esp+4h] [ebp-8h]

  v3 = 0;
  if ( (unsigned __int8)byte_425304 == 255 )
  {
    v2 = 30;
    if ( (unsigned __int8)byte_4252B4 != 255 )
      v2 = -98;
    v3 = sub_406BE7(v2);
  }
  if ( !v3 )
    return sub_406503((_BYTE *)(8 * a1 + 4346648));
  return v3;
}
// 4252B4: using guessed type char byte_4252B4;
// 425304: using guessed type char byte_425304;

//----- (00407412) --------------------------------------------------------
char __cdecl sub_407412(char a1)
{
  byte_425319[0] = 0;
  if ( !a1 )
    byte_425319[0] = 64;
  dword_42531A[0] = dword_4252DA;
  byte_42531E[0] = byte_4252DE;
  byte_42531F[0] = byte_4252DF;
  return sub_4071D1(0, 2);
}
// 4252DE: using guessed type char byte_4252DE;
// 4252DF: using guessed type char byte_4252DF;
// 42531A: using guessed type int dword_42531A[];

//----- (0040747A) --------------------------------------------------------
char sub_40747A()
{
  if ( byte_425321 )
  {
    if ( byte_425321 == 16 )
      byte_425321 = 0;
    else
      byte_42530C = 0;
  }
  else
  {
    byte_425321 = 64;
    byte_425326 = 1;
    byte_425327 = -1;
  }
  return 0;
}
// 42530C: using guessed type char byte_42530C;
// 425321: using guessed type char byte_425321;
// 425326: using guessed type char byte_425326;
// 425327: using guessed type char byte_425327;

//----- (004074C8) --------------------------------------------------------
char sub_4074C8()
{
  char v1; // [esp+8h] [ebp-4h]

  v1 = 0;
  if ( (unsigned __int8)byte_42530C == 255 && byte_425321 == 64 )
  {
    if ( (unsigned __int8)byte_425326 <= 9u )
    {
      if ( dword_425322 >= 0 )
      {
        if ( (unsigned __int8)byte_425327 == 255 )
        {
          byte_425321 = 0;
        }
        else
        {
          word_425208 = 5638;
          return -1;
        }
      }
      else
      {
        word_425208 = 5637;
        return -1;
      }
    }
    else
    {
      word_425208 = 5636;
      return -1;
    }
  }
  else if ( (unsigned __int8)byte_42530C != 255 || byte_425321 )
  {
    byte_425319[0] = 48;
    return sub_4071D1(0, 2);
  }
  else
  {
    byte_425321 = 16;
  }
  return v1;
}
// 425208: using guessed type __int16 word_425208;
// 42530C: using guessed type char byte_42530C;
// 425321: using guessed type char byte_425321;
// 425322: using guessed type int dword_425322;
// 425326: using guessed type char byte_425326;
// 425327: using guessed type char byte_425327;

//----- (00407595) --------------------------------------------------------
char sub_407595()
{
  char v1; // [esp+8h] [ebp-4h]

  v1 = 0;
  if ( (unsigned __int8)byte_42530C == 255 )
  {
    if ( byte_425321 == 64 )
    {
      dword_425322 = ~dword_425322;
      ++dword_425322;
    }
    else
    {
      byte_425321 ^= 0x80u;
    }
  }
  else
  {
    byte_425319[0] = -96;
    return sub_4071D1(0, 2);
  }
  return v1;
}
// 42530C: using guessed type char byte_42530C;
// 425321: using guessed type char byte_425321;
// 425322: using guessed type int dword_425322;

//----- (00407612) --------------------------------------------------------
char __cdecl sub_407612(char a1)
{
  return sub_4071D1((unsigned __int8)byte_42530C == 255, a1);
}
// 42530C: using guessed type char byte_42530C;

//----- (0040764C) --------------------------------------------------------
char __cdecl sub_40764C(char a1, char a2)
{
  byte_42534C = a1;
  return sub_4071D1((unsigned __int8)byte_42530C == 255, a2);
}
// 42530C: using guessed type char byte_42530C;
// 42534C: using guessed type char byte_42534C;

//----- (00407690) --------------------------------------------------------
char __cdecl sub_407690(char a1)
{
  int v2; // [esp+0h] [ebp-8h] BYREF
  char v3; // [esp+4h] [ebp-4h]

  v3 = 0;
  if ( (unsigned __int8)byte_42530C == 255 && byte_425321 == 64 )
  {
    word_425208 = sub_406F2C(1, (unsigned __int8)byte_425326);
    if ( word_425208 )
    {
      v3 = -1;
    }
    else if ( (unsigned __int8)byte_425327 == 255 )
    {
      byte_425321 = 79;
      v3 = sub_40AF8D(dword_425322, &v2);
      if ( !v3 )
        dword_425322 = v2;
    }
    else
    {
      word_425208 = 5640;
      v3 = -1;
    }
  }
  if ( !v3 )
    return sub_407612(a1);
  return v3;
}
// 425208: using guessed type __int16 word_425208;
// 42530C: using guessed type char byte_42530C;
// 425321: using guessed type char byte_425321;
// 425322: using guessed type int dword_425322;
// 425326: using guessed type char byte_425326;
// 425327: using guessed type char byte_425327;

//----- (0040774E) --------------------------------------------------------
char __cdecl sub_40774E(char a1)
{
  int v2; // [esp+8h] [ebp-8h] BYREF
  char v3; // [esp+Ch] [ebp-4h]

  v3 = 0;
  byte_425319[0] = 79;
  v3 = sub_40B47C(&v2);
  if ( !v3 )
  {
    dword_42531A[0] = v2;
    v3 = sub_4071D1(0, 2);
    if ( !v3 )
      return sub_4071D1(1u, a1);
  }
  return v3;
}
// 42531A: using guessed type int dword_42531A[];

//----- (004077C0) --------------------------------------------------------
char __cdecl sub_4077C0(char a1)
{
  int v2; // [esp+8h] [ebp-8h] BYREF
  char v3; // [esp+Ch] [ebp-4h]

  v3 = 0;
  byte_425319[0] = 79;
  if ( a1 == 64 )
  {
    v3 = sub_40B13D();
  }
  else
  {
    v3 = sub_40B217(&v2);
    if ( !v3 )
      dword_42531A[0] = v2;
  }
  if ( !v3 )
  {
    v3 = sub_4071D1(0, 2);
    if ( !v3 )
      return sub_4071D1(1u, a1);
  }
  return v3;
}
// 42531A: using guessed type int dword_42531A[];

//----- (00407850) --------------------------------------------------------
char __cdecl sub_407850(char a1)
{
  int v2; // [esp+8h] [ebp-8h] BYREF
  char v3; // [esp+Ch] [ebp-4h]

  v3 = 0;
  byte_425319[0] = 79;
  sub_40B17B(&v2);
  dword_42531A[0] = v2;
  v3 = sub_4071D1(0, 2);
  if ( !v3 )
  {
    v3 = sub_4071D1(1u, 16);
    if ( a1 != 64 && !v3 )
      return sub_40B1B9();
  }
  return v3;
}
// 42531A: using guessed type int dword_42531A[];

//----- (004078D9) --------------------------------------------------------
char __cdecl sub_4078D9(char a1)
{
  if ( a1 == 1 )
    return sub_40AEF2(dword_4252AC);
  else
    return sub_406FBC((unsigned __int8)byte_42530C == 255, a1);
}
// 4252AC: using guessed type int dword_4252AC;
// 42530C: using guessed type char byte_42530C;

//----- (00407936) --------------------------------------------------------
char sub_407936()
{
  byte_425328 = 27;
  byte_425329 = 64;
  dword_42532A = 0;
  byte_42532E = byte_4252DE;
  byte_42532F = byte_4252DF;
  return sub_4070AB();
}
// 4252DE: using guessed type char byte_4252DE;
// 4252DF: using guessed type char byte_4252DF;
// 425328: using guessed type char byte_425328;
// 425329: using guessed type char byte_425329;
// 42532A: using guessed type int dword_42532A;
// 42532E: using guessed type char byte_42532E;
// 42532F: using guessed type char byte_42532F;

//----- (0040797B) --------------------------------------------------------
char sub_40797B()
{
  __int16 v1; // [esp+0h] [ebp-10h]
  __int16 i; // [esp+4h] [ebp-Ch]
  char v3; // [esp+8h] [ebp-8h]

  byte_42534C = 0;
  v3 = sub_407612(28);
  if ( !v3 )
  {
    v3 = sub_40648C(byte_4252DE);
    if ( !v3 )
    {
      v1 = 0;
      for ( i = (unsigned __int8)byte_4252DE; i > 0 && !v3; --i )
        v3 = sub_40648C(byte_428C40[v1++]);
    }
  }
  return v3;
}
// 4252DE: using guessed type char byte_4252DE;
// 42534C: using guessed type char byte_42534C;

//----- (00407A1C) --------------------------------------------------------
char __cdecl sub_407A1C(char a1, char a2)
{
  char v3; // [esp+0h] [ebp-8h]

  byte_42534C = 1;
  v3 = sub_407612(28);
  if ( !v3 )
  {
    v3 = sub_40648C(a1);
    if ( !v3 )
      sub_40648C(a2);
  }
  return v3;
}
// 42534C: using guessed type char byte_42534C;

//----- (00407A72) --------------------------------------------------------
char __cdecl sub_407A72(char a1)
{
  __int16 v2; // [esp+0h] [ebp-10h]
  __int16 i; // [esp+4h] [ebp-Ch]
  char v4; // [esp+8h] [ebp-8h]

  byte_42534C = a1;
  if ( a1 == 2 || a1 == 3 || a1 != 4 && a1 != 5 )
    return sub_407612(28);
  v4 = sub_407612(28);
  if ( !v4 )
  {
    v4 = sub_40648C(byte_4252DE);
    if ( !v4 )
    {
      v2 = 0;
      for ( i = (unsigned __int8)byte_4252DE; i > 0 && !v4; --i )
        v4 = sub_40648C(byte_428C40[v2++]);
    }
  }
  return v4;
}
// 4252DE: using guessed type char byte_4252DE;
// 42534C: using guessed type char byte_42534C;

//----- (00407B7D) --------------------------------------------------------
char __cdecl sub_407B7D(char a1)
{
  byte_42534C = a1;
  return sub_407612(28);
}
// 42534C: using guessed type char byte_42534C;

//----- (00407BA9) --------------------------------------------------------
char __cdecl sub_407BA9(char a1, unsigned __int8 a2)
{
  char v2; // al
  char v3; // al
  char v5; // [esp+8h] [ebp-8h]
  char v6; // [esp+Ch] [ebp-4h]
  char v7; // [esp+1Ch] [ebp+Ch]

  v5 = 0;
  switch ( a1 )
  {
    case 0:
      v5 = sub_407412(a2);
      break;
    case 1:
      v5 = sub_40747A();
      break;
    case 2:
      v5 = sub_4074C8();
      break;
    case 3:
      v5 = sub_407595();
      break;
    case 4:
    case 5:
    case 6:
      if ( a1 == 4 )
      {
        v2 = sub_407612(byte_420CF8[a2]);
      }
      else if ( a1 == 5 )
      {
        v2 = sub_407612(byte_420CFC[a2]);
      }
      else
      {
        if ( a1 == 6 )
          v6 = byte_420D00[a2] | 0x20;
        v2 = sub_407612(v6);
      }
      v5 = v2;
      break;
    case 7:
    case 8:
      if ( a1 == 7 )
        v3 = sub_40764C(a2, 25);
      else
        v3 = sub_40764C(a2, 26);
      v5 = v3;
      break;
    case 9:
      sub_407612(6);
      v5 = sub_406B58(255);
      break;
    case 10:
      v5 = sub_407690(byte_420D18[a2]);
      break;
    case 11:
      v5 = sub_40B13D();
      break;
    case 12:
      v5 = sub_4077C0(byte_420D18[a2 ^ 1]);
      break;
    case 13:
      v5 = sub_407850(byte_420D18[a2 ^ 1]);
      break;
    case 14:
      v5 = sub_4078D9(a2);
      break;
    case 15:
      v5 = sub_407936();
      break;
    case 16:
    case 17:
      if ( a1 == 16 )
        v7 = -34;
      else
        v7 = -33;
      v5 = sub_406BE7(v7);
      break;
    case 18:
      v5 = sub_40797B();
      break;
    case 19:
      v5 = sub_407A1C(a2, byte_4252D9);
      break;
    case 20:
      v5 = sub_407A72(a2);
      break;
    case 21:
      v5 = sub_407B7D(a2);
      break;
    case 22:
      if ( a2 != 6 )
        a2 ^= 1u;
      v5 = sub_40774E(byte_420D18[a2]);
      break;
    case 23:
      sub_407612(7);
      break;
    default:
      v5 = -1;
      break;
  }
  if ( !v5 )
  {
    switch ( a1 )
    {
      case 9:
      case 10:
      case 12:
      case 13:
      case 16:
      case 17:
      case 18:
      case 19:
      case 20:
      case 21:
      case 22:
      case 23:
        byte_425304 = -1;
        break;
      default:
        break;
    }
  }
  if ( byte_425204 == 2 && dword_425398 )
    sub_4035F1();
  return v5;
}
// 407C77: variable 'v6' is possibly undefined
// 425204: using guessed type char byte_425204;
// 4252D9: using guessed type char byte_4252D9;
// 425304: using guessed type char byte_425304;
// 425398: using guessed type int dword_425398;

//----- (00407F10) --------------------------------------------------------
char __cdecl sub_407F10(_WORD *a1)
{
  char v2; // [esp+0h] [ebp-4h]

  v2 = 0;
  if ( (unsigned __int8)byte_4251F8 == 255 )
  {
    while ( *a1 == 42 && !v2 )
    {
      do
        v2 = sub_4011D0(a1);
      while ( *a1 != 43 && (unsigned __int16)*a1 != 0xFFFF && !v2 );
      if ( (unsigned __int16)*a1 != 0xFFFF && !v2 )
        v2 = sub_4011D0(a1);
    }
  }
  return v2;
}
// 4251F8: using guessed type char byte_4251F8;

//----- (00407FB6) --------------------------------------------------------
char sub_407FB6()
{
  int v1; // [esp+0h] [ebp-8h] BYREF
  char v2; // [esp+4h] [ebp-4h]

  v2 = 0;
  sub_40AE73();
  if ( byte_4251F8 )
    return v2;
  byte_4252D8 = 14;
  byte_4252D9 = 27;
  byte_4252DF = word_4252FC;
  byte_4252DE = 0;
  v2 = sub_4011D0(&v1);
  if ( v2 )
    return v2;
  switch ( (unsigned __int16)v1 )
  {
    case '8':
      if ( byte_434780 )
      {
        v2 = sub_4081E0(v1);
        goto LABEL_11;
      }
      break;
    case '3':
      v2 = sub_4085E3(v1);
      goto LABEL_11;
    case '6':
      v2 = sub_40A9D0(v1);
      goto LABEL_11;
  }
  v2 = sub_4084E5(v1);
LABEL_11:
  if ( !v2 )
  {
    v2 = sub_4011D0(&v1);
    if ( !v2 )
      word_4252D0 = v1;
  }
  if ( v2 && word_42757C > 80 )
    word_42757C = 80;
  return v2;
}
// 4251F8: using guessed type char byte_4251F8;
// 4252D0: using guessed type __int16 word_4252D0;
// 4252D8: using guessed type char byte_4252D8;
// 4252D9: using guessed type char byte_4252D9;
// 4252DE: using guessed type char byte_4252DE;
// 4252DF: using guessed type char byte_4252DF;
// 4252FC: using guessed type __int16 word_4252FC;
// 42757C: using guessed type __int16 word_42757C;
// 434780: using guessed type char byte_434780;

//----- (00408102) --------------------------------------------------------
char __cdecl sub_408102(unsigned __int16 a1)
{
  byte_4252D8 = 14;
  byte_4252D9 = 27;
  byte_4252DF = 0;
  byte_4252DE = 0;
  return sub_408B3E(a1);
}
// 4252D8: using guessed type char byte_4252D8;
// 4252D9: using guessed type char byte_4252D9;
// 4252DE: using guessed type char byte_4252DE;
// 4252DF: using guessed type char byte_4252DF;

//----- (00408141) --------------------------------------------------------
char __cdecl sub_408141(unsigned __int16 a1)
{
  byte_4252D8 = 14;
  byte_4252D9 = 27;
  byte_4252DF = 0;
  byte_4252DE = 0;
  return sub_408C40(a1);
}
// 4252D8: using guessed type char byte_4252D8;
// 4252D9: using guessed type char byte_4252D9;
// 4252DE: using guessed type char byte_4252DE;
// 4252DF: using guessed type char byte_4252DF;

//----- (00408180) --------------------------------------------------------
char __cdecl sub_408180(char a1)
{
  char v2; // [esp+0h] [ebp-4h]

  v2 = 0;
  if ( (unsigned __int16)word_4252FC >= 0xFFu )
  {
    word_425208 = 5136;
    return -1;
  }
  else
  {
    ++byte_4252DE;
    byte_428C40[(unsigned __int16)word_4252FC++] = a1;
  }
  return v2;
}
// 425208: using guessed type __int16 word_425208;
// 4252DE: using guessed type char byte_4252DE;
// 4252FC: using guessed type __int16 word_4252FC;

//----- (004081E0) --------------------------------------------------------
char __cdecl sub_4081E0(__int16 a1)
{
  unsigned __int16 v2; // [esp+0h] [ebp-Ch]
  char v3; // [esp+4h] [ebp-8h]
  char v4; // [esp+8h] [ebp-4h]

  v4 = sub_4011D0(&a1);
  if ( !v4 || word_425208 )
  {
    do
    {
      while ( a1 == 46 && !v4 )
        v4 = sub_4011D0(&a1);
      if ( a1 != 56 && !v4 )
      {
        v3 = 0;
        v2 = 0;
        do
        {
          if ( ++v3 <= 4 )
          {
            v4 = sub_40837F((unsigned __int16 *)&a1);
            if ( !v4 )
            {
              v2 = a1 | (16 * v2);
              v4 = sub_4011D0(&a1);
            }
          }
          else
          {
            word_425208 = 5137;
            v4 = -1;
          }
        }
        while ( a1 != 46 && a1 != 56 && !v4 );
        if ( !v4 )
          v4 = sub_408400(v2);
      }
    }
    while ( a1 != 56 && !v4 );
    if ( !v4 )
      v4 = sub_4011D0(&a1);
    if ( v4 || a1 == 43 )
    {
      return v4;
    }
    else
    {
      if ( !word_425208 )
        word_425208 = 5137;
      return -1;
    }
  }
  else
  {
    word_425208 = 5137;
    return v4;
  }
}
// 425208: using guessed type __int16 word_425208;

//----- (0040837F) --------------------------------------------------------
char __cdecl sub_40837F(unsigned __int16 *a1)
{
  char v2; // [esp+0h] [ebp-4h]

  v2 = 0;
  sub_4010A0(a1);
  if ( *a1 < 0x30u || *a1 > 0x39u )
  {
    if ( *a1 < 0x41u || *a1 > 0x46u )
    {
      word_425208 = 5138;
      return -1;
    }
    else
    {
      *a1 -= 55;
    }
  }
  else
  {
    *a1 -= 48;
  }
  return v2;
}
// 425208: using guessed type __int16 word_425208;

//----- (00408400) --------------------------------------------------------
char __cdecl sub_408400(unsigned __int16 a1)
{
  char v2; // [esp+0h] [ebp-Ch]
  char v3; // [esp+8h] [ebp-4h]

  v3 = 0;
  if ( (a1 < 0x20u || a1 > 0x5Fu) && (a1 < 0xA0u || a1 > 0xDFu) )
  {
    if ( byte_4393E2 == 1 )
      sub_401158(&a1);
    else
      sub_4010E0(&a1);
    if ( a1 )
    {
      v2 = HIBYTE(a1);
      v3 = sub_408180(SHIBYTE(a1));
      if ( !v3 )
        v2 = a1;
    }
    else
    {
      word_425208 = 5139;
      v3 = -1;
    }
  }
  else
  {
    v2 = a1;
  }
  if ( !v3 )
    return sub_408180(v2);
  return v3;
}
// 4084D3: variable 'v2' is possibly undefined
// 425208: using guessed type __int16 word_425208;
// 4393E2: using guessed type char byte_4393E2;

//----- (004084E5) --------------------------------------------------------
char __cdecl sub_4084E5(unsigned __int8 a1)
{
  char v2; // [esp+0h] [ebp-4h]

  v2 = 0;
  while ( a1 != 43 && !v2 )
  {
    if ( a1 <= 9u || a1 == 60 || a1 >= 0xCu && a1 <= 0x25u || a1 == 10 || a1 == 11 || a1 == 56 || a1 == 46 )
    {
      sub_4010A0((unsigned __int16 *)&a1);
      v2 = sub_408180(a1);
      if ( !v2 )
        v2 = sub_4011D0(&a1);
    }
    else if ( a1 == 60 )
    {
      v2 = sub_408840((unsigned __int16 *)&a1);
    }
    else
    {
      word_425208 = 5141;
      v2 = -1;
    }
  }
  return v2;
}
// 425208: using guessed type __int16 word_425208;

//----- (004085E3) --------------------------------------------------------
char __cdecl sub_4085E3(unsigned __int8 a1)
{
  unsigned __int8 v2; // [esp+8h] [ebp-10h]
  __int16 v3; // [esp+10h] [ebp-8h]
  char v4; // [esp+14h] [ebp-4h]

LABEL_1:
  v4 = sub_4011D0(&a1);
  sub_4010A0((unsigned __int16 *)&a1);
  do
  {
    if ( a1 == 32 && !v4 )
      goto LABEL_1;
    if ( a1 == 34 || v4 )
      continue;
    v2 = 0;
    v3 = 0;
    while ( 1 )
    {
      if ( a1 >= 0x30u && a1 <= 0x39u )
      {
        a1 -= 48;
        goto LABEL_17;
      }
      if ( a1 < 0x41u || a1 > 0x46u )
        break;
      a1 -= 65;
      a1 += 10;
LABEL_17:
      ++v2;
      v3 = a1 | (unsigned __int16)(16 * v3);
      sub_4011D0(&a1);
      sub_4010A0((unsigned __int16 *)&a1);
    }
    if ( a1 != 32 && a1 != 34 )
    {
      word_425208 = 5152;
      return -1;
    }
    if ( v2 == 2 )
    {
      v4 = sub_408180(v3);
    }
    else
    {
      if ( v2 <= 2u || v2 > 4u )
      {
        word_425208 = 5152;
        return -1;
      }
      sub_408180((unsigned __int16)(v3 & 0xFF00) >> 8);
      v4 = sub_408180(v3);
    }
  }
  while ( a1 != 34 && !v4 );
  if ( !v4 )
    v4 = sub_4011D0(&a1);
  if ( !v4 && a1 != 43 )
  {
    word_425208 = 5152;
    return -1;
  }
  return v4;
}
// 40882A: conditional instruction was optimized away because %var_4.1==0
// 425208: using guessed type __int16 word_425208;

//----- (00408840) --------------------------------------------------------
char __cdecl sub_408840(unsigned __int16 *a1)
{
  char v2; // [esp+0h] [ebp-4h]

  v2 = sub_4011D0(a1);
  if ( !v2 )
  {
    while ( *a1 != 60 && *a1 != 39 && *a1 != 43 && !v2 )
    {
      if ( *a1 < 6u || *a1 > 8u )
        v2 = sub_408A2F(a1);
      else
        v2 = sub_408912(a1);
    }
  }
  if ( !v2 )
  {
    if ( *a1 == 60 )
    {
      return sub_4011D0(a1);
    }
    else
    {
      v2 = -1;
      word_425208 = 5144;
    }
  }
  return v2;
}
// 425208: using guessed type __int16 word_425208;

//----- (00408912) --------------------------------------------------------
char __cdecl sub_408912(unsigned __int16 *a1)
{
  __int16 v2; // [esp+0h] [ebp-10h]
  char i; // [esp+4h] [ebp-Ch]
  char v4; // [esp+Ch] [ebp-4h]

  v4 = 0;
  v2 = 0;
  for ( i = 0; i < 4 && *a1 != 60 && *a1 != 39 && *a1 != 43 && !v4; ++i )
  {
    v4 = sub_40837F(a1);
    if ( !v4 )
    {
      v2 = *a1 | (16 * v2);
      v4 = sub_4011D0(a1);
    }
  }
  if ( i < 4 && (*a1 == 60 || *a1 == 39 || *a1 == 43) && !v4 )
  {
    word_425208 = 5138;
    return -1;
  }
  else if ( i == 4 && !v4 )
  {
    return sub_408400(v2 - 0x4000);
  }
  return v4;
}
// 425208: using guessed type __int16 word_425208;

//----- (00408A2F) --------------------------------------------------------
char __cdecl sub_408A2F(unsigned __int16 *a1)
{
  __int16 v2; // [esp+0h] [ebp-10h]
  char i; // [esp+4h] [ebp-Ch]
  char v4; // [esp+Ch] [ebp-4h]

  v2 = 0;
  v4 = 0;
  for ( i = 0; i < 2 && *a1 != 60 && *a1 != 39 && *a1 != 43 && !v4; ++i )
  {
    v4 = sub_40837F(a1);
    if ( !v4 )
    {
      v2 = *a1 | (16 * v2);
      v4 = sub_4011D0(a1);
    }
  }
  if ( i < 2 && (*a1 == 60 || *a1 == 39 || *a1 == 43) && !v4 )
  {
    word_425208 = 5138;
    return -1;
  }
  else if ( i == 2 && !v4 )
  {
    return sub_408180(v2);
  }
  return v4;
}
// 425208: using guessed type __int16 word_425208;

//----- (00408B3E) --------------------------------------------------------
char __cdecl sub_408B3E(unsigned __int16 a1)
{
  char v2; // [esp+0h] [ebp-4h]

  v2 = 0;
  word_4252D0 = a1;
  while ( a1 != 49 && a1 != 57 && !v2 )
  {
    if ( a1 <= 9u || a1 >= 0xCu && a1 <= 0x25u || a1 == 10 || a1 == 11 || a1 == 50 || a1 == 46 )
    {
      sub_4010A0(&a1);
      v2 = sub_408180(a1);
      if ( !v2 )
        v2 = sub_4011D0(&a1);
      if ( !v2 )
        word_4252D0 = a1;
    }
    else
    {
      word_425208 = 5141;
      v2 = -1;
    }
  }
  return v2;
}
// 425208: using guessed type __int16 word_425208;
// 4252D0: using guessed type __int16 word_4252D0;

//----- (00408C40) --------------------------------------------------------
char __cdecl sub_408C40(unsigned __int16 a1)
{
  char v2; // [esp+0h] [ebp-4h]

  v2 = 0;
  word_4252D0 = a1;
  while ( a1 != 49 && a1 != 44 && !v2 )
  {
    if ( a1 <= 9u || a1 >= 0xCu && a1 <= 0x25u || a1 == 10 || a1 == 46 || a1 == 50 || a1 == 56 || a1 == 41 )
    {
      sub_4010A0(&a1);
      v2 = sub_408180(a1);
      if ( !v2 )
        v2 = sub_4011D0(&a1);
      if ( !v2 )
        word_4252D0 = a1;
    }
    else
    {
      word_425208 = 5141;
      v2 = -1;
    }
  }
  return v2;
}
// 425208: using guessed type __int16 word_425208;
// 4252D0: using guessed type __int16 word_4252D0;

//----- (00408D50) --------------------------------------------------------
char __cdecl sub_408D50(unsigned __int16 a1, int *a2, char *a3)
{
  *a2 = a1;
  *a3 = 1;
  return sub_408D85(a2, a3);
}

//----- (00408D85) --------------------------------------------------------
char __cdecl sub_408D85(int *a1, char *a2)
{
  int v3; // [esp+0h] [ebp-Ch] BYREF
  int v4; // [esp+4h] [ebp-8h]
  char v5; // [esp+8h] [ebp-4h]

  v5 = 0;
  v5 = sub_4011D0(&v3);
  word_4252D0 = v3;
  if ( !v5 )
  {
    while ( (unsigned __int16)v3 <= 9u && !v5 )
    {
      *a1 *= 10;
      *a1 += (unsigned __int16)v3;
      ++*a2;
      v5 = sub_4011D0(&v3);
      word_4252D0 = v3;
    }
  }
  if ( !v5 )
  {
    byte_4252DE = *a2;
    v4 = *a1;
    dword_4252DA = v4;
  }
  return v5;
}
// 4252D0: using guessed type __int16 word_4252D0;
// 4252DE: using guessed type char byte_4252DE;

//----- (00408E3C) --------------------------------------------------------
char __cdecl sub_408E3C(unsigned __int16 a1)
{
  int v2; // [esp+0h] [ebp-Ch] BYREF
  char v3; // [esp+4h] [ebp-8h]
  int v4; // [esp+8h] [ebp-4h] BYREF

  v3 = 0;
  byte_4252D8 = 0;
  byte_4252D9 = 0;
  byte_4252DF = -1;
  v3 = sub_408D50(a1, &v4, (char *)&v2);
  if ( (unsigned __int8)v2 > 9u && !v3 )
  {
    word_425208 = 5121;
    return -1;
  }
  return v3;
}
// 425208: using guessed type __int16 word_425208;
// 4252D8: using guessed type char byte_4252D8;
// 4252D9: using guessed type char byte_4252D9;
// 4252DF: using guessed type char byte_4252DF;

//----- (00408E9C) --------------------------------------------------------
char __cdecl sub_408E9C(unsigned __int16 a1)
{
  int v2; // [esp+0h] [ebp-Ch] BYREF
  char v3; // [esp+4h] [ebp-8h]
  int v4; // [esp+8h] [ebp-4h] BYREF

  v3 = 0;
  byte_4252D8 = 0;
  byte_4252D9 = 0;
  v3 = sub_408D50(a1, &v4, (char *)&v2);
  if ( !v3 )
  {
    byte_4252DF = -1;
    if ( word_4252D0 == 11 )
    {
      byte_4252DF = v2;
      v3 = sub_408D85(&v4, (char *)&v2);
      if ( !v3 )
      {
        byte_4252DF -= v2;
        byte_4252DF = ~byte_4252DF;
        ++byte_4252DF;
      }
    }
    if ( (unsigned __int8)v2 > 9u && !v3 )
    {
      word_425208 = 5121;
      return -1;
    }
  }
  return v3;
}
// 425208: using guessed type __int16 word_425208;
// 4252D0: using guessed type __int16 word_4252D0;
// 4252D8: using guessed type char byte_4252D8;
// 4252D9: using guessed type char byte_4252D9;
// 4252DF: using guessed type char byte_4252DF;

//----- (00408F6D) --------------------------------------------------------
char sub_408F6D()
{
  int v1; // [esp+0h] [ebp-10h] BYREF
  int v2; // [esp+4h] [ebp-Ch] BYREF
  char v3; // [esp+8h] [ebp-8h]
  int v4; // [esp+Ch] [ebp-4h] BYREF

  v3 = 0;
  v3 = sub_4011D0(&v1);
  if ( !v3 )
  {
    if ( (unsigned __int8)v1 > 9u )
    {
      word_425208 = 5122;
      return -1;
    }
    else
    {
      byte_4252D8 = 0;
      byte_4252D9 = 0;
      v3 = sub_408D50((unsigned __int8)v1, &v4, (char *)&v2);
      if ( !v3 )
      {
        byte_4252DF = v2;
        if ( (unsigned __int8)v2 > 9u )
        {
          word_425208 = 5121;
          return -1;
        }
      }
    }
  }
  return v3;
}
// 425208: using guessed type __int16 word_425208;
// 4252D8: using guessed type char byte_4252D8;
// 4252D9: using guessed type char byte_4252D9;
// 4252DF: using guessed type char byte_4252DF;

//----- (00409005) --------------------------------------------------------
char sub_409005()
{
  int v1; // [esp+0h] [ebp-10h] BYREF
  int v2; // [esp+4h] [ebp-Ch] BYREF
  char v3; // [esp+8h] [ebp-8h]
  int v4; // [esp+Ch] [ebp-4h] BYREF

  v3 = 0;
  v3 = sub_4011D0(&v1);
  if ( !v3 )
  {
    if ( (unsigned __int16)v1 > 9u )
    {
      if ( (unsigned __int16)v1 == 48 )
      {
        byte_4252D8 = 2;
        v3 = sub_4011D0(&v1);
        word_4252D0 = v1;
      }
      else
      {
        word_425208 = 5124;
        return -1;
      }
    }
    else
    {
      byte_4252D8 = 0;
      byte_4252D9 = 1;
      v3 = sub_408D50(v1, &v4, (char *)&v2);
      if ( (unsigned __int8)v2 > 9u && !v3 )
      {
        word_425208 = 5123;
        v3 = -1;
      }
      if ( word_4252D0 == 59 )
      {
        byte_4252D8 = 2;
        word_4252E0 = 255;
        dword_4252E4 = dword_4252DA;
        byte_4252E8 = byte_4252DE;
        byte_4252E9 = byte_4252DF;
      }
    }
  }
  return v3;
}
// 425208: using guessed type __int16 word_425208;
// 4252D0: using guessed type __int16 word_4252D0;
// 4252D8: using guessed type char byte_4252D8;
// 4252D9: using guessed type char byte_4252D9;
// 4252DE: using guessed type char byte_4252DE;
// 4252DF: using guessed type char byte_4252DF;
// 4252E0: using guessed type __int16 word_4252E0;
// 4252E4: using guessed type int dword_4252E4;
// 4252E8: using guessed type char byte_4252E8;
// 4252E9: using guessed type char byte_4252E9;

//----- (0040910A) --------------------------------------------------------
char __cdecl sub_40910A(unsigned __int16 a1)
{
  int v2; // [esp+0h] [ebp-Ch] BYREF
  char v3; // [esp+4h] [ebp-8h]
  int v4; // [esp+8h] [ebp-4h] BYREF

  v3 = 0;
  if ( byte_4252D9 )
  {
    if ( byte_4252D9 == 1 )
    {
      v3 = sub_408D50(a1, &v4, (char *)&v2);
      if ( !v3 )
      {
        word_425208 = sub_406F2C(0, (unsigned __int8)v2);
        if ( word_425208 )
          return -1;
      }
    }
  }
  else
  {
    v3 = sub_408D50(a1, &v4, (char *)&v2);
    if ( !v3 && (unsigned __int8)v2 > 8u )
    {
      word_425208 = 5125;
      return -1;
    }
  }
  return v3;
}
// 425208: using guessed type __int16 word_425208;
// 4252D9: using guessed type char byte_4252D9;

//----- (004091B9) --------------------------------------------------------
char __cdecl sub_4091B9(__int16 a1)
{
  char v2; // [esp+4h] [ebp-4h]

  v2 = 0;
  if ( byte_4252D8 != 6 )
    return v2;
  if ( a1 == 48 )
  {
    v2 = sub_4011D0(&a1);
    if ( !v2 )
      word_4252D0 = a1;
    return v2;
  }
  switch ( byte_4252D9 )
  {
    case 0:
      if ( a1 != 29 )
        goto LABEL_22;
      if ( !sub_4011D0(&a1) )
        word_4252D0 = a1;
      if ( a1 == 48 )
      {
        v2 = sub_4011D0(&a1);
        if ( !v2 )
          word_4252D0 = a1;
      }
      else if ( a1 == 24 )
      {
        if ( !sub_4011D0(&a1) )
          word_4252D0 = a1;
        if ( a1 == 48 )
        {
          v2 = sub_4011D0(&a1);
          if ( !v2 )
            word_4252D0 = a1;
        }
        else
        {
          word_425208 = 5127;
          return -1;
        }
      }
      else
      {
LABEL_22:
        word_425208 = 5132;
        return -1;
      }
      return v2;
    case 1:
      if ( a1 == 23 )
      {
        if ( !sub_4011D0(&a1) )
          word_4252D0 = a1;
        if ( a1 == 48 )
        {
          v2 = sub_4011D0(&a1);
          if ( !v2 )
            word_4252D0 = a1;
        }
        else
        {
          word_425208 = 5127;
          return -1;
        }
      }
      else
      {
        word_425208 = 5132;
        return -1;
      }
      return v2;
    case 2:
      if ( a1 == 13 )
      {
        if ( !sub_4011D0(&a1) )
          word_4252D0 = a1;
        if ( a1 == 48 )
        {
          v2 = sub_4011D0(&a1);
          if ( !v2 )
            word_4252D0 = a1;
        }
        else
        {
          word_425208 = 5127;
          return -1;
        }
      }
      else
      {
        word_425208 = 5132;
        return -1;
      }
      return v2;
    case 3:
      if ( a1 == 23 )
      {
        if ( !sub_4011D0(&a1) )
          word_4252D0 = a1;
        if ( a1 == 48 )
        {
          v2 = sub_4011D0(&a1);
          if ( !v2 )
            word_4252D0 = a1;
        }
        else
        {
          word_425208 = 5127;
          return -1;
        }
      }
      else
      {
        word_425208 = 5132;
        return -1;
      }
      return v2;
    case 4:
      if ( a1 == 13 )
      {
        if ( !sub_4011D0(&a1) )
          word_4252D0 = a1;
        if ( a1 == 48 )
        {
          v2 = sub_4011D0(&a1);
          if ( !v2 )
            word_4252D0 = a1;
        }
        else
        {
          word_425208 = 5127;
          return -1;
        }
      }
      else
      {
        word_425208 = 5132;
        return -1;
      }
      return v2;
    case 5:
      if ( a1 == 35 )
      {
        if ( !sub_4011D0(&a1) )
          word_4252D0 = a1;
        if ( a1 == 13 )
        {
          if ( !sub_4011D0(&a1) )
            word_4252D0 = a1;
          if ( a1 == 48 )
          {
            v2 = sub_4011D0(&a1);
            if ( !v2 )
              word_4252D0 = a1;
          }
          else
          {
            word_425208 = 5127;
            return -1;
          }
          return v2;
        }
LABEL_79:
        word_425208 = 5132;
        return -1;
      }
      if ( a1 != 13 )
        goto LABEL_79;
      if ( !sub_4011D0(&a1) )
        word_4252D0 = a1;
      if ( a1 == 48 )
      {
        v2 = sub_4011D0(&a1);
        if ( !v2 )
          word_4252D0 = a1;
      }
      else
      {
        word_425208 = 5127;
        return -1;
      }
      return v2;
    case 6:
      if ( a1 == 13 )
      {
        if ( !sub_4011D0(&a1) )
          word_4252D0 = a1;
        if ( a1 == 48 )
        {
          v2 = sub_4011D0(&a1);
          if ( !v2 )
            word_4252D0 = a1;
        }
        else
        {
          word_425208 = 5127;
          return -1;
        }
      }
      else
      {
        word_425208 = 5132;
        return -1;
      }
      return v2;
    case 7:
      if ( a1 == 31 )
      {
        if ( !sub_4011D0(&a1) )
          word_4252D0 = a1;
        if ( a1 == 48 )
        {
          v2 = sub_4011D0(&a1);
          if ( !v2 )
            word_4252D0 = a1;
        }
        else
        {
          word_425208 = 5127;
          return -1;
        }
      }
      else
      {
        word_425208 = 5132;
        return -1;
      }
      return v2;
    case 8:
      if ( a1 != 18 )
        goto LABEL_121;
      if ( !sub_4011D0(&a1) )
        word_4252D0 = a1;
      if ( a1 != 13 )
        goto LABEL_121;
      if ( !sub_4011D0(&a1) )
        word_4252D0 = a1;
      if ( a1 == 31 )
      {
        if ( !sub_4011D0(&a1) )
          word_4252D0 = a1;
        if ( a1 == 48 )
        {
          v2 = sub_4011D0(&a1);
          if ( !v2 )
            word_4252D0 = a1;
        }
        else
        {
          word_425208 = 5127;
          return -1;
        }
      }
      else
      {
LABEL_121:
        word_425208 = 5132;
        return -1;
      }
      return v2;
    case 9:
      if ( a1 == 15 )
      {
        if ( !sub_4011D0(&a1) )
          word_4252D0 = a1;
        if ( a1 == 48 )
        {
          v2 = sub_4011D0(&a1);
          if ( !v2 )
            word_4252D0 = a1;
        }
        else
        {
          word_425208 = 5127;
          return -1;
        }
      }
      else
      {
        word_425208 = 5132;
        return -1;
      }
      return v2;
    case 10:
      if ( a1 == 33 )
      {
        if ( !sub_4011D0(&a1) )
          word_4252D0 = a1;
        if ( a1 == 48 )
        {
          v2 = sub_4011D0(&a1);
          if ( !v2 )
            word_4252D0 = a1;
        }
        else
        {
          word_425208 = 5127;
          return -1;
        }
      }
      else
      {
        word_425208 = 5132;
        return -1;
      }
      return v2;
    case 11:
      if ( a1 != 26 )
        goto LABEL_151;
      if ( !sub_4011D0(&a1) )
        word_4252D0 = a1;
      if ( a1 == 13 )
      {
        if ( !sub_4011D0(&a1) )
          word_4252D0 = a1;
        if ( a1 == 48 )
        {
          v2 = sub_4011D0(&a1);
          if ( !v2 )
            word_4252D0 = a1;
        }
        else
        {
          word_425208 = 5127;
          return -1;
        }
      }
      else
      {
LABEL_151:
        word_425208 = 5132;
        return -1;
      }
      return v2;
    case 12:
      if ( a1 != 12 )
        goto LABEL_163;
      if ( !sub_4011D0(&a1) )
        word_4252D0 = a1;
      if ( a1 == 23 )
      {
        if ( !sub_4011D0(&a1) )
          word_4252D0 = a1;
        if ( a1 == 48 )
        {
          v2 = sub_4011D0(&a1);
          if ( !v2 )
            word_4252D0 = a1;
        }
        else
        {
          word_425208 = 5127;
          return -1;
        }
      }
      else
      {
LABEL_163:
        word_425208 = 5132;
        return -1;
      }
      return v2;
    case 14:
      if ( a1 == 33 )
      {
        if ( !sub_4011D0(&a1) )
          word_4252D0 = a1;
        if ( a1 == 48 )
        {
          v2 = sub_4011D0(&a1);
          if ( !v2 )
            word_4252D0 = a1;
        }
        else
        {
          word_425208 = 5127;
          return -1;
        }
      }
      else
      {
        word_425208 = 5132;
        return -1;
      }
      return v2;
    case 15:
      if ( a1 == 33 )
      {
        if ( !sub_4011D0(&a1) )
          word_4252D0 = a1;
        if ( a1 == 48 )
        {
          v2 = sub_4011D0(&a1);
          if ( !v2 )
            word_4252D0 = a1;
        }
        else
        {
          word_425208 = 5127;
          return -1;
        }
      }
      else
      {
        word_425208 = 5132;
        return -1;
      }
      return v2;
    case 18:
      if ( a1 == 25 )
      {
        if ( !sub_4011D0(&a1) )
          word_4252D0 = a1;
        if ( a1 == 48 )
        {
          v2 = sub_4011D0(&a1);
          if ( !v2 )
            word_4252D0 = a1;
        }
        else
        {
          word_425208 = 5127;
          return -1;
        }
      }
      else
      {
        word_425208 = 5132;
        return -1;
      }
      return v2;
    default:
      word_425208 = 5127;
      return -1;
  }
}
// 425208: using guessed type __int16 word_425208;
// 4252D0: using guessed type __int16 word_4252D0;
// 4252D8: using guessed type char byte_4252D8;
// 4252D9: using guessed type char byte_4252D9;

//----- (00409CDA) --------------------------------------------------------
char __cdecl sub_409CDA(unsigned __int16 a1)
{
  int v2; // [esp+4h] [ebp-Ch] BYREF
  char v3; // [esp+8h] [ebp-8h]
  int v4; // [esp+Ch] [ebp-4h] BYREF

  v3 = 0;
  if ( (unsigned __int8)byte_4252D8 == 129 )
  {
    if ( byte_4252D9 && byte_4252D9 != 2 )
    {
      if ( byte_4252D9 == 3 || byte_4252D9 == 4 )
      {
        if ( a1 > 9u )
        {
          word_425208 = 5131;
          return -1;
        }
        else
        {
          v3 = sub_408D50(a1, &v4, (char *)&v2);
          if ( !v3 )
          {
            if ( (unsigned __int8)v2 > 1u )
            {
              word_425208 = 5129;
              return -1;
            }
            else if ( (v4 & 0xFFFF0000) != 0 )
            {
              word_425208 = 5130;
              return -1;
            }
            else if ( v4 < 1 || v4 > 3 )
            {
              word_425208 = 5130;
              return -1;
            }
          }
        }
      }
    }
    else if ( a1 == 48 )
    {
      v3 = sub_4011D0(&a1);
      word_4252D0 = a1;
    }
    else
    {
      word_425208 = 5128;
      return -1;
    }
  }
  return v3;
}
// 425208: using guessed type __int16 word_425208;
// 4252D0: using guessed type __int16 word_4252D0;
// 4252D8: using guessed type char byte_4252D8;
// 4252D9: using guessed type char byte_4252D9;

//----- (00409E07) --------------------------------------------------------
char __cdecl sub_409E07(unsigned __int16 a1)
{
  char result; // al
  char v2[4]; // [esp+0h] [ebp-10h] BYREF
  char v3[4]; // [esp+4h] [ebp-Ch] BYREF
  char v4; // [esp+8h] [ebp-8h]
  int *v5; // [esp+Ch] [ebp-4h]

  v4 = 0;
  v5 = &dword_4252DA;
  LOBYTE(dword_4252DA) = a1;
  if ( a1 != 16 || (v4 = sub_4011D0(&a1), word_4252D0 = a1, v4) )
  {
    v4 = sub_4011D0(&a1);
    word_4252D0 = a1;
    if ( !v4 )
    {
      if ( a1 >= 0xCu && a1 <= 0x25u )
      {
        if ( a1 == 13 && *(_BYTE *)v5 == 13 )
        {
          byte_4252D8 = 14;
          byte_4252D9 = 30;
          *(_BYTE *)v5 = a1;
          byte_4252BC = 75;
          result = sub_4011D0(&a1);
          v4 = result;
          word_4252D0 = a1;
          return result;
        }
        v4 = sub_40A080(&a1, v3, v2);
        if ( !v4 )
        {
          byte_4252D8 = v3[0];
          byte_4252D9 = v2[0];
          v4 = sub_4091B9(a1);
          if ( !v4 )
            return sub_409CDA(a1);
        }
      }
      else
      {
        if ( (*(_BYTE *)v5 == 12 || *(_BYTE *)v5 == 13) && a1 > 9u )
        {
          v4 = -1;
          word_425208 = 5153;
          return -1;
        }
        byte_4252D8 = 14;
        byte_4252D9 = *(_BYTE *)v5;
        byte_4252D9 -= 12;
        return sub_40910A(a1);
      }
    }
    return v4;
  }
  else if ( a1 < 0xCu || a1 > 0x25u )
  {
    byte_4252D8 = 14;
    byte_4252D9 = *(_BYTE *)v5;
    byte_4252D9 -= 12;
    result = sub_40910A(a1);
    v4 = result;
  }
  else
  {
    byte_4252D8 = 14;
    byte_4252D9 = 30;
    byte_4252BC = a1;
    *(_BYTE *)v5 = a1;
    byte_4252BC -= 12;
    byte_4252BC += 48;
    result = sub_4011D0(&a1);
    v4 = result;
    word_4252D0 = a1;
  }
  return result;
}
// 425208: using guessed type __int16 word_425208;
// 4252BC: using guessed type char byte_4252BC;
// 4252D0: using guessed type __int16 word_4252D0;
// 4252D8: using guessed type char byte_4252D8;
// 4252D9: using guessed type char byte_4252D9;
// 409E07: using guessed type char var_10[4];
// 409E07: using guessed type char var_C[4];

//----- (0040A080) --------------------------------------------------------
char __cdecl sub_40A080(unsigned __int16 *a1, _BYTE *a2, _BYTE *a3)
{
  __int16 i; // [esp+4h] [ebp-24h]
  int *v5; // [esp+Ch] [ebp-1Ch]
  unsigned __int8 *v6; // [esp+10h] [ebp-18h]
  __int16 v7; // [esp+14h] [ebp-14h]
  char *v8; // [esp+18h] [ebp-10h]
  char v9; // [esp+1Ch] [ebp-Ch]
  _BOOL2 v10; // [esp+20h] [ebp-8h]
  unsigned __int8 *v11; // [esp+24h] [ebp-4h]

  v7 = 1;
  v8 = (char *)&dword_4252DA + 1;
  do
  {
    *v8++ = *(_BYTE *)a1;
    ++v7;
    v9 = sub_4011D0(a1);
    if ( !v9 )
    {
      word_4252D0 = *a1;
      v6 = (unsigned __int8 *)&unk_420D20;
      do
      {
        v11 = v6;
        v5 = &dword_4252DA;
        v10 = 0;
        for ( i = 1; i <= v7 && !v10; ++i )
        {
          v10 = *(unsigned __int8 *)v5 != *v11;
          v5 = (int *)((char *)v5 + 1);
          ++v11;
        }
        if ( v10 )
          v6 += 8;
      }
      while ( (unsigned int)v6 < 0x421E60 && v10 );
      *a2 = v6[6];
      *a3 = v6[7];
      if ( v7 != v6[5] )
      {
        if ( *a1 <= 9u && *a3 == 20 )
        {
          *a3 = 4;
          v7 = v6[5];
        }
        else if ( *a1 < 0xCu || *a1 > 0x25u )
        {
          word_425208 = 5132;
          v9 = -1;
        }
        if ( v7 > 5 )
        {
          word_425208 = 5133;
          v9 = -1;
        }
      }
    }
  }
  while ( !v9 && v7 != v6[5] );
  return v9;
}
// 40A235: variable 'v6' is possibly undefined
// 425208: using guessed type __int16 word_425208;
// 4252D0: using guessed type __int16 word_4252D0;

//----- (0040A247) --------------------------------------------------------
char __cdecl sub_40A247(unsigned __int16 a1)
{
  char v2; // [esp+4h] [ebp-4h]

  v2 = 0;
  switch ( a1 )
  {
    case 0xAu:
      byte_4252D8 = 4;
      byte_4252D9 = 1;
      break;
    case 0x27u:
      byte_4252D8 = 16;
      if ( word_4252E2 )
      {
        word_425208 = 4619;
        v2 = -1;
        word_4252E2 = 0;
      }
      break;
    case 0x29u:
      byte_4252D8 = 5;
      byte_4252D9 = 1;
      break;
    case 0x2Bu:
      byte_4252D8 = -121;
      break;
    case 0x30u:
      byte_4252D8 = -126;
      break;
    case 0x31u:
      goto LABEL_6;
    case 0x32u:
      byte_4252D8 = 4;
      byte_4252D9 = 0;
      break;
    case 0x36u:
      v2 = sub_4011D0(&a1);
      word_4252D0 = a1;
      if ( a1 == 54 )
      {
        byte_4252D8 = -127;
        byte_4252D9 = 17;
      }
      else if ( a1 < 0xCu || a1 > 0x25u )
      {
        v2 = -1;
        word_425208 = 5132;
      }
      else
      {
        byte_4252D8 = 14;
        byte_4252D9 = 28;
      }
      break;
    case 0x38u:
      byte_4252D8 = 5;
      byte_4252D9 = 0;
      break;
    case 0x39u:
      byte_4252D8 = -123;
      break;
    case 0x3Du:
      --word_4252E2;
LABEL_6:
      byte_4252D8 = -125;
      break;
    case 0x3Fu:
      byte_4252D8 = 9;
      break;
    case 0x40u:
      v2 = sub_4011D0(&a1);
      word_4252D0 = a1;
      if ( a1 == 64 )
      {
        byte_4252D8 = -127;
        byte_4252D9 = 18;
      }
      else
      {
        v2 = -1;
        word_425208 = 5132;
      }
      break;
    default:
      word_425208 = 5135;
      v2 = -1;
      break;
  }
  return v2;
}
// 425208: using guessed type __int16 word_425208;
// 4252D0: using guessed type __int16 word_4252D0;
// 4252D8: using guessed type char byte_4252D8;
// 4252D9: using guessed type char byte_4252D9;
// 4252E2: using guessed type __int16 word_4252E2;

//----- (0040A485) --------------------------------------------------------
char __cdecl sub_40A485(unsigned __int16 a1)
{
  char v2; // [esp+0h] [ebp-8h]

  v2 = 0;
  if ( (unsigned __int8)byte_4252D8 == 129 && byte_4252D9 == 16 )
    return sub_408102(a1);
  if ( byte_4252D8 == 33 && a1 == 42 )
  {
    byte_4252D8 = -122;
    v2 = sub_4011D0(&a1);
    word_4252D0 = a1;
  }
  else if ( a1 == 42 )
  {
    return sub_407FB6();
  }
  else if ( a1 == 44 )
  {
    return sub_409005();
  }
  else if ( a1 < 0xCu || a1 > 0x25u )
  {
    if ( a1 == 40 )
    {
      byte_4252D8 = 17;
    }
    else if ( a1 == 38 )
    {
      LOBYTE(dword_4252DA) = a1 - 26;
      v2 = sub_4011D0(&a1);
      word_4252D0 = a1;
      if ( !v2 && (a1 < 0xCu || a1 > 0x25u) )
      {
        byte_4252D8 = 14;
        byte_4252D9 = dword_4252DA - 12;
        return sub_40910A(a1);
      }
    }
    else
    {
      v2 = sub_40A247(a1);
      if ( !v2 && byte_4252D9 != 28 )
      {
        v2 = sub_4011D0(&a1);
        word_4252D0 = a1;
      }
    }
  }
  else
  {
    return sub_409E07(a1);
  }
  return v2;
}
// 4252D0: using guessed type __int16 word_4252D0;
// 4252D8: using guessed type char byte_4252D8;
// 4252D9: using guessed type char byte_4252D9;

//----- (0040A65D) --------------------------------------------------------
char sub_40A65D()
{
  char result; // al
  int v1; // [esp+0h] [ebp-8h] BYREF
  char v2; // [esp+4h] [ebp-4h]

  v2 = 0;
  LOWORD(v1) = word_4252D0;
  if ( word_4252D0 == 255 )
  {
    v2 = sub_4011D0(&v1);
    word_4252FC = 0;
  }
  if ( !v2 )
    v2 = sub_407F10(&v1);
  if ( v2 )
    return v2;
  if ( (unsigned __int16)v1 == 0xFFFF )
  {
    word_425208 = 5134;
    v2 = -1;
LABEL_20:
    if ( (unsigned __int16)v1 <= 9u )
      return sub_408E9C(v1);
    if ( (unsigned __int16)v1 == 11 )
      return sub_408F6D();
    return sub_40A485(v1);
  }
  if ( word_4252E0 == 255 && byte_4252D8 == 2 )
  {
    byte_4252D8 = 0;
    byte_4252D9 = 0;
    dword_4252DA = dword_4252E4;
    byte_4252DE = byte_4252E8;
    byte_4252DF = -1;
  }
  else
  {
    if ( word_4252E0 != 255 || byte_4252D8 || byte_4252D9 )
    {
      if ( byte_4252D8 == 32
        && (unsigned __int8)byte_4252D9 == 130
        && (unsigned __int16)v1 != 49
        && (unsigned __int16)v1 != 44 )
      {
        result = sub_408141(v1);
        v2 = result;
        return result;
      }
      goto LABEL_20;
    }
    byte_4252D8 = 4;
    byte_4252D9 = 0;
    word_4252E0 = 0;
    ++word_4252E2;
    v2 = sub_4011D0(&v1);
    word_4252D0 = v1;
  }
  return v2;
}
// 425208: using guessed type __int16 word_425208;
// 4252D0: using guessed type __int16 word_4252D0;
// 4252D8: using guessed type char byte_4252D8;
// 4252D9: using guessed type char byte_4252D9;
// 4252DE: using guessed type char byte_4252DE;
// 4252DF: using guessed type char byte_4252DF;
// 4252E0: using guessed type __int16 word_4252E0;
// 4252E2: using guessed type __int16 word_4252E2;
// 4252E4: using guessed type int dword_4252E4;
// 4252E8: using guessed type char byte_4252E8;
// 4252FC: using guessed type __int16 word_4252FC;

//----- (0040A836) --------------------------------------------------------
char sub_40A836()
{
  int v1; // [esp+0h] [ebp-8h] BYREF
  char v2; // [esp+4h] [ebp-4h]

  v2 = 0;
  LOWORD(v1) = word_4252D0;
  if ( word_4252D0 == 255 )
    v2 = sub_4011D0(&v1);
  if ( !v2 )
    v2 = sub_407F10(&v1);
  if ( !v2 )
  {
    if ( (unsigned __int16)v1 == 0xFFFF )
    {
      word_425208 = 5134;
      return -1;
    }
    else if ( word_4252E0 == 255 && byte_4252D8 == 2 )
    {
      byte_4252D8 = 0;
      byte_4252D9 = 0;
      dword_4252DA = dword_4252E4;
      byte_4252DE = byte_4252E8;
      byte_4252DF = -1;
    }
    else if ( word_4252E0 != 255 || byte_4252D8 || byte_4252D9 )
    {
      if ( (unsigned __int16)v1 > 9u )
      {
        if ( (unsigned __int16)v1 == 11 )
        {
          byte_4252D8 = -124;
          v2 = sub_4011D0(&v1);
          word_4252D0 = v1;
        }
        else
        {
          return sub_40A485(v1);
        }
      }
      else
      {
        return sub_408E3C(v1);
      }
    }
    else
    {
      byte_4252D8 = 4;
      byte_4252D9 = 0;
      word_4252E0 = 0;
      ++word_4252E2;
      v2 = sub_4011D0(&v1);
      word_4252D0 = v1;
    }
  }
  return v2;
}
// 425208: using guessed type __int16 word_425208;
// 4252D0: using guessed type __int16 word_4252D0;
// 4252D8: using guessed type char byte_4252D8;
// 4252D9: using guessed type char byte_4252D9;
// 4252DE: using guessed type char byte_4252DE;
// 4252DF: using guessed type char byte_4252DF;
// 4252E0: using guessed type __int16 word_4252E0;
// 4252E2: using guessed type __int16 word_4252E2;
// 4252E4: using guessed type int dword_4252E4;
// 4252E8: using guessed type char byte_4252E8;

//----- (0040A9D0) --------------------------------------------------------
char __cdecl sub_40A9D0(unsigned __int16 a1)
{
  char v2[4]; // [esp+0h] [ebp-10h] BYREF
  int v3; // [esp+4h] [ebp-Ch]
  unsigned __int8 v4; // [esp+8h] [ebp-8h]
  char v5; // [esp+Ch] [ebp-4h]

  v5 = 0;
  v2[0] = 0;
  __setargv();
  v5 = sub_40ABAB(a1, v2);
  if ( v5 )
  {
    v5 = -1;
    word_425208 = 5141;
    return -1;
  }
  else
  {
    v5 = sub_4011D0(&a1);
    if ( !v5 || word_425208 )
    {
      do
      {
        while ( a1 == 46 && !v5 )
          v5 = sub_4011D0(&a1);
        if ( a1 != 56 && !v5 )
        {
          v4 = 0;
          LOWORD(v3) = 0;
          do
          {
            if ( (char)++v4 <= 4 )
            {
              v5 = sub_40837F(&a1);
              if ( !v5 )
              {
                LOWORD(v3) = 16 * v3;
                LOWORD(v3) = a1 | v3;
                v5 = sub_4011D0(&a1);
              }
            }
            else
            {
              word_425208 = 5137;
              v5 = -1;
            }
          }
          while ( a1 != 46 && a1 != 56 && !v5 );
          if ( !v5 )
            v5 = sub_40AC90(v3, v4, v2[0]);
        }
      }
      while ( a1 != 56 && !v5 );
      if ( !v5 )
        v5 = sub_4011D0(&a1);
      if ( v5 || a1 == 43 )
      {
        return v5;
      }
      else
      {
        if ( !word_425208 )
          word_425208 = 5137;
        v5 = -1;
        return -1;
      }
    }
    else
    {
      word_425208 = 5137;
      return v5;
    }
  }
}
// 40AE64: using guessed type int __setargv(void);
// 425208: using guessed type __int16 word_425208;
// 40A9D0: using guessed type char var_10[4];

//----- (0040ABAB) --------------------------------------------------------
char __cdecl sub_40ABAB(unsigned __int16 a1, _BYTE *a2)
{
  char Buf1[4]; // [esp+10h] [ebp-14h] BYREF
  char v4; // [esp+14h] [ebp-10h]
  char v5; // [esp+18h] [ebp-Ch]
  int v6; // [esp+1Ch] [ebp-8h]
  char v7; // [esp+20h] [ebp-4h]

  v5 = 0;
  v7 = 0;
  v4 = 0;
  v6 = 0;
  do
  {
    v5 = sub_4011D0(&a1);
    if ( v5 )
      break;
    sub_4010A0(&a1);
    v7 = a1;
    v5 = sub_4011D0(&a1);
    if ( v5 )
      break;
    sub_4010A0(&a1);
    v4 = a1;
    Buf1[0] = 38;
    Buf1[1] = v7;
    Buf1[2] = a1;
    if ( !sub_410B92(Buf1, a2) )
      return -1;
    sub_40AE8C(*a2 + 80);
  }
  while ( v6 );
  return v5;
}

//----- (0040AC90) --------------------------------------------------------
char __cdecl sub_40AC90(__int16 a1, unsigned __int8 a2, char a3)
{
  char v4; // [esp+8h] [ebp-10h] BYREF
  char v5; // [esp+9h] [ebp-Fh]
  char v6[4]; // [esp+Ch] [ebp-Ch] BYREF
  int v7; // [esp+10h] [ebp-8h]
  char v8; // [esp+14h] [ebp-4h]

  v8 = 0;
  v6[0] = 0;
  v7 = 0;
  if ( a2 == 2 )
  {
    v6[0] = a1;
    if ( !sub_410CDD((unsigned __int8 *)v6) )
    {
      v7 = sub_410D33(a3);
      if ( v7 == 1 )
        v7 = sub_410A33(a3, (unsigned __int8 *)v6);
    }
    return sub_408180(v6[0]);
  }
  else if ( a2 > 2u && a2 <= 4u )
  {
    v4 = (unsigned __int16)(a1 & 0xFF00) >> 8;
    v6[0] = a1;
    v5 = a1;
    v7 = sub_410D33(a3);
    if ( v7 == 2 )
    {
      v7 = sub_410A33(a3, (unsigned __int8 *)&v4);
      if ( v7 )
      {
        v8 = sub_408180(v4);
        if ( !v8 )
          return sub_408180(v5);
      }
      else
      {
        v8 = sub_408180(v4);
        if ( !v8 )
          return sub_408180(v5);
      }
    }
    else
    {
      v8 = sub_408180(v4);
      if ( !v8 )
        return sub_408180(v5);
    }
  }
  else
  {
    v8 = -1;
    word_425208 = 5139;
  }
  return v8;
}
// 425208: using guessed type __int16 word_425208;
// 40AC90: using guessed type char var_C[4];

//----- (0040AE73) --------------------------------------------------------
void sub_40AE73()
{
  dword_4251B4 = 0;
}
// 4251B4: using guessed type int dword_4251B4;

//----- (0040AE82) --------------------------------------------------------
int sub_40AE82()
{
  return dword_4251B4;
}
// 4251B4: using guessed type int dword_4251B4;

//----- (0040AE8C) --------------------------------------------------------
char __cdecl sub_40AE8C(char a1)
{
  char result; // al

  result = a1;
  byte_4251B8 = a1;
  return result;
}
// 4251B8: using guessed type char byte_4251B8;

//----- (0040AE99) --------------------------------------------------------
char sub_40AE99()
{
  return byte_4251B8;
}
// 4251B8: using guessed type char byte_4251B8;

//----- (0040AEB0) --------------------------------------------------------
char sub_40AEB0()
{
  char result; // al

  result = byte_425204;
  switch ( byte_425204 )
  {
    case 0:
      byte_425358 = 0;
      return result;
    case 1:
      goto LABEL_7;
    case 2:
      byte_425358 = 0;
LABEL_7:
      byte_425360 = 0;
      byte_42537C = 0;
      break;
  }
  return result;
}
// 425204: using guessed type char byte_425204;
// 425358: using guessed type char byte_425358;
// 425360: using guessed type char byte_425360;
// 42537C: using guessed type char byte_42537C;

//----- (0040AEF2) --------------------------------------------------------
char __cdecl sub_40AEF2(int a1)
{
  unsigned __int16 i; // [esp+0h] [ebp-8h]
  char v3; // [esp+4h] [ebp-4h]

  v3 = 0;
  if ( byte_425204 == 1 )
  {
    for ( i = 0; i < (int)(unsigned __int8)byte_425358 && !v3; ++i )
    {
      if ( dword_438E60[i] == a1 )
      {
        if ( dword_4404A0[i] == -1 )
        {
          dword_4404A0[i] = dword_4252EC;
        }
        else
        {
          word_425208 = 5764;
          v3 = -1;
        }
      }
    }
  }
  return v3;
}
// 425204: using guessed type char byte_425204;
// 425208: using guessed type __int16 word_425208;
// 4252EC: using guessed type int dword_4252EC;
// 425358: using guessed type char byte_425358;
// 438E60: using guessed type int dword_438E60[200];
// 4404A0: using guessed type int dword_4404A0[198];

//----- (0040AF8D) --------------------------------------------------------
char __cdecl sub_40AF8D(int a1, _DWORD *a2)
{
  unsigned __int16 v3; // [esp+4h] [ebp-8h]
  unsigned __int16 v4; // [esp+4h] [ebp-8h]
  char v5; // [esp+8h] [ebp-4h]

  v5 = 0;
  switch ( byte_425204 )
  {
    case 0:
      v3 = (unsigned __int8)byte_425358;
      if ( (unsigned __int8)byte_425358 >= 0xC8u )
      {
        word_425208 = 5761;
        return -1;
      }
      dword_438E60[(unsigned __int8)byte_425358] = a1;
      dword_4404A0[v3] = -1;
      ++byte_425358;
LABEL_8:
      *a2 = 0;
      return v5;
    case 1:
      goto LABEL_8;
    case 2:
      v4 = (unsigned __int8)byte_425358++;
      if ( dword_4404A0[v4] == -1 )
      {
        word_425208 = 5762;
        return -1;
      }
      else
      {
        *a2 = dword_4404A0[v4];
      }
      break;
  }
  return v5;
}
// 425204: using guessed type char byte_425204;
// 425208: using guessed type __int16 word_425208;
// 425358: using guessed type char byte_425358;
// 438E60: using guessed type int dword_438E60[200];
// 4404A0: using guessed type int dword_4404A0[198];

//----- (0040B13D) --------------------------------------------------------
char sub_40B13D()
{
  dword_4392B0[(unsigned __int16)((unsigned __int8)byte_42529C - 1)] = dword_4252EC;
  return 0;
}
// 42529C: using guessed type char byte_42529C;
// 4252EC: using guessed type int dword_4252EC;
// 4392B0: using guessed type int dword_4392B0[];

//----- (0040B17B) --------------------------------------------------------
char __cdecl sub_40B17B(_DWORD *a1)
{
  *a1 = dword_4392B0[(unsigned __int16)((unsigned __int8)byte_42529C - 1)];
  return 0;
}
// 42529C: using guessed type char byte_42529C;
// 4392B0: using guessed type int dword_4392B0[];

//----- (0040B1B9) --------------------------------------------------------
char sub_40B1B9()
{
  if ( byte_425204 == 1 )
    dword_428D40[(unsigned __int8)byte_429F80[(unsigned __int16)((unsigned __int8)byte_42529C - 1)]] = dword_4252EC;
  return 0;
}
// 425204: using guessed type char byte_425204;
// 42529C: using guessed type char byte_42529C;
// 4252EC: using guessed type int dword_4252EC;
// 428D40: using guessed type int dword_428D40[200];

//----- (0040B217) --------------------------------------------------------
char __cdecl sub_40B217(_DWORD *a1)
{
  char v2; // [esp+8h] [ebp-4h]

  v2 = 0;
  switch ( byte_425204 )
  {
    case 0:
      goto LABEL_8;
    case 1:
      if ( (unsigned __int8)byte_425360 >= 0xC8u )
      {
        word_425208 = 5763;
        return -1;
      }
      byte_429F80[(unsigned __int16)((unsigned __int8)byte_42529C - 1)] = byte_425360++;
LABEL_8:
      *a1 = 0;
      return v2;
    case 2:
      *a1 = dword_428D40[(unsigned __int8)byte_425360++];
      break;
  }
  return v2;
}
// 425204: using guessed type char byte_425204;
// 425208: using guessed type __int16 word_425208;
// 42529C: using guessed type char byte_42529C;
// 425360: using guessed type char byte_425360;
// 428D40: using guessed type int dword_428D40[200];

//----- (0040B2D6) --------------------------------------------------------
char sub_40B2D6()
{
  if ( !byte_425204 )
  {
    if ( (unsigned __int16)word_438A42 >= 0x2710u )
      return -1;
    word_43B520[(unsigned __int16)word_438A42++] = word_42907E[(unsigned __int8)byte_4252C4];
  }
  return 0;
}
// 425204: using guessed type char byte_425204;
// 4252C4: using guessed type char byte_4252C4;
// 42907E: using guessed type __int16 word_42907E[257];
// 438A42: using guessed type __int16 word_438A42;
// 43B520: using guessed type __int16 word_43B520[10000];

//----- (0040B33C) --------------------------------------------------------
int sub_40B33C()
{
  int result; // eax

  result = (unsigned __int8)byte_425204;
  if ( !byte_425204 )
  {
    result = (unsigned __int8)byte_4252C4;
    ++word_42907E[(unsigned __int8)byte_4252C4];
  }
  return result;
}
// 425204: using guessed type char byte_425204;
// 4252C4: using guessed type char byte_4252C4;
// 42907E: using guessed type __int16 word_42907E[257];

//----- (0040B36F) --------------------------------------------------------
char sub_40B36F()
{
  unsigned __int16 v1; // [esp+0h] [ebp-Ch]
  unsigned __int16 v2; // [esp+4h] [ebp-8h]

  if ( byte_425204 == 1 )
  {
    if ( (unsigned __int16)word_42907E[(unsigned __int8)byte_4252C4] > 0x1770u )
    {
      word_425208 = 4133;
      return -1;
    }
    v1 = 0;
    v2 = 0;
    while ( v2 < 4u && v1 < 0x2710u )
    {
      if ( word_42907E[(unsigned __int8)byte_4252C4] == word_43B520[v1] )
      {
        dword_42A5E0[v1] = dword_4252EC;
        ++v2;
      }
      else if ( v2 )
      {
        break;
      }
      ++v1;
    }
    ++word_42907E[(unsigned __int8)byte_4252C4];
  }
  return 0;
}
// 425204: using guessed type char byte_425204;
// 425208: using guessed type __int16 word_425208;
// 4252C4: using guessed type char byte_4252C4;
// 4252EC: using guessed type int dword_4252EC;
// 42907E: using guessed type __int16 word_42907E[257];
// 42A5E0: using guessed type int dword_42A5E0[10000];
// 43B520: using guessed type __int16 word_43B520[10000];

//----- (0040B47C) --------------------------------------------------------
char __cdecl sub_40B47C(_DWORD *a1)
{
  if ( byte_425204 == 2 )
  {
    if ( (unsigned __int16)word_438A42 >= 0x2710u )
    {
      word_425208 = 4133;
      return -1;
    }
    *a1 = dword_42A5E0[(unsigned __int16)word_438A42++];
  }
  else
  {
    *a1 = 0;
  }
  return 0;
}
// 425204: using guessed type char byte_425204;
// 425208: using guessed type __int16 word_425208;
// 42A5E0: using guessed type int dword_42A5E0[10000];
// 438A42: using guessed type __int16 word_438A42;

//----- (0040B4F0) --------------------------------------------------------
char __cdecl sub_40B4F0(int a1)
{
  __int16 v2; // [esp+0h] [ebp-8h] BYREF
  char v3; // [esp+4h] [ebp-4h]

  v3 = 0;
  word_43B460 = 0;
  dword_4252EC = 0;
  dword_425368 = 0;
  word_425298 = 0;
  word_4252C0 = 0;
  byte_4252C4 = 0;
  word_438A42 = 0;
  sub_40640D();
  v3 = sub_4011D0(&v2);
  if ( v3 )
    return v3;
  word_4252D0 = v2;
  v3 = sub_40BC76(&a1);
  if ( v3 )
  {
    if ( v3 != 99 )
    {
      word_425208 = 0;
      word_428C30 = 0;
      byte_4252C8 = 0;
      sub_406460();
      byte_4252D8 = 0;
      byte_4252D9 = 0;
      byte_4252DE = 0;
      byte_4252DF = 0;
      word_4252E2 = 0;
      word_427570 = 0;
      word_4252D0 = 255;
      word_42520C = sub_40A65D();
    }
    v3 = 0;
  }
  while ( 1 )
  {
    if ( !v3 )
    {
      byte_42529C = 0;
      v3 = sub_40B70D();
      if ( !v3 )
      {
        if ( byte_4252D8 == 17 )
        {
          v3 = sub_407BA9(17, 0);
        }
        else
        {
          word_425208 = 4116;
          v3 = -1;
        }
      }
    }
    if ( byte_425204 == 2 && word_4403E2 && dword_4428B4 < dword_427560 )
      return 0;
    if ( !v3 )
      return v3;
    if ( v3 == 99 )
      break;
    word_425208 = 0;
    word_428C30 = 0;
    byte_4252C8 = 0;
    sub_406460();
    byte_4252D8 = 0;
    byte_4252D9 = 0;
    byte_4252DE = 0;
    byte_4252DF = 0;
    word_4252E0 = 0;
    word_4252E2 = 0;
    word_427570 = 0;
    v3 = 0;
    if ( word_42755C )
      return v3;
    word_4252D0 = 255;
    word_42520C = sub_40A65D();
  }
  return v3;
}
// 425204: using guessed type char byte_425204;
// 425208: using guessed type __int16 word_425208;
// 42520C: using guessed type __int16 word_42520C;
// 425298: using guessed type __int16 word_425298;
// 42529C: using guessed type char byte_42529C;
// 4252C0: using guessed type __int16 word_4252C0;
// 4252C4: using guessed type char byte_4252C4;
// 4252C8: using guessed type char byte_4252C8;
// 4252D0: using guessed type __int16 word_4252D0;
// 4252D8: using guessed type char byte_4252D8;
// 4252D9: using guessed type char byte_4252D9;
// 4252DE: using guessed type char byte_4252DE;
// 4252DF: using guessed type char byte_4252DF;
// 4252E0: using guessed type __int16 word_4252E0;
// 4252E2: using guessed type __int16 word_4252E2;
// 4252EC: using guessed type int dword_4252EC;
// 425368: using guessed type int dword_425368;
// 42755C: using guessed type __int16 word_42755C;
// 427560: using guessed type int dword_427560;
// 427570: using guessed type __int16 word_427570;
// 428C30: using guessed type __int16 word_428C30;
// 438A42: using guessed type __int16 word_438A42;
// 43B460: using guessed type __int16 word_43B460;
// 4403E2: using guessed type __int16 word_4403E2;
// 4428B4: using guessed type int dword_4428B4;

//----- (0040B70D) --------------------------------------------------------
char sub_40B70D()
{
  int v1; // [esp+4h] [ebp-8h] BYREF
  char v2; // [esp+8h] [ebp-4h]

  v2 = 0;
  LOBYTE(v1) = 0;
  while ( (unsigned __int8)v1 != 255 && !v2 )
  {
    dword_427578 = 0;
    ++word_425298;
    byte_4252C8 = 0;
    byte_4252B4 = 0;
    if ( byte_425204 == 2 )
    {
      sub_401D4C(dword_427560, dword_434344);
      word_427570 = 0;
    }
    if ( word_42520C )
    {
      word_42520C = 0;
      v2 = -1;
    }
    else
    {
      v2 = sub_40BBE4();
      if ( !v2 )
      {
        switch ( byte_4252D8 )
        {
          case 0:
            if ( byte_4252D9 == 1 )
              goto LABEL_13;
            word_425208 = 4115;
            v2 = -1;
            break;
          case 2:
LABEL_13:
            v2 = sub_40C1CC();
            break;
          case 14:
          case 16:
            byte_4252B4 = -1;
            v2 = sub_40BF66();
            break;
          case 17:
            LOBYTE(v1) = -1;
            break;
          case 23:
            v2 = sub_40C31C();
            break;
          case 32:
            v2 = sub_40DFBB();
            break;
          case 33:
            v2 = sub_40E0BC();
            break;
          case -127:
            v2 = sub_40B940(&v1);
            break;
          default:
            word_425208 = 4115;
            v2 = -1;
            break;
        }
      }
    }
    if ( v2 )
      sub_401EBD(word_425208);
    if ( byte_425204 == 2 )
      sub_401E02();
  }
  return v2;
}
// 425204: using guessed type char byte_425204;
// 425208: using guessed type __int16 word_425208;
// 42520C: using guessed type __int16 word_42520C;
// 425298: using guessed type __int16 word_425298;
// 4252B4: using guessed type char byte_4252B4;
// 4252C8: using guessed type char byte_4252C8;
// 4252D8: using guessed type char byte_4252D8;
// 4252D9: using guessed type char byte_4252D9;
// 427560: using guessed type int dword_427560;
// 427570: using guessed type __int16 word_427570;
// 427578: using guessed type int dword_427578;
// 434344: using guessed type int dword_434344;

//----- (0040B940) --------------------------------------------------------
char __cdecl sub_40B940(_BYTE *a1)
{
  char v2; // [esp+8h] [ebp-4h]

  v2 = 0;
  switch ( byte_4252D9 )
  {
    case 0:
      v2 = sub_40CED8();
      break;
    case 1:
      v2 = sub_40C5B9(6u);
      break;
    case 2:
      v2 = sub_40C38E();
      if ( !v2 )
      {
        v2 = sub_40D7D6();
        if ( !v2 )
          sub_40C3C7();
      }
      break;
    case 3:
      v2 = sub_40C38E();
      if ( !v2 )
      {
        v2 = sub_40D73D(6u);
        if ( !v2 )
          sub_40C3C7();
      }
      break;
    case 4:
      *a1 = -1;
      break;
    case 5:
      v2 = sub_40D891();
      break;
    case 6:
      v2 = sub_40DA90();
      break;
    case 7:
      word_425208 = 4149;
      v2 = -1;
      break;
    case 19:
      if ( !word_43435E[(unsigned __int8)byte_4252C4] )
      {
        word_425208 = 4147;
        v2 = -1;
      }
      word_43435E[(unsigned __int8)byte_4252C4] = 0;
      *a1 = -1;
      break;
    case 20:
      if ( !word_43435E[(unsigned __int8)byte_4252C4] )
      {
        word_425208 = 4148;
        v2 = -1;
      }
      word_43435E[(unsigned __int8)byte_4252C4] = 0;
      *a1 = -1;
      break;
    default:
      return v2;
  }
  return v2;
}
// 425208: using guessed type __int16 word_425208;
// 4252C4: using guessed type char byte_4252C4;
// 4252D9: using guessed type char byte_4252D9;
// 43435E: using guessed type __int16 word_43435E[257];

//----- (0040BAF2) --------------------------------------------------------
char sub_40BAF2()
{
  char v1; // [esp+0h] [ebp-4h]

  v1 = 0;
  while ( byte_4252D8 == 5 && byte_4252D9 == 1 && !v1 )
  {
    v1 = sub_40A65D();
    if ( !v1 )
    {
      if ( byte_4252D8 || byte_4252D9 )
      {
        v1 = sub_407BA9(14, 0x1Du);
      }
      else if ( (unsigned __int8)byte_4252DF == 255 )
      {
        if ( dword_4252DA >= 1 && dword_4252DA <= 9 )
        {
          v1 = sub_407BA9(0, 0);
          if ( !v1 )
          {
            v1 = sub_40A65D();
            if ( !v1 )
              v1 = sub_407BA9(14, 0x1Du);
          }
        }
        else
        {
          word_425208 = 4098;
          v1 = -1;
        }
      }
      else
      {
        word_425208 = 4097;
        v1 = -1;
      }
    }
  }
  return v1;
}
// 425208: using guessed type __int16 word_425208;
// 4252D8: using guessed type char byte_4252D8;
// 4252D9: using guessed type char byte_4252D9;
// 4252DF: using guessed type char byte_4252DF;

//----- (0040BBE4) --------------------------------------------------------
char sub_40BBE4()
{
  char v1; // [esp+0h] [ebp-4h]

  v1 = sub_40BAF2();
  if ( !v1 )
  {
    dword_4252AC = -1;
    if ( byte_4252D8 == 14 && byte_4252D9 == 1 )
    {
      dword_4252B0 = dword_4252DA;
      dword_4252AC = dword_4252DA;
      v1 = sub_407BA9(14, 1u);
      if ( !v1 )
      {
        v1 = sub_40A65D();
        if ( !v1 )
          return sub_40BAF2();
      }
    }
    else
    {
      return sub_40BAF2();
    }
  }
  return v1;
}
// 4252AC: using guessed type int dword_4252AC;
// 4252B0: using guessed type int dword_4252B0;
// 4252D8: using guessed type char byte_4252D8;
// 4252D9: using guessed type char byte_4252D9;

//----- (0040BC76) --------------------------------------------------------
char __cdecl sub_40BC76(_DWORD *a1)
{
  char v2[4]; // [esp+4h] [ebp-8h] BYREF
  char v3; // [esp+8h] [ebp-4h]

  v3 = 0;
  v2[0] = 0;
  while ( 1 )
  {
    v3 = sub_40A65D();
    if ( byte_4252D8 == 14 && !byte_4252D9 )
      break;
    if ( byte_4252D8 == 17 )
      return 99;
    if ( word_425208 || word_43B460 )
      goto LABEL_16;
  }
  if ( !byte_425204 )
  {
    *a1 = dword_4252DA;
    sub_402486(dword_4252DA);
    ++dword_427574;
    dword_4407B8[2 * dword_427574] = dword_4252DA;
    dword_4407BC[2 * dword_427574] = 0;
    dword_4293C0[0] = (unsigned __int16)dword_4252DA;
    sub_4033C6(8);
    word_429E22 = 1;
  }
  word_4252FC = 0;
  if ( !dword_4252DA || dword_4252DA > 99999999 )
  {
    word_425208 = 0x8000;
    v3 = -1;
  }
  word_43B460 = 1;
  dword_4252B0 = dword_4252DA;
  dword_4252A8 = dword_4252DA;
  dword_4252A4 = dword_4252DA;
  if ( !v3 )
    v3 = sub_40A65D();
LABEL_16:
  if ( byte_425204 == 2 )
    sub_401D4C(dword_427560, dword_434344);
  byte_42529C = 0;
  ++word_425298;
  dword_427578 = 0;
  byte_4252B4 = 0;
  if ( !v3 )
  {
    v3 = sub_40BBE4();
    if ( !v3 )
    {
      switch ( byte_4252D8 )
      {
        case 0:
        case 2:
          v3 = sub_40C1CC();
          break;
        case 14:
        case 16:
          byte_4252B4 = -1;
          v3 = sub_40BF66();
          break;
        case 32:
          v3 = sub_40DFBB();
          break;
        case 33:
          v3 = sub_40E0BC();
          break;
        case -127:
          v3 = sub_40B940(v2);
          break;
        default:
          word_425208 = 4115;
          v3 = -1;
          break;
      }
    }
  }
  if ( v3 )
    sub_401EBD(word_425208);
  if ( byte_425204 == 2 )
    sub_401E02();
  return v3;
}
// 425204: using guessed type char byte_425204;
// 425208: using guessed type __int16 word_425208;
// 425298: using guessed type __int16 word_425298;
// 42529C: using guessed type char byte_42529C;
// 4252A4: using guessed type int dword_4252A4;
// 4252A8: using guessed type int dword_4252A8;
// 4252B0: using guessed type int dword_4252B0;
// 4252B4: using guessed type char byte_4252B4;
// 4252D8: using guessed type char byte_4252D8;
// 4252D9: using guessed type char byte_4252D9;
// 4252FC: using guessed type __int16 word_4252FC;
// 427560: using guessed type int dword_427560;
// 427574: using guessed type int dword_427574;
// 427578: using guessed type int dword_427578;
// 4293C0: using guessed type int dword_4293C0[24];
// 429E22: using guessed type __int16 word_429E22;
// 434344: using guessed type int dword_434344;
// 43B460: using guessed type __int16 word_43B460;
// 4407B8: using guessed type int dword_4407B8[];
// 4407BC: using guessed type int dword_4407BC[];
// 40BC76: using guessed type char var_8[4];

//----- (0040BF66) --------------------------------------------------------
char sub_40BF66()
{
  char v1; // [esp+0h] [ebp-4h]

  v1 = 0;
  byte_425354 = 0;
  while ( byte_4252D8 != 16 && !v1 )
  {
    if ( byte_4252D8 == 14 )
    {
      switch ( byte_4252D9 )
      {
        case 1:
          word_425208 = 4100;
          v1 = -1;
          break;
        case 27:
          v1 = sub_407BA9(14, 0x1Bu);
          if ( !v1 )
            v1 = sub_40A65D();
          break;
        case 28:
          v1 = sub_40A65D();
          if ( !v1 )
          {
            if ( byte_4252D8 == 14 )
            {
              byte_4252B8 = byte_4252D9;
              v1 = sub_40A65D();
              if ( !v1 )
              {
                v1 = sub_4061CF();
                if ( !v1 )
                {
                  byte_429380[(unsigned __int8)byte_425354++] = byte_4252B8;
                  byte_42534C = byte_4252B8;
                  v1 = sub_407BA9(14, 0x1Cu);
                }
              }
            }
            else
            {
              word_425208 = 4101;
              v1 = -1;
            }
          }
          break;
        case 30:
          byte_4252B8 = byte_4252BC;
          v1 = sub_40A65D();
          if ( !v1 )
          {
            v1 = sub_4061CF();
            if ( !v1 )
            {
              byte_429380[(unsigned __int8)byte_425354++] = byte_4252B8;
              byte_42534C = byte_4252B8;
              v1 = sub_407BA9(14, 0x1Cu);
            }
          }
          break;
        default:
          byte_4252B8 = byte_4252D9;
          v1 = sub_40A65D();
          if ( !v1 )
          {
            v1 = sub_406357();
            if ( !v1 )
              v1 = sub_407BA9(14, byte_4252B8);
          }
          break;
      }
    }
    else if ( byte_4252D8 == 5 && byte_4252D9 == 1 )
    {
      byte_4252B8 = 29;
      v1 = sub_40BAF2();
    }
    else
    {
      word_425208 = 4101;
      v1 = -1;
    }
  }
  byte_425354 = 0;
  if ( !v1 )
  {
    v1 = sub_407BA9(16, 0);
    if ( !v1 )
      word_42520C = sub_40A65D();
  }
  return v1;
}
// 425208: using guessed type __int16 word_425208;
// 42520C: using guessed type __int16 word_42520C;
// 4252B8: using guessed type char byte_4252B8;
// 4252BC: using guessed type char byte_4252BC;
// 4252D8: using guessed type char byte_4252D8;
// 4252D9: using guessed type char byte_4252D9;
// 42534C: using guessed type char byte_42534C;
// 425354: using guessed type char byte_425354;

//----- (0040C1CC) --------------------------------------------------------
char sub_40C1CC()
{
  char v1; // [esp+0h] [ebp-4h]

  v1 = sub_406150();
  if ( !v1 )
  {
    v1 = sub_407BA9(1, 0);
    if ( !v1 )
    {
      if ( byte_4252D8 == 9 )
      {
        v1 = sub_40A65D();
        if ( !v1 )
        {
          v1 = sub_40626B();
          if ( !v1 )
          {
            if ( byte_4252D8 == 16 )
            {
              v1 = sub_407BA9(9, 0);
              if ( !v1 )
                word_42520C = sub_40A65D();
            }
            else if ( byte_4252D8 == 14 && byte_4252D9 == 27 )
            {
              v1 = sub_407BA9(15, 0);
              if ( !v1 )
              {
                v1 = sub_40A65D();
                if ( !v1 )
                {
                  if ( byte_4252D8 == 16 )
                  {
                    v1 = sub_407BA9(9, 0);
                    if ( !v1 )
                      word_42520C = sub_40A65D();
                  }
                  else
                  {
                    word_425208 = 4102;
                    return -1;
                  }
                }
              }
            }
            else
            {
              word_425208 = 4102;
              return -1;
            }
          }
        }
      }
      else
      {
        word_425208 = 4103;
        return -1;
      }
    }
  }
  return v1;
}
// 425208: using guessed type __int16 word_425208;
// 42520C: using guessed type __int16 word_42520C;
// 4252D8: using guessed type char byte_4252D8;
// 4252D9: using guessed type char byte_4252D9;

//----- (0040C31C) --------------------------------------------------------
char sub_40C31C()
{
  char v1; // [esp+0h] [ebp-4h]

  v1 = sub_40A65D();
  if ( !v1 )
  {
    v1 = sub_4061CF();
    if ( !v1 )
    {
      if ( byte_4252D8 == 16 )
      {
        v1 = sub_407BA9(23, 0);
        if ( !v1 )
          word_42520C = sub_40A65D();
      }
      else
      {
        word_425208 = 4135;
        return -1;
      }
    }
  }
  return v1;
}
// 425208: using guessed type __int16 word_425208;
// 42520C: using guessed type __int16 word_42520C;
// 4252D8: using guessed type char byte_4252D8;

//----- (0040C38E) --------------------------------------------------------
char sub_40C38E()
{
  char v1; // [esp+0h] [ebp-4h]

  v1 = 0;
  if ( (unsigned __int8)byte_42529C >= 3u )
  {
    word_425208 = 4104;
    return -1;
  }
  else
  {
    ++byte_42529C;
  }
  return v1;
}
// 425208: using guessed type __int16 word_425208;
// 42529C: using guessed type char byte_42529C;

//----- (0040C3C7) --------------------------------------------------------
char sub_40C3C7()
{
  return --byte_42529C;
}
// 42529C: using guessed type char byte_42529C;

//----- (0040C3D8) --------------------------------------------------------
char __cdecl sub_40C3D8(_BYTE *a1)
{
  char v2; // [esp+0h] [ebp-8h]
  char v3; // [esp+0h] [ebp-8h]
  char v4; // [esp+4h] [ebp-4h]
  char v5; // [esp+4h] [ebp-4h]

  v2 = sub_40626B();
  if ( !v2 )
  {
    if ( (unsigned __int8)byte_4252D8 == 128 )
    {
      *a1 = byte_4252D9;
      v3 = sub_40A65D();
      if ( v3 )
        return v3;
      v2 = sub_40626B();
      if ( v2 )
        return v2;
    }
    else if ( (unsigned __int8)byte_4252D8 == 129 && byte_4252D9 == 17 )
    {
      v4 = byte_4252D9;
      *a1 = 1;
      byte_4252D8 = 0;
      byte_4252D9 = 0;
      dword_4252DA = 0;
      byte_4252DF = -1;
      v2 = sub_407BA9(0, 0);
      if ( v2 )
        return v2;
      byte_4252D8 = -127;
      byte_4252D9 = v4;
    }
    else if ( (unsigned __int8)byte_4252D8 == 129 && byte_4252D9 == 18 )
    {
      v5 = byte_4252D9;
      *a1 = 1;
      byte_4252D8 = 0;
      byte_4252D9 = 0;
      dword_4252DA = 0;
      byte_4252DF = -1;
      v2 = sub_407BA9(0, 0);
      if ( v2 )
        return v2;
      byte_4252D8 = -127;
      byte_4252D9 = v5;
    }
    else if ( (unsigned __int8)byte_4252D8 == 131 )
    {
      *a1 = 1;
      byte_4252D8 = 0;
      byte_4252D9 = 0;
      dword_4252DA = 0;
      byte_4252DF = -1;
      v2 = sub_407BA9(0, 0);
      if ( v2 )
        return v2;
      byte_4252D8 = -125;
    }
    else
    {
      word_425208 = 4105;
      return -1;
    }
  }
  return v2;
}
// 425208: using guessed type __int16 word_425208;
// 4252D8: using guessed type char byte_4252D8;
// 4252D9: using guessed type char byte_4252D9;
// 4252DF: using guessed type char byte_4252DF;

//----- (0040C5B9) --------------------------------------------------------
char __cdecl sub_40C5B9(unsigned __int8 a1)
{
  char v2; // [esp+0h] [ebp-4h]
  char v3; // [esp+0h] [ebp-4h]
  char v4; // [esp+0h] [ebp-4h]

  if ( a1 == 22 )
  {
    v2 = sub_40B36F();
    if ( v2 )
      return v2;
    v3 = sub_40A65D();
    if ( !v3 )
    {
      if ( !sub_4061CF() )
      {
        if ( byte_4252D8 == 16 )
        {
          v4 = sub_407BA9(10, 6u);
          if ( !v4 )
            v4 = sub_40A65D();
          if ( v4 )
            return v4;
        }
        else
        {
          word_425208 = 4108;
        }
      }
      v3 = sub_40B36F();
      if ( v3 )
        return v3;
      --byte_4252C4;
    }
  }
  else
  {
    v3 = sub_40A65D();
    if ( !v3 )
    {
      v3 = sub_4061CF();
      if ( !v3 )
      {
        if ( byte_4252D8 == 16 )
        {
          v3 = sub_407BA9(10, a1);
          if ( !v3 )
            word_42520C = sub_40A65D();
        }
        else
        {
          word_425208 = 4108;
          return -1;
        }
      }
    }
  }
  return v3;
}
// 425208: using guessed type __int16 word_425208;
// 42520C: using guessed type __int16 word_42520C;
// 4252C4: using guessed type char byte_4252C4;
// 4252D8: using guessed type char byte_4252D8;

//----- (0040C6E7) --------------------------------------------------------
char sub_40C6E7()
{
  char result; // al
  char v1; // [esp+0h] [ebp-4h]
  char v2; // [esp+0h] [ebp-4h]
  char v3; // [esp+0h] [ebp-4h]
  char v4; // [esp+0h] [ebp-4h]
  char v5; // [esp+0h] [ebp-4h]
  char v6; // [esp+0h] [ebp-4h]
  char v7; // [esp+0h] [ebp-4h]
  char v8; // [esp+0h] [ebp-4h]
  char v9; // [esp+0h] [ebp-4h]
  char v10; // [esp+0h] [ebp-4h]
  char v11; // [esp+0h] [ebp-4h]
  char v12; // [esp+0h] [ebp-4h]
  char v13; // [esp+0h] [ebp-4h]
  char v14; // [esp+0h] [ebp-4h]
  char v15; // [esp+0h] [ebp-4h]
  char v16; // [esp+0h] [ebp-4h]
  char v17; // [esp+0h] [ebp-4h]
  char v18; // [esp+0h] [ebp-4h]
  char v19; // [esp+0h] [ebp-4h]
  char v20; // [esp+0h] [ebp-4h]
  char v21; // [esp+0h] [ebp-4h]
  char v22; // [esp+0h] [ebp-4h]
  char v23; // [esp+0h] [ebp-4h]
  char v24; // [esp+0h] [ebp-4h]
  char v25; // [esp+0h] [ebp-4h]
  char v26; // [esp+0h] [ebp-4h]
  char v27; // [esp+0h] [ebp-4h]
  char v28; // [esp+0h] [ebp-4h]
  char v29; // [esp+0h] [ebp-4h]

  result = byte_4252D8;
  if ( (unsigned __int8)byte_4252D8 == 129 && byte_4252D9 == 7 )
  {
    v1 = sub_40B36F();
    if ( v1 )
      return v1;
    v2 = sub_40A65D();
    if ( v2 )
      return v2;
    if ( byte_4252D8 == 16 )
    {
      v3 = sub_40A65D();
      if ( v3 )
        return v3;
      word_43435E[(unsigned __int8)byte_4252C4] = 1;
      v4 = sub_40B70D();
      if ( v4 )
        return v4;
      if ( byte_4252D9 == 19 )
      {
        sub_40B33C();
        v5 = sub_40B2D6();
        if ( v5 )
          return v5;
        v6 = sub_407BA9(22, 6u);
        if ( v6 )
          return v6;
        v7 = sub_40B36F();
        if ( v7 )
          return v7;
        v8 = sub_40A65D();
        if ( v8 )
          return v8;
        if ( byte_4252D8 == 16 )
        {
          v9 = sub_40A65D();
          if ( v9 )
            return v9;
          if ( byte_425204 == 2 )
          {
            sub_401D4C(dword_427560, dword_434344);
            word_427570 = 0;
          }
          word_43435E[(unsigned __int8)byte_4252C4] = 1;
          v10 = sub_40B70D();
          if ( v10 )
            return v10;
          if ( byte_4252D9 != 20 )
          {
            word_425208 = 4144;
            return -1;
          }
          v11 = sub_40B36F();
          if ( v11 )
            return v11;
          --byte_4252C4;
          v12 = sub_40A65D();
          if ( v12 )
            return v12;
          if ( byte_4252D8 != 16 )
          {
            word_425208 = 4144;
            return -1;
          }
          return sub_40A65D();
        }
        if ( byte_425204 == 2 )
        {
          sub_401D4C(dword_427560, dword_434344);
          word_427570 = 0;
        }
        v13 = sub_40C1CC();
        if ( v13 )
        {
          return v13;
        }
        else
        {
          v14 = sub_40B36F();
          result = v14;
          if ( v14 )
            return v14;
          else
            --byte_4252C4;
        }
      }
      else if ( byte_4252D9 == 20 )
      {
        v15 = sub_40B36F();
        if ( v15 )
        {
          return v15;
        }
        else
        {
          --byte_4252C4;
          v16 = sub_40A65D();
          if ( v16 )
          {
            return v16;
          }
          else if ( byte_4252D8 == 16 )
          {
            word_42520C = sub_40A65D();
            return 0;
          }
          else
          {
            word_425208 = 4144;
            return -1;
          }
        }
      }
      else
      {
        word_425208 = 4144;
        return -1;
      }
    }
    else
    {
      v17 = sub_40C1CC();
      if ( v17 )
        return v17;
      if ( byte_4252D9 == 19 )
      {
        sub_40B33C();
        v18 = sub_40B2D6();
        if ( v18 )
          return v18;
        v19 = sub_407BA9(22, 6u);
        if ( v19 )
          return v19;
        v20 = sub_40B36F();
        if ( v20 )
          return v20;
        v21 = sub_40A65D();
        if ( v21 )
          return v21;
        if ( byte_4252D8 == 16 )
        {
          v22 = sub_40A65D();
          if ( v22 )
            return v22;
          if ( byte_425204 == 2 )
          {
            sub_401D4C(dword_427560, dword_434344);
            word_427570 = 0;
          }
          word_43435E[(unsigned __int8)byte_4252C4] = 1;
          v23 = sub_40B70D();
          if ( v23 )
            return v23;
          if ( byte_4252D9 != 20 )
          {
            word_425208 = 4144;
            return -1;
          }
          v24 = sub_40B36F();
          if ( v24 )
            return v24;
          --byte_4252C4;
          v25 = sub_40A65D();
          if ( v25 )
            return v25;
          if ( byte_4252D8 != 16 )
          {
            word_425208 = 4144;
            return -1;
          }
          return sub_40A65D();
        }
        if ( byte_425204 == 2 )
        {
          sub_401D4C(dword_427560, dword_434344);
          word_427570 = 0;
        }
        v26 = sub_40C1CC();
        if ( v26 )
        {
          return v26;
        }
        else
        {
          result = sub_40B36F();
          if ( !result )
            --byte_4252C4;
        }
      }
      else if ( byte_4252D9 == 20 )
      {
        v27 = sub_40B36F();
        if ( v27 )
          return v27;
        --byte_4252C4;
        v28 = sub_40A65D();
        if ( v28 )
          return v28;
        if ( byte_4252D8 == 16 )
          return sub_40A65D();
        word_425208 = 4144;
        return -1;
      }
      else
      {
        v29 = sub_40B36F();
        result = v29;
        if ( v29 )
          return v29;
        else
          --byte_4252C4;
      }
    }
  }
  return result;
}
// 40B70D: using guessed type int sub_40B70D(void);
// 425204: using guessed type char byte_425204;
// 425208: using guessed type __int16 word_425208;
// 42520C: using guessed type __int16 word_42520C;
// 4252C4: using guessed type char byte_4252C4;
// 4252D8: using guessed type char byte_4252D8;
// 4252D9: using guessed type char byte_4252D9;
// 427560: using guessed type int dword_427560;
// 427570: using guessed type __int16 word_427570;
// 434344: using guessed type int dword_434344;
// 43435E: using guessed type __int16 word_43435E[257];

//----- (0040CD04) --------------------------------------------------------
char sub_40CD04()
{
  char v1; // [esp+0h] [ebp-4h]
  char v2; // [esp+0h] [ebp-4h]
  char v3; // [esp+0h] [ebp-4h]
  char v4; // [esp+0h] [ebp-4h]
  char v5; // [esp+0h] [ebp-4h]
  char v6; // [esp+0h] [ebp-4h]
  char v7; // [esp+0h] [ebp-4h]
  char v8; // [esp+0h] [ebp-4h]
  char v9; // [esp+0h] [ebp-4h]
  char v10; // [esp+0h] [ebp-4h]

  v1 = 0;
  if ( (unsigned __int8)byte_4252D8 == 129 && byte_4252D9 == 19 )
  {
    v2 = sub_40B36F();
    if ( v2 )
      return v2;
    sub_40B33C();
    v3 = sub_40B2D6();
    if ( v3 )
      return v3;
    v4 = sub_407BA9(22, 6u);
    if ( v4 )
      return v4;
    v5 = sub_40B36F();
    if ( v5 )
      return v5;
    v1 = sub_40A65D();
    if ( !v1 )
    {
      if ( byte_4252D8 == 16 )
      {
        v6 = sub_40A65D();
        if ( v6 )
          return v6;
        word_43435E[(unsigned __int8)byte_4252C4] = 1;
        v7 = sub_40B70D();
        if ( v7 )
          return v7;
        if ( byte_4252D9 != 20 )
        {
          word_425208 = 4144;
          return -1;
        }
        v8 = sub_40B36F();
        if ( v8 )
          return v8;
        --byte_4252C4;
        v9 = sub_40A65D();
        if ( v9 )
          return v9;
        if ( byte_4252D8 != 16 )
        {
          word_425208 = 4144;
          return -1;
        }
        v1 = sub_40A65D();
        if ( v1 )
          return v1;
      }
      else
      {
        v10 = sub_40C1CC();
        if ( v10 )
          return v10;
        v1 = sub_40B36F();
        if ( v1 )
          return v1;
        --byte_4252C4;
      }
    }
  }
  return v1;
}
// 40B70D: using guessed type int sub_40B70D(void);
// 425208: using guessed type __int16 word_425208;
// 4252C4: using guessed type char byte_4252C4;
// 4252D8: using guessed type char byte_4252D8;
// 4252D9: using guessed type char byte_4252D9;
// 43435E: using guessed type __int16 word_43435E[257];

//----- (0040CED8) --------------------------------------------------------
char sub_40CED8()
{
  char v1; // al
  char v2; // al
  unsigned __int8 j; // [esp+0h] [ebp-10h]
  unsigned __int8 i; // [esp+0h] [ebp-10h]
  int v5; // [esp+4h] [ebp-Ch] BYREF
  unsigned __int8 v6[4]; // [esp+8h] [ebp-8h] BYREF
  char v7; // [esp+Ch] [ebp-4h]

  v7 = 0;
  if ( (unsigned __int16)++word_4252C0 > 0x7D0u )
  {
    v7 = -1;
    word_425208 = 4133;
    return -1;
  }
  if ( (unsigned __int8)++byte_4252C4 > 0xAu )
  {
    v7 = -1;
    word_425208 = 4136;
    return -1;
  }
  word_42907E[(unsigned __int8)byte_4252C4] = 3 * (word_4252C0 - 1) + 1;
  v7 = sub_40A65D();
  if ( v7 )
    return v7;
  v7 = sub_40C3D8(v6);
  if ( v7 )
    return v7;
  if ( (unsigned __int8)byte_4252D8 != 131 )
  {
    if ( (unsigned __int8)byte_4252D8 != 129 || byte_4252D9 != 17 )
    {
      if ( (unsigned __int8)byte_4252D8 != 129 || byte_4252D9 != 18 )
      {
        word_425208 = 4107;
        return -1;
      }
      v7 = sub_40B2D6();
      if ( v7 )
        return v7;
      v6[0] ^= 1u;
      v7 = sub_407BA9(22, v6[0]);
      if ( v7 )
        return v7;
      for ( i = 0; ; ++i )
      {
        if ( v7 )
          return v7;
        if ( i > 2u )
        {
          v7 = -1;
          word_425208 = 4145;
          return -1;
        }
        v7 = sub_40A65D();
        if ( !v7 )
        {
          v7 = sub_40C3D8(v6);
          if ( !v7 )
          {
            if ( (unsigned __int8)byte_4252D8 == 131 )
            {
              sub_40B33C();
              v7 = sub_40B2D6();
              if ( v7 )
                return v7;
              v7 = sub_407BA9(22, v6[0]);
              if ( v7 )
                return v7;
              v2 = sub_40A65D();
              v7 = v2;
              if ( v2 )
                return v7;
              if ( (unsigned __int8)byte_4252D8 != 129 )
              {
                word_425208 = 4106;
                return -1;
              }
              switch ( byte_4252D9 )
              {
                case 1:
                  v6[0] = 22;
                  v7 = sub_40C5B9(0x16u);
                  if ( !v7 )
                    return v7;
                  return v7;
                case 7:
                  v7 = sub_40C6E7();
                  if ( !v7 )
                    return v7;
                  return v7;
                case 19:
                  v7 = sub_40CD04();
                  if ( !v7 )
                  {
                    word_425208 = 4106;
                    return -1;
                  }
                  return v7;
                default:
                  return v7;
              }
            }
            if ( byte_4252D9 == 18 )
            {
              v7 = sub_40B2D6();
              if ( v7 )
                return v7;
              v6[0] ^= 1u;
              v7 = sub_407BA9(22, v6[0]);
              if ( v7 )
                return v7;
            }
            else
            {
              if ( byte_4252D9 == 17 )
              {
                v7 = -1;
                word_425208 = 4137;
                return -1;
              }
              word_425208 = 4107;
              v7 = -1;
            }
          }
        }
      }
    }
    v7 = sub_40B2D6();
    if ( v7 )
      return v7;
    v7 = sub_40B47C(&v5);
    if ( v7 )
      return v7;
    sub_40B33C();
    v7 = sub_40B2D6();
    if ( v7 )
      return v7;
    v7 = sub_407BA9(22, v6[0]);
    if ( v7 )
      return v7;
    for ( j = 0; ; ++j )
    {
      if ( j > 2u )
      {
        v7 = -1;
        word_425208 = 4145;
        return -1;
      }
      if ( v7 )
        return v7;
      v7 = sub_40A65D();
      if ( !v7 )
      {
        v7 = sub_40C3D8(v6);
        if ( !v7 )
        {
          if ( (unsigned __int8)byte_4252D8 == 131 )
          {
            v7 = sub_40B2D6();
            if ( v7 )
              return v7;
            v7 = sub_407BA9(22, v6[0]);
            if ( v7 )
              return v7;
            v1 = sub_40A65D();
            v7 = v1;
            if ( v1 )
              return v7;
            if ( (unsigned __int8)byte_4252D8 != 129 )
            {
              word_425208 = 4106;
              return -1;
            }
            switch ( byte_4252D9 )
            {
              case 1:
                v6[0] = 22;
                v7 = sub_40C5B9(0x16u);
                if ( v7 )
                  return v7;
                return v7;
              case 7:
                v7 = sub_40C6E7();
                if ( !v7 )
                  return v7;
                return v7;
              case 19:
                v7 = sub_40CD04();
                if ( !v7 )
                {
                  word_425208 = 4106;
                  return -1;
                }
                return v7;
              default:
                return v7;
            }
          }
          if ( byte_4252D9 == 17 )
          {
            v7 = sub_40B2D6();
            if ( v7 )
              return v7;
            v7 = sub_407BA9(22, v6[0]);
            if ( v7 )
              return v7;
          }
          else
          {
            if ( byte_4252D9 == 18 )
            {
              v7 = -1;
              word_425208 = 4137;
              return -1;
            }
            word_425208 = 4107;
            v7 = -1;
          }
        }
      }
    }
  }
  v7 = sub_40B2D6();
  if ( v7 )
    return v7;
  v7 = sub_40B47C(&v5);
  if ( v7 )
    return v7;
  sub_40B33C();
  v7 = sub_40B2D6();
  if ( v7 )
    return v7;
  v7 = sub_40A65D();
  if ( v7 )
    return v7;
  if ( (unsigned __int8)byte_4252D8 != 129 )
  {
    word_425208 = 4106;
    return -1;
  }
  if ( byte_4252D9 != 1 )
  {
    if ( byte_4252D9 == 7 )
    {
      v7 = sub_407BA9(22, v6[0]);
      if ( v7 )
        return v7;
      v7 = sub_40C6E7();
      if ( v7 )
        return v7;
    }
    else if ( byte_4252D9 == 19 )
    {
      v7 = sub_407BA9(22, v6[0]);
      if ( v7 )
        return v7;
      v7 = sub_40CD04();
      if ( v7 )
        return v7;
    }
    else
    {
      word_425208 = 4106;
      return -1;
    }
    return v7;
  }
  v7 = sub_40C5B9(v6[0]);
  if ( v7 )
    return v7;
  v7 = sub_40B36F();
  if ( v7 )
    return v7;
  v7 = sub_40B47C(&v5);
  if ( v7 )
    return v7;
  v7 = sub_40B36F();
  if ( !v7 )
  {
    --byte_4252C4;
    return v7;
  }
  return v7;
}
// 425208: using guessed type __int16 word_425208;
// 4252C0: using guessed type __int16 word_4252C0;
// 4252C4: using guessed type char byte_4252C4;
// 4252D8: using guessed type char byte_4252D8;
// 4252D9: using guessed type char byte_4252D9;
// 42907E: using guessed type __int16 word_42907E[257];
// 40CED8: using guessed type unsigned __int8 var_8[4];

//----- (0040D675) --------------------------------------------------------
char __cdecl sub_40D675(unsigned __int8 a1)
{
  char v2; // [esp+0h] [ebp-4h]

  v2 = sub_40A65D();
  if ( !v2 )
  {
    if ( byte_4252D8 == 16 )
    {
      v2 = sub_407BA9(12, a1);
      if ( !v2 )
        word_42520C = sub_40A65D();
    }
    else
    {
      word_425208 = 4109;
      return -1;
    }
  }
  return v2;
}
// 425208: using guessed type __int16 word_425208;
// 42520C: using guessed type __int16 word_42520C;
// 4252D8: using guessed type char byte_4252D8;

//----- (0040D6D9) --------------------------------------------------------
char __cdecl sub_40D6D9(unsigned __int8 a1)
{
  char v2; // [esp+0h] [ebp-4h]

  v2 = sub_40A65D();
  if ( !v2 )
  {
    if ( byte_4252D8 == 16 )
    {
      v2 = sub_407BA9(13, a1);
      if ( !v2 )
        word_42520C = sub_40A65D();
    }
    else
    {
      word_425208 = 4110;
      return -1;
    }
  }
  return v2;
}
// 425208: using guessed type __int16 word_425208;
// 42520C: using guessed type __int16 word_42520C;
// 4252D8: using guessed type char byte_4252D8;

//----- (0040D73D) --------------------------------------------------------
char __cdecl sub_40D73D(unsigned __int8 a1)
{
  char v2; // [esp+0h] [ebp-8h]
  char v3; // [esp+4h] [ebp-4h]

  v2 = dword_4252DA;
  v3 = sub_40D675(a1);
  if ( !v3 )
  {
    v3 = sub_40B70D();
    if ( !v3 )
    {
      if ( (unsigned __int8)byte_4252D8 == 129 && byte_4252D9 == 4 )
      {
        if ( v2 == (char)dword_4252DA )
        {
          return sub_40D6D9(a1);
        }
        else
        {
          word_425208 = 4111;
          return -1;
        }
      }
      else
      {
        word_425208 = 4112;
        return -1;
      }
    }
  }
  return v3;
}
// 40B70D: using guessed type int sub_40B70D(void);
// 425208: using guessed type __int16 word_425208;
// 4252D8: using guessed type char byte_4252D8;
// 4252D9: using guessed type char byte_4252D9;

//----- (0040D7D6) --------------------------------------------------------
char sub_40D7D6()
{
  unsigned __int8 v1[4]; // [esp+0h] [ebp-8h] BYREF
  char v2; // [esp+4h] [ebp-4h]

  v2 = sub_407BA9(11, 0);
  if ( !v2 )
  {
    v2 = sub_40A65D();
    if ( !v2 )
    {
      v2 = sub_40C3D8(v1);
      if ( !v2 )
      {
        if ( (unsigned __int8)byte_4252D8 == 131 )
        {
          v2 = sub_40A65D();
          if ( !v2 )
          {
            if ( (unsigned __int8)byte_4252D8 == 129 && byte_4252D9 == 3 )
            {
              return sub_40D73D(v1[0]);
            }
            else
            {
              word_425208 = 4113;
              return -1;
            }
          }
        }
        else
        {
          word_425208 = 4114;
          return -1;
        }
      }
    }
  }
  return v2;
}
// 425208: using guessed type __int16 word_425208;
// 4252D8: using guessed type char byte_4252D8;
// 4252D9: using guessed type char byte_4252D9;
// 40D7D6: using guessed type unsigned __int8 var_8[4];

//----- (0040D891) --------------------------------------------------------
char sub_40D891()
{
  char v1; // [esp+0h] [ebp-Ch]
  unsigned __int8 v2; // [esp+4h] [ebp-8h]
  char v3; // [esp+8h] [ebp-4h]

  v3 = sub_40A65D();
  if ( !v3 )
  {
    if ( byte_4252D8 && byte_4252D8 == 2 )
    {
      word_425208 = 4120;
      return -1;
    }
    else
    {
      v1 = byte_4252D8;
      v2 = byte_4252D9;
      v3 = sub_4061CF();
      if ( !v3 )
      {
        if ( (unsigned __int8)byte_4252D8 == 130 )
        {
          return sub_40D93B(v1, v2);
        }
        else
        {
          word_425208 = 4120;
          return -1;
        }
      }
    }
  }
  return v3;
}
// 425208: using guessed type __int16 word_425208;
// 4252D8: using guessed type char byte_4252D8;
// 4252D9: using guessed type char byte_4252D9;

//----- (0040D93B) --------------------------------------------------------
char __cdecl sub_40D93B(char a1, unsigned __int8 a2)
{
  char v3; // [esp+0h] [ebp-4h]

  while ( 1 )
  {
    byte_4252D8 = -127;
    byte_4252D9 = 16;
    v3 = sub_40A65D();
    if ( !v3 )
    {
      if ( byte_4252D8 != 14 || byte_4252D9 != 27 )
      {
        word_425208 = 4120;
        v3 = -1;
        goto LABEL_18;
      }
      v3 = sub_407BA9(18, 0);
      if ( !v3 )
      {
        v3 = sub_40A65D();
        if ( !v3 )
        {
          if ( (unsigned __int8)byte_4252D8 != 131 )
          {
            if ( (unsigned __int8)byte_4252D8 == 133 )
            {
              if ( a1 || a2 == 1 )
              {
                word_425208 = 4120;
                v3 = -1;
              }
              else
              {
                ++dword_4252DA;
                byte_4252DF = -1;
                v3 = sub_407BA9(0, a2);
              }
            }
            else
            {
              word_425208 = 4120;
              v3 = -1;
            }
            goto LABEL_18;
          }
          v3 = sub_40A65D();
          if ( !v3 )
            break;
        }
      }
    }
LABEL_18:
    if ( v3 )
      return v3;
  }
  if ( byte_4252D8 != 16 )
  {
    word_425208 = 4120;
    v3 = -1;
    goto LABEL_18;
  }
  word_42520C = sub_40A65D();
  return 0;
}
// 425208: using guessed type __int16 word_425208;
// 42520C: using guessed type __int16 word_42520C;
// 4252D8: using guessed type char byte_4252D8;
// 4252D9: using guessed type char byte_4252D9;
// 4252DF: using guessed type char byte_4252DF;

//----- (0040DA90) --------------------------------------------------------
char sub_40DA90()
{
  char v1; // [esp+0h] [ebp-4h]

  v1 = sub_40A65D();
  if ( !v1 )
  {
    if ( (unsigned __int8)byte_4252D8 == 130 )
    {
      v1 = sub_40DB3A();
      if ( !v1 )
      {
        if ( (unsigned __int8)byte_4252D8 == 131 )
        {
          v1 = sub_40A65D();
          if ( !v1 )
          {
            if ( byte_4252D8 == 16 )
            {
              word_42520C = sub_40A65D();
            }
            else
            {
              word_425208 = 4121;
              return -1;
            }
          }
        }
        else
        {
          word_425208 = 4121;
          return -1;
        }
      }
    }
    else
    {
      word_425208 = 4121;
      return -1;
    }
  }
  return v1;
}
// 425208: using guessed type __int16 word_425208;
// 42520C: using guessed type __int16 word_42520C;
// 4252D8: using guessed type char byte_4252D8;

//----- (0040DB3A) --------------------------------------------------------
char sub_40DB3A()
{
  char v1; // [esp+0h] [ebp-4h]

  do
  {
    v1 = sub_40A65D();
    if ( !v1 )
    {
      if ( byte_4252D8 == 14 && byte_4252D9 == 28 )
      {
        v1 = sub_40A65D();
        if ( !v1 )
        {
          if ( byte_4252D8 == 14 )
          {
            byte_4252B8 = byte_4252D9;
            v1 = sub_40A65D();
            if ( !v1 )
            {
              if ( byte_4252D8 == 9 )
              {
                v1 = sub_40A65D();
                if ( !v1 )
                {
                  if ( byte_4252D8 == 14 )
                  {
                    v1 = sub_407BA9(19, byte_4252B8);
                    if ( !v1 )
                      v1 = sub_40A65D();
                  }
                  else
                  {
                    word_425208 = 4121;
                    v1 = -1;
                  }
                }
              }
              else
              {
                word_425208 = 4121;
                v1 = -1;
              }
            }
          }
          else
          {
            word_425208 = 4121;
            v1 = -1;
          }
        }
      }
      else
      {
        word_425208 = 4121;
        v1 = -1;
      }
    }
  }
  while ( (unsigned __int8)byte_4252D8 == 133 && !v1 );
  return v1;
}
// 425208: using guessed type __int16 word_425208;
// 4252B8: using guessed type char byte_4252B8;
// 4252D8: using guessed type char byte_4252D8;
// 4252D9: using guessed type char byte_4252D9;

//----- (0040DC5D) --------------------------------------------------------
char __cdecl sub_40DC5D(char a1)
{
  unsigned __int8 v2; // [esp+0h] [ebp-Ch]
  char v3; // [esp+4h] [ebp-8h]
  char v4; // [esp+8h] [ebp-4h]

  v4 = sub_40A65D();
  if ( !v4 )
  {
    if ( (unsigned __int8)byte_4252D8 == 130 )
    {
      if ( a1 == 2 )
        v2 = 4;
      else
        v2 = 5;
      v3 = byte_4252F4;
      while ( 1 )
      {
        byte_4252F4 = 0;
        byte_4252D8 = 32;
        byte_4252D9 = -126;
        v4 = sub_40A65D();
        if ( v4 )
          break;
        while ( byte_4252D8 != 14 && (unsigned __int8)byte_4252D8 != 131 )
        {
          v4 = sub_40DDC3(a1);
          if ( v4 )
            goto LABEL_22;
          byte_425304 = 0;
        }
        if ( (unsigned __int8)byte_4252D8 == 131 )
        {
          v4 = sub_40DEDE(a1);
          break;
        }
        if ( byte_4252D9 != 27 )
          goto LABEL_18;
        v4 = sub_407BA9(20, v2);
        if ( v4 )
          break;
        word_4252FC = 0;
        byte_425304 = 0;
      }
    }
    else
    {
LABEL_18:
      if ( a1 == 2 )
        word_425208 = 4124;
      else
        word_425208 = 4125;
      v4 = -1;
    }
  }
LABEL_22:
  byte_4252F4 = v3;
  byte_425304 = -1;
  return v4;
}
// 40DDB0: variable 'v3' is possibly undefined
// 425208: using guessed type __int16 word_425208;
// 4252D8: using guessed type char byte_4252D8;
// 4252D9: using guessed type char byte_4252D9;
// 4252F4: using guessed type char byte_4252F4;
// 4252FC: using guessed type __int16 word_4252FC;
// 425304: using guessed type char byte_425304;

//----- (0040DDC3) --------------------------------------------------------
char __cdecl sub_40DDC3(char a1)
{
  char v1; // al
  char v3; // [esp+4h] [ebp-4h]

  if ( byte_4252D8 || byte_4252D9 != 1 )
    goto LABEL_17;
  v3 = sub_4061CF();
  if ( v3 )
    return v3;
  if ( (unsigned __int8)byte_4252D8 != 130 )
    goto LABEL_17;
  v3 = sub_40A65D();
  if ( v3 )
    return v3;
  if ( byte_4252D8 || byte_4252D9 )
    goto LABEL_17;
  v3 = sub_4061CF();
  if ( !v3 )
  {
    v1 = a1 == 2 ? sub_407BA9(20, 6u) : sub_407BA9(20, 7u);
    v3 = v1;
    if ( !v1 )
    {
      if ( (unsigned __int8)byte_4252D8 == 131 )
      {
        byte_4252D8 = 32;
        byte_4252D9 = -126;
        return sub_40A65D();
      }
LABEL_17:
      if ( a1 == 2 )
        word_425208 = 4124;
      else
        word_425208 = 4125;
      return -1;
    }
  }
  return v3;
}
// 425208: using guessed type __int16 word_425208;
// 4252D8: using guessed type char byte_4252D8;
// 4252D9: using guessed type char byte_4252D9;

//----- (0040DEDE) --------------------------------------------------------
char __cdecl sub_40DEDE(char a1)
{
  char v1; // al
  unsigned __int16 v3; // [esp+4h] [ebp-8h] BYREF
  char v4; // [esp+8h] [ebp-4h]

  v4 = sub_40A65D();
  if ( !v4 )
  {
    if ( byte_4252D8 != 16
      || (v3 = 39, sub_4010A0(&v3), byte_4252DE = 0, (v4 = sub_408180(v3)) != 0)
      || (a1 != 2 ? (v1 = sub_407BA9(20, 5u)) : (v1 = sub_407BA9(20, 4u)), (v4 = v1) != 0) )
    {
      if ( a1 == 2 )
        word_425208 = 4124;
      else
        word_425208 = 4125;
      return -1;
    }
    else
    {
      word_4252FC = 0;
      word_42520C = sub_40A65D();
    }
  }
  return v4;
}
// 425208: using guessed type __int16 word_425208;
// 42520C: using guessed type __int16 word_42520C;
// 4252D8: using guessed type char byte_4252D8;
// 4252DE: using guessed type char byte_4252DE;
// 4252FC: using guessed type __int16 word_4252FC;

//----- (0040DFBB) --------------------------------------------------------
char sub_40DFBB()
{
  char v1; // [esp+4h] [ebp-4h]

  v1 = 0;
  switch ( byte_4252D9 )
  {
    case 0:
      v1 = sub_407BA9(20, 2u);
      if ( !v1 )
      {
        v1 = sub_40A65D();
        if ( !v1 )
        {
          if ( byte_4252D8 == 16 )
            goto LABEL_5;
          word_425208 = 4122;
          v1 = -1;
        }
      }
      break;
    case 1:
      v1 = sub_407BA9(20, 3u);
      if ( !v1 )
      {
        v1 = sub_40A65D();
        if ( !v1 )
        {
          if ( byte_4252D8 == 16 )
          {
LABEL_5:
            word_42520C = sub_40A65D();
          }
          else
          {
            word_425208 = 4123;
            v1 = -1;
          }
        }
      }
      break;
    case 2:
    case 3:
      v1 = sub_40DC5D(byte_4252D9);
      break;
    default:
      return v1;
  }
  return v1;
}
// 425208: using guessed type __int16 word_425208;
// 42520C: using guessed type __int16 word_42520C;
// 4252D8: using guessed type char byte_4252D8;
// 4252D9: using guessed type char byte_4252D9;

//----- (0040E0BC) --------------------------------------------------------
char sub_40E0BC()
{
  unsigned __int8 v1; // [esp+0h] [ebp-8h]
  char v2; // [esp+4h] [ebp-4h]

  v1 = byte_4252D9;
  v2 = sub_40A65D();
  if ( !v2 )
  {
    if ( (unsigned __int8)byte_4252D8 == 134 )
    {
      v2 = sub_40A65D();
      if ( !v2 )
      {
        v2 = sub_40626B();
        if ( !v2 )
        {
          if ( v1 == 3 )
            return sub_40E268(v1);
          if ( (unsigned __int8)byte_4252D8 != 133 )
          {
            word_425208 = v1 + 4126;
            return -1;
          }
          v2 = sub_40A65D();
          if ( !v2 )
          {
            v2 = sub_40626B();
            if ( !v2 )
            {
              if ( v1 == 1 )
                return sub_40E268(v1);
              if ( (unsigned __int8)byte_4252D8 != 133 )
              {
                word_425208 = v1 + 4126;
                return -1;
              }
              v2 = sub_40A65D();
              if ( !v2 )
              {
                v2 = sub_40626B();
                if ( !v2 )
                  return sub_40E268(v1);
              }
            }
          }
        }
      }
    }
    else
    {
      word_425208 = v1 + 4126;
      return -1;
    }
  }
  return v2;
}
// 425208: using guessed type __int16 word_425208;
// 4252D8: using guessed type char byte_4252D8;
// 4252D9: using guessed type char byte_4252D9;

//----- (0040E268) --------------------------------------------------------
char __cdecl sub_40E268(unsigned __int8 a1)
{
  char v2; // [esp+0h] [ebp-4h]

  if ( (unsigned __int8)byte_4252D8 == 135 )
  {
    v2 = sub_407BA9(21, a1 + 8);
    if ( !v2 )
    {
      v2 = sub_40A65D();
      if ( !v2 )
      {
        if ( byte_4252D8 == 16 )
        {
          word_42520C = sub_40A65D();
        }
        else
        {
          word_425208 = a1 + 4126;
          return -1;
        }
      }
    }
  }
  else
  {
    word_425208 = a1 + 4126;
    return -1;
  }
  return v2;
}
// 425208: using guessed type __int16 word_425208;
// 42520C: using guessed type __int16 word_42520C;
// 4252D8: using guessed type char byte_4252D8;

//----- (0040E330) --------------------------------------------------------
int sub_40E330()
{
  int result; // eax
  int i6; // [esp+0h] [ebp-8h]
  int i8; // [esp+0h] [ebp-8h]
  int i; // [esp+4h] [ebp-4h]
  int j; // [esp+4h] [ebp-4h]
  int k; // [esp+4h] [ebp-4h]
  int m; // [esp+4h] [ebp-4h]
  int n; // [esp+4h] [ebp-4h]
  int ii; // [esp+4h] [ebp-4h]
  int jj; // [esp+4h] [ebp-4h]
  int kk; // [esp+4h] [ebp-4h]
  int mm; // [esp+4h] [ebp-4h]
  int nn; // [esp+4h] [ebp-4h]
  int i1; // [esp+4h] [ebp-4h]
  int i2; // [esp+4h] [ebp-4h]
  int i3; // [esp+4h] [ebp-4h]
  int i4; // [esp+4h] [ebp-4h]
  int i5; // [esp+4h] [ebp-4h]
  int i7; // [esp+4h] [ebp-4h]

  byte_4251C8 = 0;
  dword_4251CC = 0;
  word_4251D0 = 0;
  word_4251D4 = 0;
  word_4251D8 = 0;
  byte_4251DC = 0;
  byte_4251E4 = 0;
  byte_4251E8 = 0;
  byte_4251FC = 0;
  byte_425200 = 0;
  word_425208 = 0;
  word_42520C = 0;
  dword_425210 = 0;
  word_434782 = 0;
  word_43B340 = 0;
  for ( i = 0; i < 400; ++i )
  {
    word_429420[3 * i] = 0;
    *(int *)((char *)&dword_429422 + 6 * i) = 0;
    result = i + 1;
  }
  dword_425218 = 0;
  dword_42521C = 0;
  word_425220 = 0;
  word_425222 = 0;
  dword_425224 = 0;
  word_425228 = 0;
  dword_42522A = 0;
  for ( j = 0; j < 42; ++j )
  {
    byte_42522E[j] = 0;
    result = j + 1;
  }
  dword_425258 = 0;
  dword_42525C = 0;
  word_425260 = 0;
  for ( k = 0; k < 54; ++k )
  {
    result = k;
    byte_425262[k] = 0;
  }
  word_425298 = 0;
  byte_42529C = 0;
  byte_4252A0 = 0;
  dword_4252A4 = 0;
  dword_4252A8 = 0;
  dword_4252AC = 0;
  dword_4252B0 = 0;
  byte_4252B4 = 0;
  byte_4252B8 = 0;
  byte_4252C8 = 0;
  byte_4252CC = 0;
  word_4252D0 = 0;
  byte_4252D8 = 0;
  byte_4252D9 = 0;
  dword_4252DA = 0;
  byte_4252DE = 0;
  byte_4252DF = 0;
  word_4252E0 = 0;
  word_4252E2 = 0;
  dword_4252E4 = 0;
  byte_4252E8 = 0;
  byte_4252E9 = 0;
  dword_4252EC = 0;
  dword_4252F0 = 0;
  byte_4252F4 = 0;
  byte_4252F8 = 0;
  word_4252FC = 0;
  for ( m = 0; m < 255; ++m )
    byte_428C40[m] = 0;
  byte_425300 = 0;
  byte_425304 = 0;
  byte_425308 = 0;
  byte_42530C = 0;
  byte_425310 = 0;
  for ( n = 0; n < 2; ++n )
  {
    byte_425318[8 * n] = 0;
    byte_425319[8 * n] = 0;
    dword_42531A[2 * n] = 0;
    byte_42531E[8 * n] = 0;
    byte_42531F[8 * n] = 0;
    result = n + 1;
  }
  byte_425328 = 0;
  byte_425329 = 0;
  dword_42532A = 0;
  byte_42532E = 0;
  byte_42532F = 0;
  byte_425330 = 0;
  byte_425331 = 0;
  byte_425332 = 0;
  byte_425333 = 0;
  dword_425334 = 0;
  byte_425338 = 0;
  byte_425339 = 0;
  byte_42533C = 0;
  byte_425340 = 0;
  word_420CA0 = 20;
  for ( ii = 0; ii < 20; ++ii )
  {
    byte_442720[8 * ii] = 0;
    byte_442721[8 * ii] = 0;
    dword_442722[2 * ii] = 0;
    byte_442726[8 * ii] = 0;
    byte_442727[8 * ii] = 0;
    result = ii + 1;
  }
  byte_425344 = 0;
  byte_425348 = 0;
  byte_42534C = 0;
  byte_425350 = 0;
  byte_425358 = 0;
  byte_42535C = 0;
  for ( jj = 0; jj < 200; ++jj )
  {
    dword_438E60[jj] = 0;
    result = jj + 1;
  }
  for ( kk = 0; kk < 200; ++kk )
  {
    result = kk;
    dword_4404A0[kk] = 0;
  }
  byte_425360 = 0;
  byte_425364 = 0;
  for ( mm = 0; mm < 200; ++mm )
    byte_429F80[mm] = 0;
  for ( nn = 0; nn < 200; ++nn )
  {
    dword_428D40[nn] = 0;
    result = nn + 1;
  }
  for ( i1 = 0; i1 < 3; ++i1 )
  {
    result = i1;
    dword_4392B0[i1] = 0;
  }
  dword_425368 = 0;
  word_42536C = 0;
  word_425370 = 0;
  word_425374 = 0;
  for ( i2 = 0; i2 < 16; ++i2 )
    byte_434560[i2] = 0;
  for ( i3 = 0; i3 < 16; ++i3 )
  {
    byte_429D80[i3] = 0;
    result = i3 + 1;
  }
  byte_425378 = 0;
  for ( i4 = 0; i4 < 16; ++i4 )
  {
    result = i4;
    dword_4293C0[i4] = 0;
  }
  for ( i5 = 0; i5 < 1000; ++i5 )
  {
    for ( i6 = 0; i6 < 8; ++i6 )
    {
      result = i5;
      *(&Str1 + 8 * i5 + i6) = 0;
    }
  }
  for ( i7 = 0; i7 < 2000; ++i7 )
  {
    for ( i8 = 0; i8 < 2; ++i8 )
    {
      dword_4347A0[2 * i7 + i8] = 0;
      result = i8 + 1;
    }
  }
  dword_427568 = 0;
  dword_439344 = 0;
  return result;
}
// 420CA0: using guessed type __int16 word_420CA0;
// 4251C8: using guessed type char byte_4251C8;
// 4251CC: using guessed type int dword_4251CC;
// 4251D0: using guessed type __int16 word_4251D0;
// 4251D4: using guessed type __int16 word_4251D4;
// 4251D8: using guessed type __int16 word_4251D8;
// 4251DC: using guessed type char byte_4251DC;
// 4251E4: using guessed type char byte_4251E4;
// 4251E8: using guessed type char byte_4251E8;
// 4251FC: using guessed type char byte_4251FC;
// 425200: using guessed type char byte_425200;
// 425208: using guessed type __int16 word_425208;
// 42520C: using guessed type __int16 word_42520C;
// 425210: using guessed type int dword_425210;
// 425218: using guessed type int dword_425218;
// 42521C: using guessed type int dword_42521C;
// 425220: using guessed type __int16 word_425220;
// 425222: using guessed type __int16 word_425222;
// 425224: using guessed type int dword_425224;
// 425228: using guessed type __int16 word_425228;
// 42522A: using guessed type int dword_42522A;
// 425258: using guessed type int dword_425258;
// 42525C: using guessed type int dword_42525C;
// 425260: using guessed type __int16 word_425260;
// 425298: using guessed type __int16 word_425298;
// 42529C: using guessed type char byte_42529C;
// 4252A0: using guessed type char byte_4252A0;
// 4252A4: using guessed type int dword_4252A4;
// 4252A8: using guessed type int dword_4252A8;
// 4252AC: using guessed type int dword_4252AC;
// 4252B0: using guessed type int dword_4252B0;
// 4252B4: using guessed type char byte_4252B4;
// 4252B8: using guessed type char byte_4252B8;
// 4252C8: using guessed type char byte_4252C8;
// 4252CC: using guessed type char byte_4252CC;
// 4252D0: using guessed type __int16 word_4252D0;
// 4252D8: using guessed type char byte_4252D8;
// 4252D9: using guessed type char byte_4252D9;
// 4252DE: using guessed type char byte_4252DE;
// 4252DF: using guessed type char byte_4252DF;
// 4252E0: using guessed type __int16 word_4252E0;
// 4252E2: using guessed type __int16 word_4252E2;
// 4252E4: using guessed type int dword_4252E4;
// 4252E8: using guessed type char byte_4252E8;
// 4252E9: using guessed type char byte_4252E9;
// 4252EC: using guessed type int dword_4252EC;
// 4252F0: using guessed type int dword_4252F0;
// 4252F4: using guessed type char byte_4252F4;
// 4252F8: using guessed type char byte_4252F8;
// 4252FC: using guessed type __int16 word_4252FC;
// 425300: using guessed type char byte_425300;
// 425304: using guessed type char byte_425304;
// 425308: using guessed type char byte_425308;
// 42530C: using guessed type char byte_42530C;
// 425310: using guessed type char byte_425310;
// 42531A: using guessed type int dword_42531A[];
// 425328: using guessed type char byte_425328;
// 425329: using guessed type char byte_425329;
// 42532A: using guessed type int dword_42532A;
// 42532E: using guessed type char byte_42532E;
// 42532F: using guessed type char byte_42532F;
// 425330: using guessed type char byte_425330;
// 425331: using guessed type char byte_425331;
// 425332: using guessed type char byte_425332;
// 425333: using guessed type char byte_425333;
// 425334: using guessed type int dword_425334;
// 425338: using guessed type char byte_425338;
// 425339: using guessed type char byte_425339;
// 42533C: using guessed type char byte_42533C;
// 425340: using guessed type char byte_425340;
// 425344: using guessed type char byte_425344;
// 425348: using guessed type char byte_425348;
// 42534C: using guessed type char byte_42534C;
// 425350: using guessed type char byte_425350;
// 425358: using guessed type char byte_425358;
// 42535C: using guessed type char byte_42535C;
// 425360: using guessed type char byte_425360;
// 425364: using guessed type char byte_425364;
// 425368: using guessed type int dword_425368;
// 42536C: using guessed type __int16 word_42536C;
// 425370: using guessed type __int16 word_425370;
// 425374: using guessed type __int16 word_425374;
// 425378: using guessed type char byte_425378;
// 427568: using guessed type int dword_427568;
// 428D40: using guessed type int dword_428D40[200];
// 4293C0: using guessed type int dword_4293C0[24];
// 429420: using guessed type __int16 word_429420[];
// 429422: using guessed type int dword_429422;
// 434782: using guessed type __int16 word_434782;
// 4347A0: using guessed type int dword_4347A0[];
// 438E60: using guessed type int dword_438E60[200];
// 4392B0: using guessed type int dword_4392B0[];
// 439344: using guessed type int dword_439344;
// 43B340: using guessed type __int16 word_43B340;
// 4404A0: using guessed type int dword_4404A0[198];
// 442722: using guessed type int dword_442722[];

//----- (0040E930) --------------------------------------------------------
int sub_40E930()
{
  _DWORD *v1; // [esp+4h] [ebp-14h]
  int i; // [esp+8h] [ebp-10h]
  __int16 v3; // [esp+Ch] [ebp-Ch]
  _DWORD *Blocka; // [esp+10h] [ebp-8h]
  _DWORD *Block; // [esp+10h] [ebp-8h]
  _DWORD *v6; // [esp+14h] [ebp-4h]

  dword_426698 = (char *)malloc(0x84u);
  dword_426C48 = (int)dword_426698;
  *dword_426698 = 0;
  *(_BYTE *)(dword_426C48 + 33) = 0;
  *(_WORD *)(dword_426C48 + 114) = 0;
  *(_DWORD *)(dword_426C48 + 116) = dword_426698;
  *(_DWORD *)(dword_426C48 + 120) = 0;
  Blocka = malloc(8u);
  *(_DWORD *)(dword_426C48 + 124) = Blocka;
  *(_DWORD *)(dword_426C48 + 128) = Blocka;
  *(_WORD *)Blocka = -1;
  Blocka[1] = 0;
  word_426C18 = 1;
  word_426C44 = 0;
  word_426104 = 0;
  word_426106 = 0;
  word_426108 = 0;
  word_426C4C = 0;
  dword_445EB8 = fopen(byte_434220, aW_3);
  if ( dword_445EB8 )
  {
    dword_426100 = getenv(aMeor_0);
    if ( dword_426100 && (!strcmp(dword_426100, aYes_1) || !strcmp(dword_426100, aYes_2)) )
      fputs(asc_4210BC, dword_445EB8);
    if ( byte_440340 || byte_429060 || (dword_445EB0 = fopen(byte_429EE0, aW_2)) != 0 )
    {
      sub_410170(0);
      v3 = sub_40EC2D(byte_439180);
      if ( !v3 )
        sub_410170(2);
      if ( --File._cnt < 0 )
        _flsbuf(10, &File);
      else
        *File._ptr++ = 10;
      if ( fclose(dword_445EB8) )
      {
        printf("temporary file access error.\n");
        return -1;
      }
      else if ( byte_440340 || byte_429060 || !fclose(dword_445EB0) )
      {
        v6 = (_DWORD *)dword_426C48;
        for ( i = dword_426C48; i; v6 = (_DWORD *)i )
        {
          for ( Block = (_DWORD *)v6[31]; Block; Block = v1 )
          {
            v1 = (_DWORD *)Block[1];
            free(Block);
          }
          i = v6[30];
          free(v6);
        }
        return v3;
      }
      else
      {
        printf("xxxxxx.REF file access error.\n");
        return -1;
      }
    }
    else
    {
      printf("xxxxxx.REF file access error.\n");
      return -1;
    }
  }
  else
  {
    printf("temporary file access error.\n");
    return -1;
  }
}
// 410170: using guessed type _DWORD __cdecl sub_410170(__int16);
// 426104: using guessed type __int16 word_426104;
// 426106: using guessed type __int16 word_426106;
// 426108: using guessed type __int16 word_426108;
// 426C18: using guessed type __int16 word_426C18;
// 426C44: using guessed type __int16 word_426C44;
// 426C48: using guessed type int dword_426C48;
// 426C4C: using guessed type __int16 word_426C4C;
// 429060: using guessed type char byte_429060;
// 440340: using guessed type char byte_440340;

//----- (0040EC2D) --------------------------------------------------------
__int16 __cdecl sub_40EC2D(char *FileName)
{
  size_t v2; // eax
  __int16 v3; // [esp+0h] [ebp-BCh]
  int v4; // [esp+4h] [ebp-B8h] BYREF
  FILE *Stream; // [esp+8h] [ebp-B4h]
  __int16 v6; // [esp+Ch] [ebp-B0h]
  __int16 v7; // [esp+10h] [ebp-ACh]
  int v8; // [esp+14h] [ebp-A8h]
  char Destination[128]; // [esp+18h] [ebp-A4h] BYREF
  __int16 v10; // [esp+98h] [ebp-24h]
  int v11; // [esp+9Ch] [ebp-20h] BYREF
  __int16 v12; // [esp+A0h] [ebp-1Ch]
  __int16 v13; // [esp+A4h] [ebp-18h]
  int v14; // [esp+A8h] [ebp-14h]
  _DWORD *v15; // [esp+ACh] [ebp-10h]
  char *v16; // [esp+B0h] [ebp-Ch]
  int v17; // [esp+B4h] [ebp-8h]
  char *v18; // [esp+B8h] [ebp-4h]

  LOBYTE(v4) = 0;
  v13 = 1;
  v7 = 0;
  v12 = 0;
  Stream = fopen(FileName, aR_4);
  if ( !Stream )
    return -2;
  if ( _stat(FileName, &Stat) == -1 )
    return -2;
  v8 = Stat.st_size / 10;
  dword_426100 = getenv(aMeor_1);
  if ( dword_426100 && (!strcmp(dword_426100, aYes_3) || !strcmp(dword_426100, aYes_4)) )
    fgets(byte_4266A0, 1400, Stream);
  v14 = 0;
  while ( v13 && fgets(byte_4266A0, 1400, Stream) )
  {
    v18 = strchr(byte_4266A0, 10);
    if ( v18 )
      *v18 = 0;
    v14 += strlen(byte_4266A0);
    if ( v14 >= v8 )
    {
      if ( --File._cnt < 0 )
      {
        v3 = _flsbuf(42, &File);
      }
      else
      {
        *File._ptr = 42;
        v3 = 42;
        ++File._ptr;
      }
      v14 = 0;
    }
    LOWORD(v11) = 0;
    ++word_426108;
    ++v7;
    strcpy(byte_426120, byte_4266A0);
    if ( byte_429060 )
    {
LABEL_36:
      ++word_426C4C;
      sub_410170(4);
      strcpy(byte_4266A0, byte_426120);
      memset(byte_426C60, 0, 0x400u);
      LOWORD(v11) = 0;
      v6 = 0;
      word_4253A0 = 0;
      word_425CE0 = 0;
      while ( v13 )
      {
        memset(&byte_4258E0, 0, 0xFFu);
        memset(byte_425D00, 0, 0xFFu);
        LOBYTE(v4) = 0;
        v10 = sub_40F337(&byte_4266A0[(__int16)v11], &byte_4258E0, &v11);
        if ( byte_4258E0 == 37 )
          v13 = 0;
        if ( !v10 && !byte_4258E0 )
          break;
        if ( !byte_429060 && v10 && byte_4258E0 == 40 && byte_4258E1 == 39 )
        {
          sub_40FE62((int)&byte_4258E0, byte_425D00);
          strcat(byte_426C60, byte_425D00);
        }
        else if ( !byte_429060 && v10 && (v16 = sub_40FE21(&byte_4258E0)) != 0 )
        {
          if ( *((_WORD *)v16 + 57) == 2 && !v6 )
            strcat(byte_426C60, aN);
          v15 = malloc(8u);
          v17 = *((_DWORD *)v16 + 32);
          *(_WORD *)v17 = word_426108;
          *(_DWORD *)(v17 + 4) = v15;
          *(_WORD *)v15 = -1;
          v15[1] = 0;
          *((_DWORD *)v16 + 32) = v15;
          strcat(byte_426C60, v16 + 33);
        }
        else
        {
          if ( byte_4258E0 == 44 && byte_4258E1 )
          {
            byte_4258E0 = 40;
            if ( byte_4258DF[strlen(&byte_4258E0)] == 59 )
            {
              v2 = strlen(&byte_4258E0);
              strcpy(&byte_4258DF[v2], asc_4213C8);
            }
            else
            {
              strcat(&byte_4258E0, asc_4213CC);
            }
            strcat(byte_426C60, &byte_4258E0);
            break;
          }
          if ( !byte_429060 && v10 && byte_4258E0 == 40 && sub_410AFD(&byte_4258E1, &v4) )
          {
            sub_41083F((unsigned __int8 *)&byte_4258E0, byte_425D00, v4);
            strcat(byte_426C60, byte_425D00);
          }
          else
          {
            strcat(byte_426C60, &byte_4258E0);
            if ( byte_4258E0 == 59 )
              break;
          }
        }
        ++v6;
      }
      v10 = fprintf(dword_445EB8, "%s\n", byte_426C60);
      if ( v10 == -1 )
      {
        sub_4105EE(504, byte_4253BC, 0, v3);
        v12 = -1;
        break;
      }
    }
    else
    {
      sub_40FA4C(byte_426120, &byte_4258E0, byte_425D00);
      if ( byte_4258E0 )
      {
        if ( byte_4258E0 != 36 && byte_4258E0 != 64 && byte_4258E0 != 62 )
          goto LABEL_36;
        sub_410170(1);
        v12 = sub_40FC1E(&byte_4258E0, byte_425D00);
        if ( v12 == 1 )
        {
          if ( ++word_426C44 > 2 )
          {
            sub_4105EE(500, FileName, byte_425D00, v7);
            v12 = -1;
            break;
          }
          strcpy(Destination, byte_425D00);
          v12 = sub_40EC2D(Destination);
          if ( v12 == -2 )
          {
            sub_4105EE(500, FileName, Destination, v7);
            v12 = -1;
            break;
          }
          --word_426C44;
        }
        if ( v12 == 2 )
        {
          sub_410170(3);
          v12 = 0;
        }
        if ( v12 )
        {
          sub_4105EE(v12, FileName, &byte_4258E0, v7);
          v12 = -1;
          break;
        }
      }
      else
      {
        sub_410170(1);
      }
    }
  }
  fclose(Stream);
  return v12;
}
// 40F30B: variable 'v3' is possibly undefined
// 4253A0: using guessed type __int16 word_4253A0;
// 4258E1: using guessed type char byte_4258E1;
// 425CE0: using guessed type __int16 word_425CE0;
// 426108: using guessed type __int16 word_426108;
// 426C44: using guessed type __int16 word_426C44;
// 426C4C: using guessed type __int16 word_426C4C;
// 429060: using guessed type char byte_429060;

//----- (0040F337) --------------------------------------------------------
__int16 __cdecl sub_40F337(char *Buf1, char *a2, _WORD *a3)
{
  char v4; // [esp+0h] [ebp-1Ch]
  int v5; // [esp+4h] [ebp-18h] BYREF
  char v6; // [esp+8h] [ebp-14h]
  char v7; // [esp+Ch] [ebp-10h]
  char *Str1; // [esp+10h] [ebp-Ch]
  char *v9; // [esp+14h] [ebp-8h]
  char i; // [esp+18h] [ebp-4h]
  char *Buf1a; // [esp+24h] [ebp+8h]
  _BYTE *Buf1b; // [esp+24h] [ebp+8h]
  char *Buf1c; // [esp+24h] [ebp+8h]
  char *Buf1d; // [esp+24h] [ebp+8h]
  char *v15; // [esp+28h] [ebp+Ch]
  _BYTE *v16; // [esp+28h] [ebp+Ch]
  char *v17; // [esp+28h] [ebp+Ch]
  _BYTE *v18; // [esp+28h] [ebp+Ch]

  Str1 = a2;
  LOBYTE(v5) = 0;
  while ( 1 )
  {
    while ( 1 )
    {
      v7 = *Buf1;
      if ( !strchr(asc_4210A8, v7) )
      {
        *a2 = *Buf1;
        v18 = a2 + 1;
        Buf1d = Buf1 + 1;
        ++*a3;
        while ( 1 )
        {
          v7 = *Buf1d;
          if ( strchr(asc_4210A8, v7) )
            break;
          *v18++ = v7;
          ++*a3;
          ++Buf1d;
        }
        *v18 = 0;
        for ( i = 17; ; ++i )
        {
          if ( i >= 70 )
            return 1;
          if ( !strcmp(Str1, (&off_420F90)[i]) )
            break;
        }
        word_4253A0 = 1;
        return 1;
      }
      if ( v7 != 32 && v7 != 9 )
        break;
      ++Buf1;
      ++*a3;
    }
    if ( v7 != -127 || Buf1[1] != 64 )
      break;
    Buf1 += 2;
    ++*a3;
    ++*a3;
  }
  if ( word_4253A0 || v7 != 40 )
  {
    if ( word_4253A0 || v7 != 44 )
    {
      if ( *Buf1 == 47 && Buf1[1] == 42 )
      {
        *a2 = 0;
        *a3 += 2;
        return 0;
      }
      if ( v7 == 91 && *Buf1 == 91 && Buf1[1] == 35 && Buf1[2] == 95 )
      {
        v9 = Buf1 + 3;
        v4 = 1;
        for ( i = 0; ; ++i )
        {
          v6 = *v9;
          if ( v6 == 91 )
          {
            ++v4;
          }
          else if ( v6 == 93 )
          {
            if ( !--v4 )
            {
              for ( i += 4; i > 0; --i )
              {
                *a2++ = *Buf1++;
                ++*a3;
              }
              *a2 = 0;
              return 1;
            }
          }
          else if ( strchr(asc_4210A8, v6) )
          {
            break;
          }
          ++v9;
        }
      }
      *a2 = v7;
      a2[1] = 0;
      ++*a3;
      if ( v7 == 41 && word_4253A0 )
        word_4253A0 = 0;
      if ( word_4253A0 )
      {
        if ( v7 == 91 )
        {
          ++word_425CE0;
        }
        else if ( v7 == 93 && !--word_425CE0 )
        {
          word_4253A0 = 0;
        }
      }
      if ( v7 == 59 )
        word_4253A0 = 0;
      return 0;
    }
    else
    {
      *a2 = v7;
      v17 = a2 + 1;
      Buf1c = Buf1 + 1;
      ++*a3;
      do
      {
        if ( !*Buf1c )
          break;
        *v17 = *Buf1c;
        v7 = *v17++;
        ++Buf1c;
        ++*a3;
      }
      while ( v7 != 59 );
      word_4253A0 = 0;
      return 1;
    }
  }
  else
  {
    *a2 = v7;
    v15 = a2 + 1;
    Buf1a = Buf1 + 1;
    ++*a3;
    if ( *Buf1a == 39 )
    {
      while ( 1 )
      {
        *v15++ = *Buf1a++;
        ++*a3;
        if ( !*Buf1a )
          break;
        if ( *Buf1a == 39 && Buf1a[1] == 41 )
        {
          *v15 = *Buf1a;
          v15[1] = Buf1a[1];
          *a3 += 2;
          return 1;
        }
      }
    }
    else if ( *Buf1a == 42 )
    {
      *v15 = *Buf1a;
      v16 = v15 + 1;
      Buf1b = Buf1a + 1;
      ++*a3;
      while ( *Buf1b )
      {
        if ( *Buf1b == 41 )
        {
          *v16 = *Buf1b;
          ++*a3;
          return 1;
        }
        *v16++ = *Buf1b++;
        ++*a3;
      }
    }
    else if ( sub_410AFD(Buf1a, &v5) )
    {
      while ( 1 )
      {
        *v15++ = *Buf1a++;
        ++*a3;
        if ( !*Buf1a )
          break;
        if ( *Buf1a == 39 && Buf1a[1] == 41 )
        {
          *v15 = *Buf1a;
          v15[1] = Buf1a[1];
          *a3 += 2;
          return 1;
        }
      }
    }
    else
    {
      do
      {
        if ( !*Buf1a )
          break;
        *v15 = *Buf1a;
        v7 = *v15++;
        ++Buf1a;
        ++*a3;
      }
      while ( v7 != 41 );
    }
    return 1;
  }
}
// 4253A0: using guessed type __int16 word_4253A0;
// 425CE0: using guessed type __int16 word_425CE0;

//----- (0040FA4C) --------------------------------------------------------
char *__cdecl sub_40FA4C(char *a1, char *a2, char *a3)
{
  char *result; // eax
  char *v4; // [esp+8h] [ebp+8h]
  _BYTE *v5; // [esp+Ch] [ebp+Ch]

  *a3 = 0;
  *a2 = 0;
  while ( *a1 == 32 || *a1 == 9 )
    ++a1;
  while ( *a1 == -127 && a1[1] == 64 )
    a1 += 2;
  if ( *a1 == 36 || *a1 == 62 || *a1 == 64 )
  {
    *a2 = *a1;
    v5 = a2 + 1;
    v4 = a1 + 1;
    *v5 = 0;
    while ( *v4 != 32 && *v4 != 9 && *v4 )
    {
      if ( *v4 == 47 )
      {
        result = v4;
        if ( v4[1] == 42 )
          return result;
      }
      *v5++ = *v4++;
      *v5 = 0;
    }
    while ( 1 )
    {
      result = (char *)*v4;
      if ( result != (char *)32 && *v4 != 9 )
        break;
      ++v4;
    }
    while ( *v4 == -127 )
    {
      result = v4;
      if ( v4[1] != 64 )
        break;
      result = v4 + 2;
      v4 += 2;
    }
    while ( *v4 != 32 )
    {
      result = v4;
      if ( *v4 == 9 )
        break;
      result = (char *)*v4;
      if ( !*v4 )
        break;
      if ( *v4 == 47 )
      {
        result = v4;
        if ( v4[1] == 42 )
          break;
      }
      *a3++ = *v4;
      result = ++v4;
      *a3 = 0;
    }
  }
  else
  {
    result = (char *)*a1;
    if ( result != (char *)47 || a1[1] != 42 )
    {
      result = a2;
      *a2 = *a1;
    }
  }
  return result;
}

//----- (0040FC1E) --------------------------------------------------------
__int16 __cdecl sub_40FC1E(char *Str1, char *Source)
{
  _DWORD *v3; // eax
  __int16 j; // [esp+4h] [ebp-8h]
  char *i; // [esp+8h] [ebp-4h]
  char *v6; // [esp+8h] [ebp-4h]

  if ( !strcmp(Str1, aInclude) )
  {
    if ( *Source )
      return 1;
    else
      return 503;
  }
  else
  {
    if ( !strcmp(Str1, aNolist) )
    {
      word_426C18 = 0;
    }
    else if ( !strcmp(Str1, aList) )
    {
      word_426C18 = 1;
    }
    else
    {
      if ( !strcmp(Str1, aEject) )
        return 2;
      if ( !*Source )
        return 503;
      for ( i = (char *)dword_426C48; *((_DWORD *)i + 30); i = (char *)*((_DWORD *)i + 30) )
      {
        if ( !strcmp(i, Str1 + 1) )
          return 502;
      }
      for ( j = 0; j < 70; ++j )
      {
        if ( !strcmp((&off_420F90)[j], Str1 + 1) )
          return 501;
      }
      strcpy(dword_426698, Str1 + 1);
      strcpy(dword_426698 + 33, Source);
      *((_WORD *)dword_426698 + 57) = (*Str1 != 64) + 1;
      v6 = (char *)malloc(0x84u);
      *((_DWORD *)dword_426698 + 30) = v6;
      *v6 = 0;
      v6[33] = 0;
      *((_WORD *)v6 + 57) = 0;
      *((_DWORD *)v6 + 29) = dword_426698;
      *((_DWORD *)v6 + 30) = 0;
      v3 = malloc(8u);
      *((_DWORD *)v6 + 31) = v3;
      *((_DWORD *)v6 + 32) = v3;
      *(_WORD *)v3 = -1;
      v3[1] = 0;
      dword_426698 = v6;
    }
    return 0;
  }
}
// 426C18: using guessed type __int16 word_426C18;
// 426C48: using guessed type int dword_426C48;

//----- (0040FE21) --------------------------------------------------------
char *__cdecl sub_40FE21(char *Str2)
{
  char *Str1; // [esp+0h] [ebp-4h]

  for ( Str1 = (char *)dword_426C48; *((_DWORD *)Str1 + 30); Str1 = (char *)*((_DWORD *)Str1 + 30) )
  {
    if ( !strcmp(Str1, Str2) )
      return Str1;
  }
  return 0;
}
// 426C48: using guessed type int dword_426C48;

//----- (0040FE62) --------------------------------------------------------
char *__cdecl sub_40FE62(int a1, char *Destination)
{
  unsigned int v2; // eax
  unsigned __int8 *v4; // [esp+0h] [ebp-14h]
  char Source[8]; // [esp+8h] [ebp-Ch] BYREF
  int v6; // [esp+10h] [ebp-4h]

  strcat(Destination, asc_4213F8);
  v4 = (unsigned __int8 *)(a1 + 2);
  v6 = sub_413140();
  sub_412C60(932);
  while ( (*v4 != 39 || v4[1] != 41) && *v4 )
  {
    if ( (byte_425429[*v4] & 4) != 0 && (byte_425429[v4[1]] & 8) != 0 )
    {
      v2 = _mbcjmstojis(_byteswap_ushort(*(_WORD *)v4));
      sprintf(Source, "%4X", v2);
      v4 += 2;
      Source[4] = 0;
    }
    else if ( *v4 != 39 || v4[1] == 39 )
    {
      if ( *v4 == 39 && v4[1] == 39 )
        ++v4;
      sprintf(Source, "%02X", *v4++);
      Source[2] = 0;
    }
    else
    {
      strcpy(Source, "'");
      ++v4;
    }
    strcat(Destination, Source);
    if ( *v4 != 39 || v4[1] != 41 )
    {
      if ( *v4 )
        strcat(Destination, asc_42140C);
    }
  }
  sub_412C60(v6);
  return strcat(Destination, asc_421410);
}

//----- (00410029) --------------------------------------------------------
int sub_410029()
{
  int result; // eax
  char *Source; // [esp+0h] [ebp-28h]
  char Destination[11]; // [esp+4h] [ebp-24h] BYREF
  char v3[5]; // [esp+Fh] [ebp-19h] BYREF
  char v4[16]; // [esp+14h] [ebp-14h] BYREF
  __time32_t Time; // [esp+24h] [ebp-4h] BYREF

  fputs(&byte_421414, dword_445EB0);
  time(&Time);
  Source = ctime(&Time);
  strncpy(Destination, Source, 0xBu);
  Destination[7] = 45;
  Destination[10] = 45;
  strncpy(v3, Source + 20, 4u);
  v3[4] = 32;
  strncpy(v4, Source + 11, 8u);
  v4[8] = 0;
  fprintf(dword_445EB0, "                   %s             Page %u\n", Destination, ++word_426106);
  if ( byte_434780 )
  {
    fprintf(dword_445EB0, "   (FS30i/FS0i)    Macro Compiler (Pre) %s           %s    \n", aV010, byte_439220);
    if ( (unsigned __int8)byte_439202 == 255 )
      result = fprintf(dword_445EB0, "                   Select Series : 0i\n\n");
    else
      result = fprintf(dword_445EB0, "                   Select Series : 30i\n\n");
  }
  else
  {
    result = fprintf(
               dword_445EB0,
               "        (F15)      Macro Compiler (Pre) %s           %s    \n\n\n",
               aV010,
               byte_439220);
  }
  word_426104 += 5;
  return result;
}
// 426104: using guessed type __int16 word_426104;
// 426106: using guessed type __int16 word_426106;
// 434780: using guessed type char byte_434780;
// 439202: using guessed type char byte_439202;

//----- (00410170) --------------------------------------------------------
__int16 __cdecl sub_410170(__int16 a1)
{
  __int16 result; // ax
  char *Destination; // [esp+0h] [ebp-110h]
  char *Destinationa; // [esp+0h] [ebp-110h]
  char Str[38]; // [esp+4h] [ebp-10Ch] BYREF
  char v5[218]; // [esp+2Ah] [ebp-E6h] BYREF
  __int16 v6; // [esp+104h] [ebp-Ch]
  const char *i; // [esp+108h] [ebp-8h]
  __int16 *v8; // [esp+10Ch] [ebp-4h]

  result = word_426C18;
  if ( word_426C18 && !byte_440340 && !byte_429060 )
  {
    if ( a1 != 2 && (!word_426104 || word_426104 >= 57) )
    {
      if ( word_426104 >= 57 )
        word_426104 = 2;
      sub_410029();
      if ( a1 )
      {
        fprintf(dword_445EB0, "  S-Line G-Line\n");
        ++word_426104;
      }
    }
    if ( a1 )
    {
      switch ( a1 )
      {
        case 1:
          result = fprintf(dword_445EB0, "  %4d             %s\n", word_426108, byte_4266A0);
          ++word_426104;
          break;
        case 2:
          result = dword_426C48;
          if ( (char *)dword_426C48 != dword_426698 )
          {
            fprintf(dword_445EB0, "\n\n");
            word_426104 = 2;
            sub_410029();
            fprintf(dword_445EB0, "---------- Cross Reference -------------------------------------------\n\n");
            word_426104 += 4;
            fprintf(
              dword_445EB0,
              "         Symbol                      Define       Line No.                                      \n");
            for ( i = (const char *)dword_426C48; *((_DWORD *)i + 30); i = (const char *)*((_DWORD *)i + 30) )
            {
              if ( word_426104 + 4 >= 57 )
              {
                fprintf(dword_445EB0, "\n\n");
                word_426104 = 2;
                sub_410029();
              }
              v8 = (__int16 *)*((_DWORD *)i + 31);
              if ( *v8 != -1 || (unsigned __int8)byte_427564 != 255 )
              {
                memset(Str, 32, 0x20u);
                sprintf(&Str[4], "%s", i);
                Destination = strchr(Str, 0);
                if ( Destination )
                  strcpy(Destination, asc_4216BC);
                sprintf(v5, "%s", i + 33);
                Destinationa = strchr(Str, 0);
                if ( Destinationa )
                  strcpy(Destinationa, asc_4216E4);
                v5[10] = 0;
                fprintf(dword_445EB0, "%s", Str);
                if ( *v8 == -1 )
                {
                  fprintf(dword_445EB0, "***");
                }
                else
                {
                  v6 = 0;
                  v8 = (__int16 *)*((_DWORD *)i + 31);
                  while ( 1 )
                  {
                    if ( v6 >= 5 )
                    {
                      fprintf(dword_445EB0, "\n                                                ");
                      v6 = 0;
                      ++word_426104;
                    }
                    fprintf(dword_445EB0, "%3d", *v8);
                    v8 = (__int16 *)*((_DWORD *)v8 + 1);
                    if ( !v8 || !*((_DWORD *)v8 + 1) )
                      break;
                    fprintf(dword_445EB0, ", ");
                    ++v6;
                  }
                }
                fprintf(dword_445EB0, "\n");
                ++word_426104;
              }
            }
            return fprintf(dword_445EB0, "\n\n");
          }
          break;
        case 3:
          word_426104 = 3;
          sub_410029();
          return fprintf(dword_445EB0, "  S-Line G-Line\n");
        default:
          result = a1;
          if ( a1 == 4 )
          {
            result = fprintf(dword_445EB0, "  %4d   %04d      %s\n", word_426108, word_426C4C, byte_4266A0);
            ++word_426104;
          }
          break;
      }
    }
    else
    {
      fprintf(dword_445EB0, "---------- Compile Parameter -----------------------------------------\n\n");
      fprintf(dword_445EB0, "        %s\n\n", byte_43B360);
      fprintf(dword_445EB0, "---------- Program ---------------------------------------------------\n\n\n");
      fprintf(dword_445EB0, "  S-Line G-Line\n");
      result = word_426104 + 8;
      word_426104 += 8;
    }
  }
  return result;
}
// 426104: using guessed type __int16 word_426104;
// 426108: using guessed type __int16 word_426108;
// 426C18: using guessed type __int16 word_426C18;
// 426C48: using guessed type int dword_426C48;
// 426C4C: using guessed type __int16 word_426C4C;
// 427564: using guessed type char byte_427564;
// 429060: using guessed type char byte_429060;
// 440340: using guessed type char byte_440340;

//----- (004105EE) --------------------------------------------------------
int __cdecl sub_4105EE(__int16 a1, const char *a2, const char *a3, __int16 a4)
{
  int result; // eax

  result = a1;
  switch ( a1 )
  {
    case 500:
      if ( word_426C18 && !byte_440340 )
        fprintf(dword_445EB0, " %s : include file error : '%s'\n", a2, a3);
      result = printf("\n    %s(%u) : include file error : '%s'\n", a2, a4, a3);
      break;
    case 501:
      if ( word_426C18 && !byte_440340 )
        fprintf(dword_445EB0, " %s : reserved symbol name : '%s'\n", a2, a3);
      result = printf("\n    %s(%u) : reserved symbol name : '%s'\n", a2, a4, a3);
      break;
    case 502:
      if ( word_426C18 && !byte_440340 )
        fprintf(dword_445EB0, " %s : redefinition symbol : '%s'\n", a2, a3);
      result = printf("\n    %s(%u) : redefinition symbol : '%s'\n", a2, a4, a3);
      break;
    case 503:
      if ( word_426C18 && !byte_440340 )
        fprintf(dword_445EB0, " %s : syntax error : '%s'\n", a2, a3);
      result = printf("\n    %s(%u) : syntax error : '%s'\n", a2, a4, a3);
      break;
    case 504:
      if ( word_426C18 && !byte_440340 )
        fprintf(dword_445EB0, " temporary file error\n");
      result = printf("\n    temporary file error\n");
      break;
    default:
      break;
  }
  ++word_426104;
  return result;
}
// 426104: using guessed type __int16 word_426104;
// 426C18: using guessed type __int16 word_426C18;
// 440340: using guessed type char byte_440340;

//----- (004107BD) --------------------------------------------------------
int __cdecl sub_4107BD(_BYTE *a1, _BYTE *a2, _BYTE *a3)
{
  while ( *a2 && *a2 != 46 )
    *a1++ = *a2++;
  if ( *a3 != 46 )
    *a1++ = 46;
  while ( *a3 )
    *a1++ = *a3++;
  *a1 = 0;
  return 0;
}

//----- (0041083F) --------------------------------------------------------
char *__cdecl sub_41083F(unsigned __int8 *a1, char *Destination, unsigned __int8 a3)
{
  unsigned __int8 *Buf2; // [esp+0h] [ebp-1Ch]
  char Src[4]; // [esp+4h] [ebp-18h] BYREF
  char Buffer[8]; // [esp+8h] [ebp-14h] BYREF
  char Source[8]; // [esp+10h] [ebp-Ch] BYREF
  char Buf1[4]; // [esp+18h] [ebp-4h] BYREF

  Src[0] = 39;
  memset(Source, 0, 5u);
  strcpy(Buf1, "')");
  memcpy(Source, a1, 3u);
  Source[3] = 42;
  Buf2 = a1 + 4;
  strcat(Destination, Source);
  while ( memcmp(Buf1, Buf2, 2u) && *Buf2 )
  {
    if ( sub_410A33(a3, Buf2) )
    {
      Buf2 += (unsigned __int8)sub_410A93(dword_4210C8[4 * a3], Buf2, Buffer);
    }
    else if ( memcmp(Src, Buf2, 1u) || !memcmp(Src, Buf2 + 1, 1u) )
    {
      if ( !memcmp(Src, Buf2, 1u) && !memcmp(Src, Buf2 + 1, 1u) )
        ++Buf2;
      sprintf(Buffer, "%02X", *Buf2);
      Buffer[2] = 0;
      ++Buf2;
    }
    else
    {
      memcpy(Buffer, Src, 1u);
      Buffer[1] = 0;
      ++Buf2;
    }
    strcat(Destination, Buffer);
    if ( memcmp(Buf1, Buf2, 2u) )
    {
      if ( *Buf2 )
        strcat(Destination, asc_4218E0);
    }
    memset(Buffer, 0, sizeof(Buffer));
  }
  return strcat(Destination, asc_4218E4);
}
// 4210C8: using guessed type int dword_4210C8[];
// 41083F: using guessed type char Src[4];

//----- (00410A33) --------------------------------------------------------
BOOL __cdecl sub_410A33(char a1, unsigned __int8 *a2)
{
  BOOL v3; // [esp+4h] [ebp-4h]

  v3 = 0;
  if ( a1 == 1 )
  {
    v3 = sub_410C27(a2);
    if ( v3 )
      return sub_410C27(a2 + 1);
  }
  else if ( a1 == 2 )
  {
    return sub_410C82(a2);
  }
  return v3;
}

//----- (00410A93) --------------------------------------------------------
char __cdecl sub_410A93(char a1, unsigned __int8 *a2, char *Buffer)
{
  if ( a1 == 1 )
  {
    sprintf(Buffer, "%02X", *a2);
    Buffer[2] = 0;
  }
  else if ( a1 == 2 )
  {
    sprintf(Buffer, "%02X%02X", *a2, a2[1]);
    Buffer[4] = 0;
  }
  return a1;
}

//----- (00410AFD) --------------------------------------------------------
int __cdecl sub_410AFD(void *Buf1, _BYTE *a2)
{
  int v3; // [esp+0h] [ebp-Ch]
  unsigned int i; // [esp+4h] [ebp-8h]

  v3 = 0;
  if ( Buf1 && Buf1 != (void *)-1 )
  {
    for ( i = 0; i < 0x10; ++i )
    {
      if ( !memcmp(Buf1, &a00[16 * i], 3u) )
      {
        v3 = dword_4210CC[4 * i];
        *a2 = a00[16 * i + 6];
        return v3;
      }
    }
  }
  return v3;
}
// 410B89: conditional instruction was optimized away because %var_4.4==0
// 4210CC: using guessed type int dword_4210CC[61];

//----- (00410B92) --------------------------------------------------------
int __cdecl sub_410B92(void *Buf1, _BYTE *a2)
{
  int v3; // [esp+0h] [ebp-Ch]
  unsigned int i; // [esp+4h] [ebp-8h]

  v3 = 0;
  if ( Buf1 && Buf1 != (void *)-1 )
  {
    for ( i = 0; i < 0x10; ++i )
    {
      if ( !memcmp(Buf1, (const void *)(16 * i + 4329667), 3u) )
      {
        v3 = dword_4210CC[4 * i];
        *a2 = a00[16 * i + 6];
        return v3;
      }
    }
  }
  return v3;
}
// 410C1E: conditional instruction was optimized away because %var_4.4==0
// 4210CC: using guessed type int dword_4210CC[61];

//----- (00410C27) --------------------------------------------------------
BOOL __cdecl sub_410C27(unsigned __int8 *a1)
{
  int v2; // [esp+4h] [ebp-8h]

  v2 = 0;
  if ( a1 )
    return *a1 >= 0xA0u;
  return v2;
}
// 410C79: conditional instruction was optimized away because %var_4.4==0

//----- (00410C82) --------------------------------------------------------
BOOL __cdecl sub_410C82(unsigned __int8 *a1)
{
  int v2; // [esp+4h] [ebp-8h]

  v2 = 0;
  if ( a1 )
    return *a1 >= 0x80u;
  return v2;
}
// 410CD4: conditional instruction was optimized away because %var_4.4==0

//----- (00410CDD) --------------------------------------------------------
BOOL __cdecl sub_410CDD(unsigned __int8 *a1)
{
  int v2; // [esp+4h] [ebp-8h]

  v2 = 0;
  if ( a1 && *a1 >= 0x20u )
    return *a1 <= 0x5Fu;
  return v2;
}
// 410D2A: conditional instruction was optimized away because %var_4.4==0

//----- (00410D33) --------------------------------------------------------
int __cdecl sub_410D33(unsigned __int8 a1)
{
  int v2; // [esp+0h] [ebp-4h]

  v2 = 0;
  if ( a1 < 0x10u )
    return dword_4210C8[4 * a1];
  return v2;
}
// 4210C8: using guessed type int dword_4210C8[];

//----- (00410D70) --------------------------------------------------------
int sub_410D70()
{
  char Str[24]; // [esp+0h] [ebp-C8h] BYREF
  FARPROC RegGetSerialNumber; // [esp+18h] [ebp-B0h]
  CHAR LibFileName[132]; // [esp+1Ch] [ebp-ACh] BYREF
  FARPROC SetAppliType; // [esp+A0h] [ebp-28h]
  int v5; // [esp+A4h] [ebp-24h]
  char v6[16]; // [esp+A8h] [ebp-20h] BYREF
  HMODULE hModule; // [esp+B8h] [ebp-10h]
  int (*CheckEvaluationLimit)(void); // [esp+BCh] [ebp-Ch]
  FARPROC CheckSerialNumber; // [esp+C0h] [ebp-8h]

  v5 = 0;
  memset(Str, 0, sizeof(Str));
  memset(v6, 0, sizeof(v6));
  memset(LibFileName, 0, 0x81u);
  _searchenv(aMcsmanDll, aPath_0, LibFileName);
  if ( !strrchr(LibFileName, 92) )
  {
    strcpy(LibFileName, asc_421910);
    strcat(LibFileName, aMcsmanDll_0);
  }
  hModule = LoadLibraryA(LibFileName);
  if ( hModule )
  {
    SetAppliType = GetProcAddress(hModule, ProcName);
    if ( SetAppliType )
      v5 = ((int (__stdcall *)(int))SetAppliType)(1);
    else
      v5 = -1;
    RegGetSerialNumber = GetProcAddress(hModule, aReggetserialnu);
    if ( v5 || !RegGetSerialNumber )
    {
      v5 = -1;
    }
    else
    {
      v5 = ((int (__stdcall *)(char *, int))RegGetSerialNumber)(Str, 24);
      if ( !v5 && !strlen(Str) )
        v5 = -1;
    }
    CheckSerialNumber = GetProcAddress(hModule, aCheckserialnum);
    if ( v5 || !CheckSerialNumber )
      v5 = -1;
    else
      v5 = ((int (__stdcall *)(char *))CheckSerialNumber)(Str);
    if ( v5 == -1 )
    {
      printf("Serial number is wrong.\n");
      FreeLibrary(hModule);
      return v5;
    }
    RegGetSerialNumber = GetProcAddress(hModule, aReggetinstalli);
    if ( v5 || !RegGetSerialNumber )
      v5 = -1;
    else
      v5 = ((int (__stdcall *)(char *, int))RegGetSerialNumber)(v6, 16);
    CheckEvaluationLimit = GetProcAddress(hModule, aCheckevaluatio);
    if ( v5 || !CheckEvaluationLimit )
      v5 = -1;
    else
      v5 = CheckEvaluationLimit();
    if ( v5 == -1 )
      printf("The evaluation period has ended.\n");
  }
  else
  {
    printf("An indispensable module is not found.\n");
    v5 = -1;
  }
  FreeLibrary(hModule);
  return v5;
}

//----- (004111A0) --------------------------------------------------------
int __cdecl sub_4111A0(int C)
{
  int result; // eax
  int v2; // ebx
  int v3; // eax
  int v4; // eax
  int v5; // eax
  unsigned __int16 DestStr[4]; // [esp+4h] [ebp-8h] BYREF

  if ( dword_425668 )
  {
    v2 = C;
    if ( C >= 256 || ((int)SrcSizeInBytes <= 1 ? (v3 = *((_BYTE *)off_421D80 + 2 * C) & 2) : (v3 = _isctype(C, 2)), v3) )
    {
      if ( *((char *)off_421D80 + 2 * BYTE1(v2) + 1) >= 0 )
      {
        LOWORD(C) = (unsigned __int8)v2;
        v4 = 1;
      }
      else
      {
        LOBYTE(C) = BYTE1(v2);
        *(_WORD *)((char *)&C + 1) = (unsigned __int8)v2;
        v4 = 2;
      }
      v5 = sub_413A90(dword_425668, 0x200u, (LPCSTR)&C, (LPCWCH)v4, (LPSTR)DestStr, 3, 0, 1);
      if ( v5 )
      {
        if ( v5 == 1 )
          return LOBYTE(DestStr[0]);
        else
          return DestStr[0];
      }
      else
      {
        return v2;
      }
    }
    else
    {
      return v2;
    }
  }
  else
  {
    result = C;
    if ( C >= 97 && C <= 122 )
      return C - 32;
  }
  return result;
}
// 421D80: using guessed type void *off_421D80;
// 4111A0: using guessed type unsigned __int16 DestStr[4];

//----- (00412C60) --------------------------------------------------------
int __cdecl sub_412C60(int a1)
{
  UINT SystemCP; // ecx
  int v3; // edx
  _DWORD *v4; // eax
  UINT MaxCharSize; // ecx
  BYTE *v6; // edx
  unsigned int v7; // ecx
  unsigned int i; // eax
  BYTE v9; // al
  unsigned int j; // eax
  unsigned int v11; // edi
  int v12; // ebx
  unsigned __int8 *v13; // ebp
  unsigned __int8 *v14; // esi
  unsigned int v15; // ecx
  unsigned int v16; // eax
  char v17; // dl
  unsigned __int8 v18; // al
  LCID v19; // eax
  int v20; // ecx
  int v21; // edx
  int v22; // eax
  struct _cpinfo CPInfo; // [esp+10h] [ebp-14h] BYREF
  UINT v24; // [esp+28h] [ebp+4h]

  SystemCP = getSystemCP(a1);
  v24 = SystemCP;
  if ( SystemCP == CodePage )
    return 0;
  if ( SystemCP )
  {
    v3 = 0;
    v4 = &unk_421C78;
    while ( *v4 != SystemCP )
    {
      v4 += 12;
      ++v3;
      if ( v4 >= dword_421D68 )
      {
        if ( GetCPInfo(SystemCP, &CPInfo) )
        {
          memset(&unk_425428, 0, 0x100u);
          MaxCharSize = CPInfo.MaxCharSize;
          *((_BYTE *)&unk_425428 + 256) = 0;
          CodePage = v24;
          Locale = 0;
          if ( MaxCharSize <= 1 )
          {
            dword_445FC8 = 0;
          }
          else
          {
            if ( CPInfo.LeadByte[0] )
            {
              v6 = &CPInfo.LeadByte[1];
              do
              {
                if ( !*v6 )
                  break;
                v7 = *v6;
                for ( i = *(v6 - 1); i <= v7; ++i )
                  byte_425429[i] |= 4u;
                v9 = v6[1];
                v6 += 2;
              }
              while ( v9 );
            }
            for ( j = 1; j < 0xFF; ++j )
              byte_425429[j] |= 8u;
            Locale = CPtoLCID(v24);
            dword_445FC8 = 1;
          }
          dword_425638 = 0;
          dword_42563C = 0;
          dword_425640 = 0;
          sub_412F60();
          return 0;
        }
        else if ( dword_425644 )
        {
          setSBCS();
          sub_412F60();
          return 0;
        }
        else
        {
          return -1;
        }
      }
    }
    memset(&unk_425428, 0, 0x100u);
    *((_BYTE *)&unk_425428 + 256) = 0;
    v11 = 0;
    v12 = 12 * v3;
    v13 = (unsigned __int8 *)&unk_421C88 + 48 * v3;
    do
    {
      v14 = v13;
      if ( *v13 )
      {
        do
        {
          if ( !v14[1] )
            break;
          v15 = v14[1];
          v16 = *v14;
          if ( v16 <= v15 )
          {
            v17 = byte_421C70[v11];
            do
              byte_425429[v16++] |= v17;
            while ( v16 <= v15 );
          }
          v18 = v14[2];
          v14 += 2;
        }
        while ( v18 );
      }
      ++v11;
      v13 += 8;
    }
    while ( v11 < 4 );
    dword_445FC8 = 1;
    CodePage = v24;
    v19 = CPtoLCID(v24);
    v20 = dword_421C7C[v12];
    v21 = dword_421C80[v12];
    Locale = v19;
    dword_425638 = v20;
    v22 = dword_421C7C[v12 + 2];
    dword_42563C = v21;
    dword_425640 = v22;
    sub_412F60();
    return 0;
  }
  else
  {
    setSBCS();
    sub_412F60();
    return 0;
  }
}
// 412E70: using guessed type _DWORD __cdecl getSystemCP(_DWORD);
// 412EC0: using guessed type _DWORD __cdecl CPtoLCID(_DWORD);
// 412F20: using guessed type int setSBCS(void);
// 421C7C: using guessed type int dword_421C7C[];
// 421C80: using guessed type int dword_421C80[];
// 421D68: using guessed type _DWORD dword_421D68[2];
// 425638: using guessed type int dword_425638;
// 42563C: using guessed type int dword_42563C;
// 425640: using guessed type int dword_425640;
// 425644: using guessed type int dword_425644;
// 445FC8: using guessed type int dword_445FC8;

//----- (00412F60) --------------------------------------------------------
unsigned int sub_412F60()
{
  unsigned int i; // eax
  BYTE v1; // al
  BYTE *v2; // edx
  unsigned int v3; // ecx
  unsigned int result; // eax
  WORD *v5; // edx
  struct _cpinfo CPInfo; // [esp+4h] [ebp-514h] BYREF
  CHAR SrcStr[256]; // [esp+18h] [ebp-500h] BYREF
  CHAR DestStr[256]; // [esp+118h] [ebp-400h] BYREF
  CHAR v9[256]; // [esp+218h] [ebp-300h] BYREF
  WORD CharType[256]; // [esp+318h] [ebp-200h] BYREF

  if ( GetCPInfo(CodePage, &CPInfo) )
  {
    for ( i = 0; i < 0x100; ++i )
      SrcStr[i] = i;
    v1 = CPInfo.LeadByte[0];
    SrcStr[0] = 32;
    if ( CPInfo.LeadByte[0] )
    {
      v2 = &CPInfo.LeadByte[1];
      do
      {
        v3 = *v2;
        if ( v1 <= v3 )
          memset(&SrcStr[v1], 0x20u, v3 - v1 + 1);
        v1 = v2[1];
        v2 += 2;
      }
      while ( v1 );
    }
    sub_417670(1u, SrcStr, 256, CharType, CodePage, Locale, 0);
    sub_413A90(Locale, 0x100u, SrcStr, (LPCWCH)0x100, DestStr, 256, CodePage, 0);
    sub_413A90(Locale, 0x200u, SrcStr, (LPCWCH)0x100, v9, 256, CodePage, 0);
    result = 0;
    v5 = CharType;
    do
    {
      if ( (*v5 & 1) != 0 )
      {
        byte_425429[result] |= 0x10u;
        byte_425530[result] = DestStr[result];
      }
      else if ( (*v5 & 2) != 0 )
      {
        byte_425429[result] |= 0x20u;
        byte_425530[result] = v9[result];
      }
      else
      {
        byte_425530[result] = 0;
      }
      ++result;
      ++v5;
    }
    while ( result < 0x100 );
  }
  else
  {
    for ( result = 0; result < 0x100; ++result )
    {
      if ( result < 0x41 || result > 0x5A )
      {
        if ( result < 0x61 || result > 0x7A )
        {
          byte_425530[result] = 0;
        }
        else
        {
          byte_425429[result] |= 0x20u;
          byte_425530[result] = result - 32;
        }
      }
      else
      {
        byte_425429[result] |= 0x10u;
        byte_425530[result] = result + 32;
      }
    }
  }
  return result;
}
// 412F60: using guessed type CHAR SrcStr[256];
// 412F60: using guessed type CHAR DestStr[256];
// 412F60: using guessed type CHAR var_300[256];

//----- (00413140) --------------------------------------------------------
UINT sub_413140()
{
  return dword_445FC8 != 0 ? CodePage : 0;
}
// 445FC8: using guessed type int dword_445FC8;

//----- (00413A90) --------------------------------------------------------
int __cdecl sub_413A90(
        LCID Locale,
        DWORD dwMapFlags,
        LPCSTR lpSrcStr,
        LPCWCH lpWideCharStr,
        LPSTR lpDestStr,
        int cchDest,
        UINT CodePage,
        int a8)
{
  int result; // eax
  LPCWCH v9; // esi
  UINT v10; // ebp
  int v11; // edi
  WCHAR *v12; // ebx
  int v13; // eax
  int v14; // esi
  WCHAR *v15; // eax
  WCHAR *lpWideCharStra; // [esp+20h] [ebp+10h]

  result = dword_425658;
  if ( !dword_425658 )
  {
    if ( LCMapStringW(0, 0x100u, &String2, 1, 0, 0) )
    {
      result = 1;
    }
    else
    {
      if ( !LCMapStringA(0, 0x100u, String1, 1, 0, 0) )
        return 0;
      result = 2;
    }
    dword_425658 = result;
  }
  v9 = lpWideCharStr;
  if ( (int)lpWideCharStr > 0 )
  {
    v9 = (LPCWCH)strncnt(lpSrcStr, lpWideCharStr);
    result = dword_425658;
  }
  if ( result == 2 )
    return LCMapStringA(Locale, dwMapFlags, lpSrcStr, (int)v9, lpDestStr, cchDest);
  if ( result == 1 )
  {
    v10 = CodePage;
    lpWideCharStra = 0;
    if ( !CodePage )
    {
      CodePage = dword_425678;
      v10 = dword_425678;
    }
    result = MultiByteToWideChar(v10, a8 != 0 ? 9 : 1, lpSrcStr, (int)v9, 0, 0);
    v11 = result;
    if ( result )
    {
      result = (int)malloc(2 * result);
      v12 = (WCHAR *)result;
      if ( result )
      {
        if ( MultiByteToWideChar(v10, 1u, lpSrcStr, (int)v9, (LPWSTR)result, v11) )
        {
          v13 = LCMapStringW(Locale, dwMapFlags, v12, v11, 0, 0);
          v14 = v13;
          if ( v13 )
          {
            if ( (dwMapFlags & 0x400) != 0 )
            {
              if ( !cchDest || v13 <= cchDest && LCMapStringW(Locale, dwMapFlags, v12, v11, (LPWSTR)lpDestStr, cchDest) )
                goto LABEL_22;
              goto LABEL_30;
            }
            v15 = (WCHAR *)malloc(2 * v13);
            lpWideCharStra = v15;
            if ( v15 )
            {
              if ( LCMapStringW(Locale, dwMapFlags, v12, v11, v15, v14) )
              {
                if ( cchDest )
                {
                  v14 = WideCharToMultiByte(CodePage, 0x220u, lpWideCharStra, v14, lpDestStr, cchDest, 0, 0);
                  if ( v14 )
                  {
LABEL_22:
                    free(v12);
                    free(lpWideCharStra);
                    return v14;
                  }
                }
                else
                {
                  v14 = WideCharToMultiByte(CodePage, 0x220u, lpWideCharStra, v14, 0, 0, 0, 0);
                  if ( v14 )
                    goto LABEL_22;
                }
              }
            }
          }
        }
LABEL_30:
        free(v12);
        free(lpWideCharStra);
        return 0;
      }
    }
  }
  return result;
}
// 413CC0: using guessed type _DWORD __cdecl strncnt(_DWORD, _DWORD);
// 425658: using guessed type int dword_425658;

//----- (00413EB0) --------------------------------------------------------
int __cdecl sub_413EB0(int a1)
{
  int v1; // edi
  void *v2; // eax
  int v3; // edi

  if ( !_isatty(*(_DWORD *)(a1 + 16)) )
    return 0;
  if ( (FILE *)a1 == &File )
  {
    v1 = 0;
  }
  else
  {
    if ( (_UNKNOWN *)a1 != &unk_421A30 )
      return 0;
    v1 = 1;
  }
  ++dword_425424;
  if ( (*(_DWORD *)(a1 + 12) & 0x10C) != 0 )
    return 0;
  if ( dword_425680[v1] || (v2 = malloc(0x1000u), (dword_425680[v1] = (int)v2) != 0) )
  {
    v3 = dword_425680[v1];
    *(_DWORD *)(a1 + 24) = 4096;
    *(_DWORD *)(a1 + 8) = v3;
    *(_DWORD *)a1 = v3;
    *(_DWORD *)(a1 + 4) = 4096;
  }
  else
  {
    *(_DWORD *)(a1 + 8) = a1 + 20;
    *(_DWORD *)a1 = a1 + 20;
    *(_DWORD *)(a1 + 24) = 2;
    *(_DWORD *)(a1 + 4) = 2;
  }
  *(_DWORD *)(a1 + 12) |= 0x1102u;
  return 1;
}
// 425424: using guessed type int dword_425424;
// 425680: using guessed type int dword_425680[];

//----- (00417670) --------------------------------------------------------
int __cdecl sub_417670(
        DWORD dwInfoType,
        LPCSTR lpSrcStr,
        int cchSrc,
        LPWORD lpCharType,
        UINT CodePage,
        LCID Locale,
        int a7)
{
  int result; // eax
  WCHAR *v8; // edi
  LCID v9; // eax
  UINT v10; // ebx
  int v11; // eax
  int v12; // esi
  WCHAR *v13; // eax
  int v14; // eax
  BOOL StringTypeW; // esi
  WORD CharType; // [esp+12h] [ebp-2h] BYREF

  result = dword_4256B4;
  v8 = 0;
  if ( !dword_4256B4 )
  {
    if ( GetStringTypeW(1u, &String2, 1, &CharType) )
    {
      result = 1;
      dword_4256B4 = 1;
    }
    else
    {
      if ( !GetStringTypeA(0, 1u, String1, 1, &CharType) )
        return 0;
      result = 2;
      dword_4256B4 = 2;
    }
  }
  if ( result == 2 )
  {
    v9 = Locale;
    if ( !Locale )
      v9 = dword_425668;
    return GetStringTypeA(v9, dwInfoType, lpSrcStr, cchSrc, lpCharType);
  }
  else if ( result == 1 )
  {
    v10 = CodePage;
    if ( !CodePage )
      v10 = dword_425678;
    v11 = MultiByteToWideChar(v10, a7 != 0 ? 9 : 1, lpSrcStr, cchSrc, 0, 0);
    v12 = v11;
    if ( v11
      && (v13 = (WCHAR *)calloc(2u, v11), (v8 = v13) != 0)
      && (v14 = MultiByteToWideChar(v10, 1u, lpSrcStr, cchSrc, v13, v12)) != 0 )
    {
      StringTypeW = GetStringTypeW(dwInfoType, v8, v14, lpCharType);
      free(v8);
      return StringTypeW;
    }
    else
    {
      free(v8);
      return 0;
    }
  }
  return result;
}
// 4256B4: using guessed type int dword_4256B4;

//----- (004195B0) --------------------------------------------------------
BOOL __cdecl sub_4195B0(_DWORD *a1)
{
  int v2; // eax
  int v3; // ecx
  int v4; // eax
  int v5; // [esp-24h] [ebp-2Ch]
  int wMonth; // [esp-20h] [ebp-28h]
  int wDay; // [esp-1Ch] [ebp-24h]
  int wDayOfWeek; // [esp-18h] [ebp-20h]
  int wHour; // [esp-10h] [ebp-18h]
  int wMinute; // [esp-Ch] [ebp-14h]
  int wSecond; // [esp-8h] [ebp-10h]
  int wMilliseconds; // [esp-4h] [ebp-Ch]

  if ( !dword_4242A4 )
    return 0;
  v2 = a1[5];
  if ( v2 != dword_424338 || v2 != dword_424348 )
  {
    if ( dword_4257E0 )
    {
      if ( TimeZoneInformation.DaylightDate.wYear )
        cvtdate(
          1,
          0,
          v2,
          TimeZoneInformation.DaylightDate.wMonth,
          0,
          0,
          TimeZoneInformation.DaylightDate.wDay,
          TimeZoneInformation.DaylightDate.wHour,
          TimeZoneInformation.DaylightDate.wMinute,
          TimeZoneInformation.DaylightDate.wSecond,
          TimeZoneInformation.DaylightDate.wMilliseconds);
      else
        cvtdate(
          1,
          1,
          v2,
          TimeZoneInformation.DaylightDate.wMonth,
          TimeZoneInformation.DaylightDate.wDay,
          TimeZoneInformation.DaylightDate.wDayOfWeek,
          0,
          TimeZoneInformation.DaylightDate.wHour,
          TimeZoneInformation.DaylightDate.wMinute,
          TimeZoneInformation.DaylightDate.wSecond,
          TimeZoneInformation.DaylightDate.wMilliseconds);
      if ( TimeZoneInformation.StandardDate.wYear )
      {
        cvtdate(
          0,
          0,
          a1[5],
          TimeZoneInformation.StandardDate.wMonth,
          0,
          0,
          TimeZoneInformation.StandardDate.wDay,
          TimeZoneInformation.StandardDate.wHour,
          TimeZoneInformation.StandardDate.wMinute,
          TimeZoneInformation.StandardDate.wSecond,
          TimeZoneInformation.StandardDate.wMilliseconds);
        goto LABEL_14;
      }
      wMilliseconds = TimeZoneInformation.StandardDate.wMilliseconds;
      wSecond = TimeZoneInformation.StandardDate.wSecond;
      wMinute = TimeZoneInformation.StandardDate.wMinute;
      wHour = TimeZoneInformation.StandardDate.wHour;
      wDayOfWeek = TimeZoneInformation.StandardDate.wDayOfWeek;
      wDay = TimeZoneInformation.StandardDate.wDay;
      wMonth = TimeZoneInformation.StandardDate.wMonth;
      v5 = a1[5];
    }
    else
    {
      cvtdate(1, 1, v2, 4, 1, 0, 0, 2, 0, 0, 0);
      wMilliseconds = 0;
      wSecond = 0;
      wMinute = 0;
      wHour = 2;
      wDayOfWeek = 0;
      wDay = 5;
      wMonth = 10;
      v5 = a1[5];
    }
    cvtdate(0, 1, v5, wMonth, wDay, wDayOfWeek, 0, wHour, wMinute, wSecond, wMilliseconds);
  }
LABEL_14:
  v3 = a1[7];
  if ( dword_42433C < dword_42434C )
  {
    if ( v3 >= dword_42433C && v3 <= dword_42434C )
    {
      if ( v3 > dword_42433C && v3 < dword_42434C )
        return 1;
      goto LABEL_25;
    }
    return 0;
  }
  if ( v3 < dword_42434C || v3 > dword_42433C )
    return 1;
  if ( v3 > dword_42434C && v3 < dword_42433C )
    return 0;
LABEL_25:
  v4 = 1000 * (*a1 + 60 * (a1[1] + 60 * a1[2]));
  if ( v3 == dword_42433C )
    return v4 >= dword_424340;
  else
    return v4 < dword_424350;
}
// 419820: using guessed type _DWORD __cdecl cvtdate(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD);
// 4242A4: using guessed type int dword_4242A4;
// 424338: using guessed type int dword_424338;
// 42433C: using guessed type int dword_42433C;
// 424340: using guessed type int dword_424340;
// 424348: using guessed type int dword_424348;
// 42434C: using guessed type int dword_42434C;
// 424350: using guessed type int dword_424350;
// 4257E0: using guessed type int dword_4257E0;

//----- (0041B3F0) --------------------------------------------------------
int __cdecl sub_41B3F0(int C)
{
  int result; // eax
  int v2; // ebx
  int v3; // eax
  int v4; // eax
  int v5; // eax
  unsigned __int16 DestStr[4]; // [esp+4h] [ebp-8h] BYREF

  if ( dword_425668 )
  {
    v2 = C;
    if ( C >= 256 || ((int)SrcSizeInBytes <= 1 ? (v3 = *((_BYTE *)off_421D80 + 2 * C) & 1) : (v3 = _isctype(C, 1)), v3) )
    {
      if ( *((char *)off_421D80 + 2 * BYTE1(v2) + 1) >= 0 )
      {
        LOWORD(C) = (unsigned __int8)v2;
        v4 = 1;
      }
      else
      {
        LOBYTE(C) = BYTE1(v2);
        *(_WORD *)((char *)&C + 1) = (unsigned __int8)v2;
        v4 = 2;
      }
      v5 = sub_413A90(dword_425668, 0x100u, (LPCSTR)&C, (LPCWCH)v4, (LPSTR)DestStr, 3, 0, 1);
      if ( v5 )
      {
        if ( v5 == 1 )
          return LOBYTE(DestStr[0]);
        else
          return DestStr[0];
      }
      else
      {
        return v2;
      }
    }
    else
    {
      return v2;
    }
  }
  else
  {
    result = C;
    if ( C >= 65 && C <= 90 )
      return C + 32;
  }
  return result;
}
// 421D80: using guessed type void *off_421D80;
// 41B3F0: using guessed type unsigned __int16 DestStr[4];

//----- (0041B4F0) --------------------------------------------------------
int __cdecl sub_41B4F0(char *String1, char *String2)
{
  char *v3; // edi
  char *v4; // ebp
  unsigned __int16 v5; // ax
  unsigned __int8 v6; // dl
  unsigned __int16 v7; // si
  int v8; // eax
  unsigned __int16 v9; // ax
  unsigned __int8 v10; // cl
  int v11; // eax

  if ( !CodePage )
    return _strcmpi(String1, String2);
  v3 = String2;
  v4 = String1;
  do
  {
    v5 = (unsigned __int8)*v4;
    v6 = *v4++;
    if ( (byte_425429[v6] & 4) != 0 )
    {
      if ( *v4 )
      {
        v8 = sub_413A90(Locale, 0x200u, v4 - 1, (LPCWCH)2, (LPSTR)&String2, 2, CodePage, 1);
        if ( v8 == 1 )
        {
          v7 = (unsigned __int8)String2;
          ++v4;
        }
        else
        {
          if ( v8 != 2 )
            return 0x7FFFFFFF;
          v7 = BYTE1(String2) + ((unsigned __int8)String2 << 8);
          ++v4;
        }
      }
      else
      {
        v7 = 0;
      }
    }
    else if ( (byte_425429[v5] & 0x10) == 16 )
    {
      v7 = (unsigned __int8)byte_425530[v5];
    }
    else
    {
      v7 = v5;
    }
    v9 = (unsigned __int8)*v3;
    v10 = *v3++;
    if ( (byte_425429[v10] & 4) != 0 )
    {
      if ( *v3 )
      {
        v11 = sub_413A90(Locale, 0x200u, v3 - 1, (LPCWCH)2, (LPSTR)&String2, 2, CodePage, 1);
        if ( v11 == 1 )
        {
          v9 = (unsigned __int8)String2;
          ++v3;
        }
        else
        {
          if ( v11 != 2 )
            return 0x7FFFFFFF;
          v9 = BYTE1(String2) + ((unsigned __int8)String2 << 8);
          ++v3;
        }
      }
      else
      {
        v9 = 0;
      }
    }
    else if ( (byte_425429[v9] & 0x10) == 16 )
    {
      v9 = (unsigned __int8)byte_425530[v9];
    }
    if ( v9 != v7 )
      return v9 < v7 ? 1 : -1;
  }
  while ( v7 );
  return 0;
}

//----- (0041B6C0) --------------------------------------------------------
unsigned int __cdecl sub_41B6C0(unsigned int SrcStr)
{
  unsigned int v1; // ebx
  CHAR DestStr[4]; // [esp+4h] [ebp-8h] BYREF

  v1 = SrcStr;
  if ( SrcStr <= 0xFF )
  {
    if ( (byte_425429[SrcStr] & 0x10) == 16 )
      return (unsigned __int8)byte_425530[SrcStr];
  }
  else
  {
    BYTE1(SrcStr) = SrcStr;
    LOBYTE(SrcStr) = BYTE1(v1);
    if ( (byte_425429[BYTE1(v1)] & 4) != 0
      && sub_413A90(Locale, 0x100u, (LPCSTR)&SrcStr, (LPCWCH)2, DestStr, 2, CodePage, 1) )
    {
      return (unsigned __int8)DestStr[1] + ((unsigned __int8)DestStr[0] << 8);
    }
  }
  return v1;
}

// nfuncs=392 queued=204 decompiled=204 lumina nreq=0 worse=0 better=0
// ALL OK, 204 function(s) have been successfully decompiled
